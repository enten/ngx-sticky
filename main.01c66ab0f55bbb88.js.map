{"version":3,"file":"main.01c66ab0f55bbb88.js","mappings":"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","names":["rxjs_1","operators_1","sticky_container_directive_1","sticky_tokens_1","coercion_1","__webpack_require__","config_subject_1","dom_1","intersection_1","exports","disabled","aliasKey","defaultValue","coercion","thresholds","NgxInViewportDirective","constructor","rootContainer","stickyContainer","elementRef","ngZone","_win","this","core_1","_container","container","registerIntersection","config","config$","getValue","state","_intersectionState","ngOnChanges","changes","nextChanges","ngAfterViewInit","_initMonitoring","ngOnDestroy","unregisterIntersection","_destroyed$","isStopped","next","complete","_destroyMonitoring","beforeRefresh","fastUpdate","_intersection","disableIntersection","nextKeyValue","skipCoercion","enableIntersection","getIntersection","_computeIntersection","refresh","computation","_refresh$","update","updateStickies","elementRect","nativeElement","height","top","_createMonitoringObservable","pipe","_monitoring","unsubscribe","runOutsideAngular","handleRefreshSubscription","leading","trailing","subscribe","_refreshIntersection","triggerUpdateSubscription","add","_intersectionComputation","intersectionComputation","run","intersectionState","oldEntry","_intersectionCrossed","newEntry","oldRatio","ratio","newRatio","crossedThreshold","snap","intersection","isNaN","_intersectionThreshold","intersectionThreshold","emit","i0","selectors","NgxStickyBaseBoundaryController","NgxStickyBaseContainerController","disableAllStickies","disableStickies","containers","enableAllStickies","enableStickies","getStickedOffset","position","viewportTop","getContainer","viewportHeight","getViewportHeight","stickies","stickyController","push","getSticky","stickyEngine","fixViewportTop","userOffsetTop","viewportTopOffsetless","viewportTopFixed","containerParent","registerContainer","containerController","registerBoundary","boundaryController","boundaries","intersectionController","intersectionIndex","collections_1","intersections","_intersectionSnaps","_intersectionComputations","registerSticky","stickyIndex","_stickySnaps","_stickyComputations","updateAllStickies","length","getViewportTop","stickyComputation","stickySnap","_stickyController","snapSticky","determineStickyState","intersectionSnap","snapIntersection","determineIntersectionState","unregisterContainer","unregisterBoundary","boundary","unregisterSticky","sticky","sticky_base_container_controller_1","offsetTop","offsetBottom","unstacked","NgxStickyBaseContainerDirective","super","_getDocumentHeight","_getDocumentWidth","destroyed$","createScrollPlan","target","scrollPlan","scrollToFn","element","scrollTo","bind","targetContainer","targetContainerScrollPlan","containsElement","elementAsNumber","parseFloat","querySelector","document","elementTop","scrollToOptions","left","getViewportLeft","tagName","contains","containerScrollPlan","targetLine","targetTopFixed","_computeContainer","scrollToTop","scrollStep","_updateStickies$","containerRect","scrollHeight","width","scrollWidth","_createMonitoringInputsObservable","_createMonitoringScrollObservable","_createMonitoringWindowObservable","passive","_updateStickies","inputs","NgxStickyBaseController","sticky_base_boundary_controller_1","NgxStickyBoundaryDirective","ngOnInit","_boundary","getBoundary","_computeBoundary","boundaryStyle","getComputedStyle","paddingTop","paddingBottom","sticky_base_container_directive_1","NgxStickyContainerDirective","stickyContainerParent","offsetHeight","scrollLeft","scrollTop","NgxStickyEngine","computeStickyBoundary","directionDown","spot","boundaryHeight","boundaryTop","boundaryLeft","boundaryWidth","spotPoint","computeStickyStickedLine","positionBottom","stickedTop","stickedHeight","computeStickySortPoint","sortPoint","enter","exit","stateKey","join","maxHeightVisible","Math","min","offsetSticked","intersecting","offsetStucked","stickyComputed","_stickyComputedState","_stickyComputed","boundaryOffset","_stickedTop","_stickedHeight","sticked","sticky_helpers_1","maxStickyUnstackedHeight","stickedOffset","_sticky","_elementHeight","exitSticky","direction","boundariesMap","stickiesComputed","offsetSpacer","stickyComputedBoundaryRight","_stickyIndex","_directionDown","_positionBottom","_stickyComputedBoundaryRight","boundaryKey","sort","a","b","factory","NgxStickyRootContainerController","NgxStickySpotDirective","stickySpotHeight","_stickySpotHeight","value","utils_1","sticky_base_controller_1","sticky_boundary_directive_1","from_image_events_1","classes","spacer","spotHeight","NgxStickyDirective","stickyBoundary","stickyParent","renderer","attrDataStickyState","cssClassSticky","cssClassStickyNormal","cssClassStickySticked","cssClassStickyStucked","cssClassStickyDisabled","_stickyState","_preventNestedStickyError","disableSticky","enableSticky","_computeSticky","_refreshStickyElement","spotRect","_getStickyElementStyle","win","ghost","_spacerGenerated","ghostParent","offsetParent","ghostParentIsRootElement","body","documentElement","ghostRelativeRect","ghostStyle","elementWidth","boxSizing","borderLeft","borderRight","paddingLeft","paddingRight","elementLeft","ghostRect","offsetLeft","right","bottom","float","margin","ghostParentRect","_getStickyGhostStyle","elementStyle","ghostHeight","borderTopWidth","borderBottomWidth","style","maxHeight","minHeight","borderTop","borderBottom","cssFloat","marginTop","marginBottom","marginLeft","marginRight","_hideStickyGhost","setStyle","_refreshSticky","_insertStickyGhostGenerated","createElement","addClass","insertBefore","parentElement","nestedStickyError","Error","logLevel","logLevelLogger","console","_stickyElementState","_stickyComputation","stickyState","_restoreStickyElementStyle","_saveStickyElementStyle","_showStickyGhost","_refreshStickyGhost","_elementOriginStyle","remove","display","isStickyPositionBottom","isStickyDirectionDown","coerceStickyPosition","coerceStickyDirection","getStuckedPositionTop","elementHeight","NgxStickyModule","common_1","providedIn","window","_isNumberValue","Number","coerceBooleanProperty","coerceNumberProperty","fallbackValue","addEntry","set","entry","entryIndex","indexOf","deleteEntry","splice","input_subject_1","ConfigSubject","schema","_config","_configChanges","_aliases","inputKeys","Object","keys","inputKey","inputOptions","input","pushChangeSubscription","change$","inputChange","_configChanged","currentValue","_pushChangesSubscription","getKeyValue","partialConfig","options","key","changes$","n","changeKeys","getDocumentHeightFactory","documentHeightGetters","clientHeight","documentHeightGetter","documentHeight","_documentHeightGetter","_documentHeight","getDocumentWidthFactory","documentWidthGetters","offsetWidth","clientWidth","documentWidthGetter","documentWidth","_documentWidthGetter","_documentWidth","getElementAbsoluteRect","rect","currentElement","getElementRelativeRect","currentElementStyle","getWindowViewportHeight","innerHeight","getWindowViewportLeft","getBoundingClientRect","scrollX","getWindowViewportTop","scrollY","isElementScrollableY","overflowY","setElementStyles","styles","propKeys","prop","removeStyle","fromImageEvents","images$","addImage","event","querySelectorAll","forEach","fromMediaQuery","query","matchMedia","mql","initEvent","matches","media","initMqlEvent","MediaQueryListEvent","type","mql$","onQueryChange","mqlEvent","call","removeListener","addListener","tslib_1","InputSubject","_value","_valueSetted","firstChange","_firstChange","previousValue","coerceIntersectionThresholds","split","map","x","Array","isArray","getCrossedThreshold","threshold","AppRoutingModule","router_1","forRoot","public_api_1","AppComponent","changeDetectorRef","smallBreakpoint$","_smallBreakpointSubscription","_isSmallScreen","$event","ctx","app_routing_module_1","app_component_1","AppModule","bootstrap","platform_browser_1","production","app_module_1","environment_1","__NgCli_bootstrap_1","bootstrapModule","catch","err","error"],"sourceRoot":"webpack:///","sources":["./projects/ngx-sticky/src/lib/in-viewport.directive.ts","./projects/ngx-sticky/src/lib/sticky-base-boundary.controller.ts","./projects/ngx-sticky/src/lib/sticky-base-container.controller.ts","./projects/ngx-sticky/src/lib/sticky-base-container.directive.ts","./projects/ngx-sticky/src/lib/sticky-base.controller.ts","./projects/ngx-sticky/src/lib/sticky-boundary.directive.ts","./projects/ngx-sticky/src/lib/sticky-container.directive.ts","./projects/ngx-sticky/src/lib/sticky-engine.ts","./projects/ngx-sticky/src/lib/sticky-root-container.controller.ts","./projects/ngx-sticky/src/lib/sticky-spot.directive.ts","./projects/ngx-sticky/src/lib/sticky.directive.ts","./projects/ngx-sticky/src/lib/sticky.helpers.ts","./projects/ngx-sticky/src/lib/sticky.module.ts","./projects/ngx-sticky/src/lib/sticky.tokens.ts","./projects/ngx-sticky/src/lib/utils/coercion.ts","./projects/ngx-sticky/src/lib/utils/collections.ts","./projects/ngx-sticky/src/lib/utils/config-subject.ts","./projects/ngx-sticky/src/lib/utils/dom.ts","./projects/ngx-sticky/src/lib/utils/from-image-events.ts","./projects/ngx-sticky/src/lib/utils/from-media-query.ts","./projects/ngx-sticky/src/lib/utils/index.ts","./projects/ngx-sticky/src/lib/utils/input-subject.ts","./projects/ngx-sticky/src/lib/utils/intersection.ts","./projects/ngx-sticky/src/public-api.ts","./src/app/app-routing.module.ts","./src/app/app.component.ts","./src/app/app.component.html","./src/app/app.module.ts","./src/environments/environment.prod.ts","./src/main.ts"],"sourcesContent":["import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  SimpleChanges,\n  forwardRef,\n} from '@angular/core';\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\nimport { distinctUntilChanged, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\n\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\nimport {\n  NgxIntersection,\n  NgxIntersectionComputation,\n  NgxIntersectionController,\n  NgxIntersectionState,\n  NgxStickyContainerController,\n} from './sticky.types';\nimport { coerceBooleanProperty } from './utils/coercion';\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\nimport { getElementAbsoluteRect } from './utils/dom';\nimport { coerceIntersectionThresholds, getCrossedThreshold } from './utils/intersection';\n\n\nexport interface NgxIntersectionConfig {\n  disabled: boolean;\n  thresholds: number[];\n}\n\n\nexport const NGX_BASE_INTERSECTION_CONFIG_SCHEMA: ConfigSubjectSchema<NgxIntersectionConfig> = {\n  disabled: {\n    aliasKey: 'intersectionDisabled',\n    defaultValue: false,\n    coercion: coerceBooleanProperty,\n  },\n  thresholds: {\n    aliasKey: 'intersectionThresholds',\n    defaultValue: [ 0, 1 ],\n    coercion: coerceIntersectionThresholds,\n  },\n};\n\n\n@Directive({\n  selector: '[ngxInViewport], [ngx-in-viewport], ngx-in-viewport',\n  exportAs: 'ngxInViewport',\n})\nexport class NgxInViewportDirective implements NgxIntersectionController, AfterViewInit, OnChanges, OnDestroy {\n  /**\n   * Disable intersection.\n   *\n   * Defaults to `false`.\n   */\n  @Input()\n  intersectionDisabled: boolean;\n\n  /**\n   * Intersection thresholds.\n   *\n   * Defaults to `[ 0, 1 ]`.\n   */\n  @Input()\n  intersectionThresholds: number[];\n\n  /**\n   * Emit intersection.\n   */\n  @Output()\n  readonly intersection = new EventEmitter<NgxIntersectionComputation>();\n\n  /**\n   * Emit intersection computation.\n   */\n  @Output()\n  readonly intersectionComputation = new EventEmitter<NgxIntersectionComputation>();\n\n  /**\n   * Emit intersection state.\n   */\n  @Output()\n  readonly intersectionState = new EventEmitter<NgxIntersectionState>();\n\n  /**\n   * Emit intersection threshold.\n   */\n  @Output()\n  readonly intersectionThreshold = new EventEmitter<number>();\n\n  get container(): NgxStickyContainerController {\n    return this._container;\n  }\n\n  get config(): NgxIntersectionConfig {\n    return this.config$.getValue();\n  }\n\n  get disabled(): boolean {\n    return this.config.disabled;\n  }\n\n  /**\n   * State of the intersection.\n   */\n  get state(): NgxIntersectionState {\n    return this._intersectionState;\n  }\n\n  /** Inputs config */\n  readonly config$ = new ConfigSubject<NgxIntersectionConfig>(NGX_BASE_INTERSECTION_CONFIG_SCHEMA);\n\n  /** Intersection container controller */\n  readonly _container: NgxStickyBaseContainerDirective;\n\n  /** Emits when the component is destroyed. */\n  readonly _destroyed$ = new Subject<void>();\n\n  /** Intersection which reflect last call of _computeIntersection() */\n  _intersection: NgxIntersection;\n\n  /** Intersection computation which reflect last call of _refreshIntersection()  */\n  _intersectionComputation: NgxIntersectionComputation;\n\n  /** Intersection computation with last threshold crossed */\n  _intersectionCrossed: NgxIntersectionComputation;\n\n  /** Last inetersection state crossed */\n  _intersectionState: NgxIntersectionState;\n\n  /** Last inetersection threshold crossed */\n  _intersectionThreshold: number;\n\n  /** Monitoring subscription which trigger update stickies and handle refresh */\n  _monitoring: Subscription;\n\n  /** Emits when refresh() is called */\n  readonly _refresh$ = new Subject<NgxIntersectionComputation>();\n\n  constructor(\n    readonly rootContainer: NgxStickyRootContainerController,\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\n    readonly stickyContainer: NgxStickyContainerDirective,\n    readonly elementRef: ElementRef<HTMLElement>,\n    readonly ngZone: NgZone,\n    @Inject(NGX_STICKY_WINDOW)\n    readonly _win: Window,\n  ) {\n    // use root container when sticky isn't in container\n    this._container = stickyContainer || rootContainer;\n\n    // register in parent container for first update calls\n    this.container.registerIntersection(this);\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.config$.nextChanges(changes);\n  }\n\n  ngAfterViewInit(): void {\n    this._initMonitoring();\n  }\n\n  ngOnDestroy(): void {\n    this.container.unregisterIntersection(this);\n\n    if (!this._destroyed$.isStopped) {\n      this._destroyed$.next();\n      this._destroyed$.complete();\n    }\n\n    this._destroyMonitoring();\n  }\n\n  beforeRefresh(fastUpdate?: boolean): void {\n    if (!fastUpdate) {\n      this._intersection = null;\n    }\n  }\n\n  disableIntersection(): void {\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\n  }\n\n  enableIntersection(): void {\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\n  }\n\n  getIntersection(): NgxIntersection {\n    if (!this._intersection) {\n      this._intersection = this._computeIntersection();\n    }\n\n    return this._intersection;\n  }\n\n  refresh(computation: NgxIntersectionComputation): void {\n    this._refresh$.next(computation);\n  }\n\n  update(fastUpdate?: boolean): void {\n    this.container.updateStickies(fastUpdate);\n  }\n\n  _computeIntersection(): NgxIntersection {\n    const config = this.config$.getValue();\n\n    const elementRect = getElementAbsoluteRect(this.elementRef.nativeElement);\n\n    return {\n      disabled: config.disabled,\n      height: elementRect.height,\n      top: elementRect.top,\n      thresholds: config.thresholds,\n    };\n  }\n\n  /**\n   * Create intersection monitoring observable.\n   */\n  _createMonitoringObservable(): Observable<boolean> {\n    return merge(\n      this.config$,\n      animationFrameScheduler,\n    ).pipe(\n      // throttleTime(0, animationFrameScheduler),\n      mapTo(false),\n    );\n  }\n\n  /**\n   * Destroy intersection monitoring subscription.\n   */\n  _destroyMonitoring(): void {\n    if (this._monitoring) {\n      this._monitoring.unsubscribe();\n      this._monitoring = null;\n    }\n  }\n\n  /**\n   * Init intersection monitoring.\n   */\n  _initMonitoring(): void {\n    if (!this._win || this._monitoring) {\n      return;\n    }\n\n    this.ngZone.runOutsideAngular(() => {\n      const handleRefreshSubscription = this._refresh$\n        .pipe(\n          takeUntil(this._destroyed$),\n          distinctUntilChanged(),\n          throttleTime(0, animationFrameScheduler, { leading: true, trailing: true }),\n          share(),\n        )\n        .subscribe(computation => {\n          this._refreshIntersection(computation);\n        });\n\n      const triggerUpdateSubscription = this._createMonitoringObservable()\n        .pipe(\n          takeUntil(this._destroyed$),\n          share(),\n        )\n        .subscribe(fastUpdate => {\n          this.update(fastUpdate);\n        });\n\n      this._monitoring = new Subscription();\n      this._monitoring.add(handleRefreshSubscription);\n      this._monitoring.add(triggerUpdateSubscription);\n    });\n  }\n\n  /**\n   * Refresh intersection with given computation.\n   *\n   * @param computation Intersection state computation\n   */\n  _refreshIntersection(computation: NgxIntersectionComputation): void {\n    this._intersectionComputation = computation;\n    this.intersectionComputation.next(computation);\n\n    if (computation.state !== this._intersectionState) {\n      this.ngZone.run(() => {\n        this._intersectionState = computation.state;\n        this.intersectionState.next(computation.state);\n      });\n    }\n\n    const oldEntry = this._intersectionCrossed;\n    const newEntry = computation;\n\n    const oldRatio = oldEntry ? oldEntry.ratio : 0;\n    const newRatio = newEntry.ratio;\n\n    // ignore when ratios are unchanged\n    if (oldEntry && oldRatio === newRatio) {\n      return;\n    }\n\n    const crossedThreshold = getCrossedThreshold(computation.snap.intersection.thresholds, oldRatio, newRatio);\n\n    // ignore when no treshold is crossed\n    if (isNaN(crossedThreshold)) {\n      return;\n    }\n\n    this._intersectionCrossed = newEntry;\n\n    this.ngZone.run(() => {\n      this._intersectionThreshold = crossedThreshold;\n      this.intersectionThreshold.next(crossedThreshold);\n\n      this.intersection.emit(newEntry);\n    });\n  }\n}\n","import {\n  NgxStickyBoundary,\n  NgxStickyBoundaryController,\n  NgxStickyContainerController,\n} from './sticky.types';\n\n\n/**\n * Abstract sticky boundary controller.\n */\nexport abstract class NgxStickyBaseBoundaryController implements NgxStickyBoundaryController {\n  abstract readonly container: NgxStickyContainerController;\n\n  abstract beforeRefresh(fastUpdate?: boolean): void;\n  abstract getBoundary(): NgxStickyBoundary;\n\n  updateStickies(fastUpdate?: boolean) {\n    this.container.updateStickies(fastUpdate);\n  }\n}\n","import { NgxStickyEngine } from './sticky-engine';\nimport {\n  NgxIntersectionComputation,\n  NgxIntersectionController,\n  NgxIntersectionSnap,\n  NgxScrollPlan,\n  NgxSticky,\n  NgxStickyBoundaryController,\n  NgxStickyComputation,\n  NgxStickyContainer,\n  NgxStickyContainerController,\n  NgxStickyController,\n  NgxStickyPosition,\n  NgxStickySnap,\n} from './sticky.types';\nimport { addEntry, deleteEntry } from './utils/collections';\n\n\n/**\n * Abstract sticky container controller.\n */\nexport abstract class NgxStickyBaseContainerController implements NgxStickyContainerController {\n  abstract readonly containerParent?: NgxStickyContainerController;\n  abstract readonly stickyEngine: NgxStickyEngine;\n\n  abstract disabled: boolean;\n\n  readonly boundaries: NgxStickyBoundaryController[] = [];\n  readonly containers: NgxStickyContainerController[] = [];\n  readonly intersections: NgxIntersectionController[] = [];\n  readonly stickies: NgxStickyController[] = [];\n\n  readonly _stickyComputations: Record<number, NgxStickyComputation> = {};\n  readonly _stickySnaps: Record<number, NgxStickySnap> = {};\n  _stickySnapContainerHeight: number;\n\n  readonly _intersectionComputations: Record<number, NgxIntersectionComputation> = {};\n  readonly _intersectionSnaps: Record<number, NgxIntersectionSnap> = {};\n\n  abstract beforeRefresh(fastUpdate?: boolean): void;\n  abstract createScrollPlan(element: number | string | HTMLElement, userOffsetTop?: number): NgxScrollPlan;\n  abstract disableStickies(): void;\n  abstract enableStickies(): void;\n  abstract getContainer(): NgxStickyContainer;\n  abstract getViewportHeight(): number;\n  abstract getViewportLeft(): number;\n  abstract getViewportTop(): number;\n  abstract scrollToTop(target: number | string | HTMLElement, userOffsetTop?: number): void;\n\n  abstract _computeContainer(): NgxStickyContainer;\n\n  disableAllStickies(): void {\n    this.disableStickies();\n\n    for (const container of this.containers) {\n      container.disableStickies();\n    }\n  }\n\n  enableAllStickies(): void {\n    this.enableStickies();\n\n    for (const container of this.containers) {\n      container.enableStickies();\n    }\n  }\n\n  getStickedOffset(position: NgxStickyPosition, viewportTop: number): number {\n    const container = this.getContainer();\n    const viewportHeight = this.getViewportHeight();\n    const stickies: NgxSticky[] = [];\n\n    for (const stickyController of this.stickies) {\n      stickies.push(stickyController.getSticky());\n    }\n\n    return this.stickyEngine.getStickedOffset(container, stickies, position, viewportHeight, viewportTop);\n  }\n\n  fixViewportTop(viewportTop: number, userOffsetTop?: number): number {\n    // const container = this.getContainer();\n    const viewportTopOffsetless = viewportTop - (userOffsetTop || 0);\n    const stickedOffsetTop = this.getStickedOffset('top', viewportTopOffsetless);\n\n    let viewportTopFixed = viewportTopOffsetless /* - container.offsetTop*/ - stickedOffsetTop;\n\n    if (this.containerParent) {\n      viewportTopFixed -= this.getContainer().top;\n    }\n\n    return viewportTopFixed;\n  }\n\n  registerContainer(containerController: NgxStickyContainerController): void {\n    addEntry(this.containers, containerController);\n  }\n\n  registerBoundary(boundaryController: NgxStickyBoundaryController): void {\n    addEntry(this.boundaries, boundaryController);\n  }\n\n  registerIntersection(intersectionController: NgxIntersectionController): void {\n    const intersectionIndex = addEntry(this.intersections, intersectionController);\n\n    if (intersectionIndex !== -1) {\n      this._intersectionSnaps[intersectionIndex] = null;\n      this._intersectionComputations[intersectionIndex] = null;\n    }\n  }\n\n  registerSticky(stickyController: NgxStickyController): void {\n    const stickyIndex = addEntry(this.stickies, stickyController);\n\n    if (stickyIndex !== -1) {\n      this._stickySnaps[stickyIndex] = null;\n      this._stickyComputations[stickyIndex] = null;\n    }\n  }\n\n  updateAllStickies(fastUpdate?: boolean): void {\n    this.updateStickies(fastUpdate);\n\n    for (const containerController of this.containers) {\n      containerController.updateAllStickies(fastUpdate);\n    }\n  }\n\n  updateStickies(fastUpdate?: boolean): void {\n    // // avoid update when there is no stickies\n    // if (!this.stickies.length) {\n    //   return;\n    // }\n\n    // // force full update when container size change\n    // if (this.getContainerHeight() !== this._stickySnapContainerHeight) {\n    //   fastUpdate = false;\n    // }\n\n    if (!fastUpdate) {\n      this.beforeRefresh(fastUpdate);\n\n      for (const boundaryController of this.boundaries) {\n        boundaryController.beforeRefresh(fastUpdate);\n      }\n\n      for (let stickyIndex = 0; stickyIndex < this.stickies.length; ++stickyIndex) {\n        this._stickyComputations[stickyIndex] = null;\n        this._stickySnaps[stickyIndex] = null;\n\n        this.stickies[stickyIndex].beforeRefresh(fastUpdate);\n      }\n\n      for (let intersectionIndex = 0; intersectionIndex < this.intersections.length; ++intersectionIndex) {\n        this._intersectionComputations[intersectionIndex] = null;\n        this._intersectionSnaps[intersectionIndex] = null;\n\n        this.intersections[intersectionIndex].beforeRefresh(fastUpdate);\n      }\n    }\n\n    //   // legacy code\n    //   const viewportHeight = this.getViewportHeight() - this.stickyOffsetTop - this.stickyOffsetBottom;\n    //   const viewportTop = this.getViewportTop() + this.getContainer().top + this.stickyOffsetTop;\n\n    const container = this.getContainer();\n    const viewportHeight = this.getViewportHeight();\n    // compute absolute viewport top\n    const viewportTop = this.getViewportTop() + this.getContainer().top;\n    let stickies: NgxSticky[];\n\n    // refresh stickies\n    for (let stickyIndex = 0; stickyIndex < this.stickies.length; ++stickyIndex) {\n      const stickyController = this.stickies[stickyIndex];\n      let stickyComputation = this._stickyComputations[stickyIndex];\n\n      if (!stickyComputation || stickyComputation.viewportTop !== viewportTop) {\n        let stickySnap = this._stickySnaps[stickyIndex];\n\n        if (!stickySnap) {\n          if (!stickies) {\n            stickies = [];\n            for (const _stickyController of this.stickies) {\n              stickies.push(_stickyController.getSticky());\n            }\n          }\n\n          stickySnap = this.stickyEngine.snapSticky(container, stickies, stickies[stickyIndex], viewportHeight);\n\n          this._stickySnaps[stickyIndex] = stickySnap;\n        }\n\n        stickyComputation = this.stickyEngine.determineStickyState(stickySnap, viewportTop);\n\n        this._stickyComputations[stickyIndex] = stickyComputation;\n      }\n\n      stickyController.refresh(stickyComputation);\n    }\n\n    // refresh intersections\n    for (let intersectionIndex = 0; intersectionIndex < this.intersections.length; ++intersectionIndex) {\n      const intersectionController = this.intersections[intersectionIndex];\n      let intersectionComputation = this._intersectionComputations[intersectionIndex];\n\n      if (!intersectionComputation || intersectionComputation.viewportTop !== viewportTop) {\n        let intersectionSnap = this._intersectionSnaps[intersectionIndex];\n\n        if (!intersectionSnap) {\n          if (!stickies) {\n            stickies = [];\n            for (const _stickyController of this.stickies) {\n              stickies.push(_stickyController.getSticky());\n            }\n          }\n\n          const intersection = intersectionController.getIntersection();\n\n          intersectionSnap = this.stickyEngine.snapIntersection(container, stickies, intersection, viewportHeight);\n\n          this._intersectionSnaps[intersectionIndex] = intersectionSnap;\n        }\n\n        intersectionComputation = this.stickyEngine.determineIntersectionState(intersectionSnap, viewportTop);\n\n        this._intersectionComputations[intersectionIndex] = intersectionComputation;\n      }\n\n      intersectionController.refresh(intersectionComputation);\n    }\n  }\n\n  unregisterContainer(container: NgxStickyContainerController): void {\n    deleteEntry(this.containers, container);\n  }\n\n  unregisterBoundary(boundary: NgxStickyBoundaryController): void {\n    deleteEntry(this.boundaries, boundary);\n  }\n\n  unregisterIntersection(intersectionController: NgxIntersectionController): void {\n    const intersectionIndex = deleteEntry(this.intersections, intersectionController);\n\n    if (intersectionIndex !== -1) {\n      this._intersectionSnaps[intersectionIndex] = null;\n      this._intersectionComputations[intersectionIndex] = null;\n    }\n  }\n\n  unregisterSticky(sticky: NgxStickyController): void {\n    const stickyIndex = deleteEntry(this.stickies, sticky);\n\n    if (stickyIndex !== -1) {\n      this._stickySnaps[stickyIndex] = null;\n      this._stickyComputations[stickyIndex] = null;\n    }\n  }\n}\n","import { Directive, Input, NgZone, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';\nimport { Observable, Subject, Subscription, animationFrameScheduler, fromEvent, merge, of } from 'rxjs';\nimport { debounceTime, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\n\nimport { NgxStickyBaseContainerController } from './sticky-base-container.controller';\nimport { NgxStickyEngine } from './sticky-engine';\nimport { NgxScrollPlan, NgxStickyContainer, NgxStickyContainerController, NgxStickyController } from './sticky.types';\nimport { coerceBooleanProperty, coerceNumberProperty } from './utils/coercion';\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\nimport {\n  getDocumentHeightFactory,\n  getDocumentWidthFactory,\n  getElementAbsoluteRect,\n  getWindowViewportHeight,\n  getWindowViewportLeft,\n  getWindowViewportTop,\n  isElementScrollableY,\n} from './utils/dom';\n\n\nexport interface NgxStickyContainerConfig {\n  disabled: boolean;\n  offsetTop: number;\n  offsetBottom: number;\n  unstacked: boolean;\n}\n\n\nexport const NGX_STICKY_BASE_CONTAINER_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyContainerConfig> = {\n  disabled: {\n    aliasKey: 'stickyDisabled',\n    defaultValue: false,\n    coercion: coerceBooleanProperty,\n  },\n  offsetTop: {\n    aliasKey: 'stickyOffsetTop',\n    defaultValue: 0,\n    coercion: coerceNumberProperty,\n  },\n  offsetBottom: {\n    aliasKey: 'stickyOffsetBottom',\n    defaultValue: 0,\n    coercion: coerceNumberProperty,\n  },\n  unstacked: {\n    aliasKey: 'stickyUnstacked',\n    defaultValue: false,\n    coercion: coerceBooleanProperty,\n  },\n};\n\n\n/**\n * Abstract sticky container directive.\n */\n@Directive()\nexport abstract class NgxStickyBaseContainerDirective extends NgxStickyBaseContainerController implements OnChanges, OnDestroy {\n  /**\n   * Returns HTMLElement of the container or `null` in case of root container.\n   */\n  abstract readonly element: HTMLElement;\n\n  /**\n   * Disable sticky. container.\n   *\n   * Defaults to `false`.\n   */\n  @Input()\n  stickyDisabled: boolean;\n\n  /**\n   * Defines offset bottom inside the sticky container.\n   */\n  @Input()\n  stickyOffsetBottom: (element: HTMLElement) => number;\n\n  /**\n   * Defines offset top inside the sticky container.\n   */\n  @Input()\n  stickyOffsetTop: (element: HTMLElement) => number;\n\n  /**\n   * Enable/disable sticky stack inside container.\n   *\n   * Defaults to `false`.\n   */\n  @Input()\n  stickyUnstacked: boolean;\n\n  get config(): NgxStickyContainerConfig {\n    return this.config$.getValue();\n  }\n\n  get disabled(): boolean {\n    return this.config.disabled;\n  }\n\n  /** Inputs config */\n  readonly config$ = new ConfigSubject(NGX_STICKY_BASE_CONTAINER_CONFIG_SCHEMA);\n\n  /** Container which reflect last call of _computeContainer() */\n  _container: NgxStickyContainer;\n\n  /** Emits when the service is destroyed. */\n  readonly destroyed$ = new Subject<void>();\n\n  /** Monitoring subscription which trigger update stickies */\n  _monitoring: Subscription;\n\n  /** Emits when updateStickies() is called */\n  _updateStickies$ = new Subject<boolean>();\n\n  /** Getter for document height */\n  readonly _getDocumentHeight: () => number;\n  /** Getter for document width */\n  readonly _getDocumentWidth: () => number;\n\n  constructor(\n    readonly containerParent: NgxStickyContainerController,\n    readonly stickyEngine: NgxStickyEngine,\n    readonly ngZone: NgZone,\n    readonly _win: Window,\n  ) {\n    super();\n\n    if (this.containerParent) {\n      this.containerParent.registerContainer(this);\n    }\n\n    this._getDocumentHeight = getDocumentHeightFactory(this._win);\n    this._getDocumentWidth = getDocumentWidthFactory(this._win);\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.config$.nextChanges(changes);\n  }\n\n  ngOnDestroy(): void {\n    if (this.containerParent) {\n      this.containerParent.unregisterContainer(this);\n    }\n\n    if (!this.destroyed$.isStopped) {\n      this.destroyed$.next();\n      this.destroyed$.complete();\n    }\n\n    this._destroyMonitoring();\n  }\n\n  beforeRefresh(fastUpdate?: boolean): void {\n    if (!fastUpdate) {\n      this._container = null;\n    }\n  }\n\n  createScrollPlan(target: number | string | HTMLElement, userOffsetTop?: number): NgxScrollPlan {\n    const scrollPlan: NgxScrollPlan = [];\n\n    if (!this._win) {\n      return scrollPlan;\n    }\n\n    const scrollToFn = this.element\n      ? this.element.scrollTo.bind(this.element)\n      : this._win.scrollTo.bind(this._win);\n\n    let containsElement = false;\n\n    if (typeof target === 'string') {\n      const elementAsNumber = parseFloat(target as string);\n\n      if (!isNaN(elementAsNumber)) {\n        target = elementAsNumber;\n      } else {\n        if (this.element) {\n          target = this.element.querySelector<HTMLElement>(target);\n        } else {\n          target = this._win.document.querySelector<HTMLElement>(target);\n        }\n\n        if (target) {\n          containsElement = true;\n        }\n      }\n    }\n\n    if (typeof target === 'number' && !isNaN(target)) {\n      const elementTop = this.fixViewportTop(target, userOffsetTop);\n\n      scrollPlan.push({\n        scrollToOptions: { left: this.getViewportLeft(), top: elementTop },\n        scrollToFn,\n      });\n\n      return scrollPlan;\n    }\n\n    // if (!target || !(target instanceof HTMLElement)) {\n    if (!target || !((target as HTMLElement).tagName)) {\n      return scrollPlan;\n    }\n\n    containsElement = containsElement || !this.element || this.element.contains(target as HTMLElement);\n\n    if (!containsElement) {\n      return scrollPlan;\n    }\n\n    let targetContainer: NgxStickyBaseContainerDirective;\n    let targetContainerScrollPlan: NgxScrollPlan;\n\n    for (const containerController of (this.containers as NgxStickyBaseContainerDirective[])) {\n      const containerScrollPlan = containerController.createScrollPlan(target, userOffsetTop);\n\n      if (containerScrollPlan.length) {\n        targetContainerScrollPlan = containerScrollPlan;\n        targetContainer = containerController as NgxStickyBaseContainerDirective;\n\n        break;\n      }\n    }\n\n    const containerScrollable = !this.element || isElementScrollableY(this._win, this.element);\n\n    if (containerScrollable) {\n      const targetLine = targetContainer\n        ? targetContainer.getContainer()\n        : getElementAbsoluteRect(target as HTMLElement);\n      const targetTopFixed = this.fixViewportTop(targetLine.top, userOffsetTop);\n\n      scrollPlan.push({\n        scrollToFn,\n        scrollToOptions: { left: this.getViewportLeft(), top: targetTopFixed },\n      });\n    }\n\n    if (targetContainerScrollPlan) {\n      scrollPlan.push(...targetContainerScrollPlan);\n    }\n\n    return scrollPlan;\n  }\n\n  disableStickies(): void {\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\n  }\n\n  enableStickies(): void {\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\n  }\n\n  getContainer(): NgxStickyContainer {\n    if (!this._container) {\n      this._container = this._computeContainer();\n    }\n\n    return this._container;\n  }\n\n  getViewportHeight(): number {\n    return getWindowViewportHeight(this._win);\n  }\n\n  getViewportLeft(): number {\n    return getWindowViewportLeft(this._win);\n  }\n\n  getViewportTop(): number {\n    return getWindowViewportTop(this._win);\n  }\n\n  registerSticky(sticky: NgxStickyController): void {\n    super.registerSticky(sticky);\n\n    if (this.stickies.length) {\n      this._initMonitoring();\n    }\n  }\n\n  unregisterSticky(sticky: NgxStickyController): void {\n    super.unregisterSticky(sticky);\n\n    if (!this.stickies.length) {\n      this._destroyMonitoring();\n    }\n  }\n\n  scrollToTop(target: number | string | HTMLElement, userOffsetTop?: number): void {\n    const scrollPlan = this.createScrollPlan(target, userOffsetTop);\n\n    for (const scrollStep of scrollPlan) {\n      scrollStep.scrollToFn(scrollStep.scrollToOptions);\n    }\n  }\n\n  updateStickies(fastUpdate?: boolean): void {\n    // intercept update stickies to throttle calls\n    this._updateStickies$.next(fastUpdate);\n  }\n\n  _computeContainer(): NgxStickyContainer {\n    const config = this.config$.getValue();\n\n    const containerRect = this.element ? getElementAbsoluteRect(this.element) : null;\n\n    return {\n      disabled: this.disabled,\n      height: containerRect ? this.element.scrollHeight : this._getDocumentHeight(),\n      left: containerRect ? containerRect.left : 0,\n      offsetBottom: config.offsetBottom,\n      offsetTop: config.offsetTop,\n      top: containerRect ? containerRect.top : 0,\n      unstacked: config.unstacked,\n      width: containerRect ? this.element.scrollWidth : this._getDocumentWidth(),\n    };\n  }\n\n  _createMonitoringObservable(): Observable<boolean> {\n    if (!this._win) {\n      return of();\n    }\n\n    return merge(\n      this._createMonitoringInputsObservable(),\n      this._createMonitoringScrollObservable(),\n      this._createMonitoringWindowObservable(),\n      this._updateStickies$,\n      animationFrameScheduler,\n    )/*.pipe(throttleTime(0, animationFrameScheduler))*/;\n  }\n\n  _createMonitoringInputsObservable(): Observable<boolean> {\n    return this.config$.pipe(\n      debounceTime(0),\n      // throttleTime(0, animationFrameScheduler),\n      mapTo(false),\n    );\n  }\n\n  _createMonitoringScrollObservable(): Observable<boolean> {\n    return fromEvent(this.element || this._win, 'scroll', { passive: true })\n      .pipe(\n        throttleTime(0, animationFrameScheduler),\n        mapTo(true),\n      );\n  }\n\n  _createMonitoringWindowObservable(): Observable<boolean> {\n    return merge(\n      fromEvent(this._win, 'load', { passive: true }),\n      fromEvent(this._win, 'orientationchange', { passive: true }),\n      fromEvent(this._win, 'resize', { passive: true }),\n    ).pipe(\n      debounceTime(0, animationFrameScheduler),\n      mapTo(false),\n    );\n  }\n\n  _destroyMonitoring(): void {\n    if (this._monitoring) {\n      this._monitoring.unsubscribe();\n      this._monitoring = null;\n    }\n  }\n\n  _initMonitoring(): void {\n    if (!this._win || this._monitoring) {\n      return;\n    }\n\n    this.ngZone.runOutsideAngular(() => {\n      this._monitoring = this._createMonitoringObservable()\n        .pipe(\n          takeUntil(this.destroyed$),\n          // throttleTime(0, animationFrameScheduler),\n          share(),\n        )\n        .subscribe(fastUpdate => {\n          this._updateStickies(fastUpdate);\n        });\n\n      // fromMediaQuery(this._win, 'print').subscribe(mqlEvent => {\n      //   if (mqlEvent.matches) {\n      //     this.disableStickies();\n      //   } else {\n      //     this.enableStickies();\n      //   }\n      // });\n    });\n  }\n\n  _updateStickies(fastUpdate?: boolean): void {\n    super.updateStickies(fastUpdate);\n  }\n}\n","import {\n  NgxSticky,\n  NgxStickyBoundaryController,\n  NgxStickyComputation,\n  NgxStickyContainerController,\n  NgxStickyController,\n  NgxStickyState,\n} from './sticky.types';\n\n\n/**\n * Abstract sticky controller.\n */\nexport abstract class NgxStickyBaseController implements NgxStickyController {\n  abstract readonly boundary?: NgxStickyBoundaryController;\n  abstract readonly container: NgxStickyContainerController;\n  abstract readonly disabled: boolean;\n  abstract readonly state: NgxStickyState;\n\n  abstract beforeRefresh(fastUpdate?: boolean): void;\n  abstract disableSticky(): void;\n  abstract enableSticky(): void;\n  abstract getSticky(): NgxSticky;\n  abstract refresh(computation: NgxStickyComputation): void;\n\n  update(fastUpdate?: boolean): void {\n    // all stickies need to be updated when one of them changed\n    this.container.updateStickies(fastUpdate);\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  SimpleChanges,\n  forwardRef,\n} from '@angular/core';\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\nimport { mapTo, share, takeUntil } from 'rxjs/operators';\n\nimport { NgxStickyBaseBoundaryController } from './sticky-base-boundary.controller';\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\nimport { NgxStickyBoundary, NgxStickyContainerController } from './sticky.types';\nimport { coerceBooleanProperty } from './utils/coercion';\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\nimport { getElementAbsoluteRect } from './utils/dom';\n\n\nexport interface NgxStickyBoundaryConfig {\n  unstacked: boolean;\n}\n\n\nexport const NGX_STICKY_BASE_BOUNDARY_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyBoundaryConfig> = {\n  unstacked: {\n    aliasKey: 'stickyUnstacked',\n    defaultValue: false,\n    coercion: coerceBooleanProperty,\n  },\n};\n\n\n/**\n * Defines a sticky boundary.\n */\n@Directive({\n  selector: '[ngxStickyBoundary], [ngx-sticky-boundary], ngx-sticky-boundary',\n  exportAs: 'ngxStickyBoundary',\n})\nexport class NgxStickyBoundaryDirective extends NgxStickyBaseBoundaryController implements OnChanges, OnDestroy, OnInit {\n  /**\n   * Enable/disable sticky stack inside boudary.\n   *\n   * Defaults to `false`.\n   */\n  @Input()\n  stickyUnstacked: boolean;\n\n  get config(): NgxStickyBoundaryConfig {\n    return this.config$.getValue();\n  }\n\n  get container(): NgxStickyContainerController {\n    return this._container;\n  }\n\n  /** Inputs config */\n  readonly config$ = new ConfigSubject(NGX_STICKY_BASE_BOUNDARY_CONFIG_SCHEMA);\n\n  /** Boundary line which reflect last call of _computeBoundary() */\n  _boundary: NgxStickyBoundary;\n\n  /** Boundary container controller */\n  readonly _container: NgxStickyContainerController;\n\n  /** Emits when the component is destroyed. */\n  readonly _destroyed$ = new Subject<void>();\n\n  /** Monitoring subscription which trigger update stickies */\n  _monitoring: Subscription;\n\n  constructor(\n    readonly rootContainer: NgxStickyRootContainerController,\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\n    readonly stickyContainer: NgxStickyContainerController,\n    readonly elementRef: ElementRef<HTMLElement>,\n    readonly ngZone: NgZone,\n    @Inject(NGX_STICKY_WINDOW)\n    readonly _win: Window,\n  ) {\n    super();\n\n    // use root container when boundary isn't in container\n    this._container = stickyContainer || rootContainer;\n\n    // register boundary in container for first update calls\n    this.container.registerBoundary(this);\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.config$.nextChanges(changes);\n  }\n\n  ngOnInit(): void {\n    this._initMonitoring();\n  }\n\n  ngOnDestroy(): void {\n    this.container.unregisterBoundary(this);\n\n    if (!this._destroyed$.isStopped) {\n      this._destroyed$.next();\n      this._destroyed$.complete();\n    }\n\n    this._destroyMonitoring();\n  }\n\n  beforeRefresh(fastUpdate?: boolean): void {\n    if (!fastUpdate) {\n      this._boundary = null;\n    }\n  }\n\n  getBoundary(): NgxStickyBoundary {\n    if (!this._boundary) {\n      this._boundary = this._computeBoundary();\n    }\n\n    return this._boundary;\n  }\n\n  _computeBoundary(): NgxStickyBoundary {\n    const boundary: NgxStickyBoundary = getElementAbsoluteRect(this.elementRef.nativeElement);\n\n    if (this._win) {\n      const boundaryStyle = this._win.getComputedStyle(this.elementRef.nativeElement);\n      const paddingTop = parseFloat(boundaryStyle.paddingTop) || 0;\n      const paddingBottom = parseFloat(boundaryStyle.paddingBottom) || 0;\n\n      // substract paddings from computed boundary line\n      boundary.top += paddingTop;\n      boundary.height -= paddingTop + paddingBottom;\n    }\n\n    boundary.unstacked = this.config.unstacked;\n\n    return boundary;\n  }\n\n  _createMonitoringObservable(): Observable<boolean> {\n    return merge(\n      this.config$,\n      animationFrameScheduler,\n    ).pipe(\n      // throttleTime(0, animationFrameScheduler),\n      mapTo(false),\n    );\n  }\n\n  _destroyMonitoring(): void {\n    if (this._monitoring) {\n      this._monitoring.unsubscribe();\n      this._monitoring = null;\n    }\n  }\n\n  _initMonitoring(): void {\n    if (!this._win || this._monitoring) {\n      return;\n    }\n\n    this.ngZone.runOutsideAngular(() => {\n      this._monitoring = this._createMonitoringObservable()\n        .pipe(\n          takeUntil(this._destroyed$),\n          share(),\n        )\n        .subscribe(fastUpdate => {\n          this.updateStickies(fastUpdate);\n        });\n    });\n  }\n}\n","import { Directive, ElementRef, Inject, NgZone, Optional, SkipSelf, forwardRef } from '@angular/core';\n\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\nimport { NgxStickyEngine } from './sticky-engine';\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\nimport { NgxStickyContainerController } from './sticky.types';\n\n\n/**\n * Defines a sticky container.\n */\n@Directive({\n  selector: '[ngxStickyContainer], [ngx-sticky-container], ngx-sticky-container',\n  exportAs: 'ngxStickyContainer',\n})\nexport class NgxStickyContainerDirective extends NgxStickyBaseContainerDirective {\n  /**\n   * Returns HTMLElement of the container.\n   */\n  get element(): HTMLElement {\n    return this.elementRef.nativeElement;\n  }\n\n  constructor(\n    readonly rootContainer: NgxStickyRootContainerController,\n    @SkipSelf() @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\n    readonly stickyContainerParent: NgxStickyContainerController,\n    readonly stickyEngine: NgxStickyEngine,\n    readonly ngZone: NgZone,\n    readonly elementRef: ElementRef<HTMLElement>,\n    @Inject(NGX_STICKY_WINDOW)\n    readonly _win: Window,\n  ) {\n    // use root container when boundary isn't in container\n    super(stickyContainerParent || rootContainer, stickyEngine, ngZone, _win);\n  }\n\n  getViewportHeight(): number {\n    return this.element.offsetHeight;\n  }\n\n  getViewportLeft(): number {\n    return this.element.scrollLeft;\n  }\n\n  getViewportTop(): number {\n    return this.element.scrollTop;\n  }\n}\n","import { Injectable } from '@angular/core';\n\nimport { isStickyDirectionDown, isStickyPositionBottom } from './sticky.helpers';\nimport {\n  NgxIntersection,\n  NgxIntersectionComputation,\n  NgxIntersectionSnap,\n  NgxSticky,\n  NgxStickyBoundary,\n  NgxStickyBoundaryComputed,\n  NgxStickyComputation,\n  NgxStickyComputed,\n  NgxStickyContainer,\n  NgxStickyLine,\n  NgxStickyPosition,\n  NgxStickySnap,\n  NgxStickyState,\n} from './sticky.types';\n\n\nexport const NGX_STICKY_ENGINE_INTERCEPTION_STATE_MAP = {\n  'sticked,normal': 'enter',\n  'stucked,normal': 'entered',\n  'sticked,sticked': 'entered',\n  'stucked,sticked': 'exit',\n  'stucked,stucked': 'exited',\n};\n\n\n/**\n * Defines a sticky engine. Implemented in universal way.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class NgxStickyEngine {\n  /**\n   * Compute sticky boundary.\n   *\n   * @param container Container\n   * @param boundary Sticky boundary\n   * @param sticky Sticky line\n   * @param directionDown Direction down\n   * @param spot Spot line\n   * @param viewportHeight Viewport height\n   * @returns Boundary instance\n   */\n  computeStickyBoundary(\n    container: NgxStickyContainer,\n    boundary: NgxStickyBoundary | null,\n    sticky: NgxStickyLine,\n    directionDown: boolean,\n    spot: NgxStickyLine | null,\n    viewportHeight: number,\n  ): NgxStickyBoundaryComputed {\n    let {\n      height: boundaryHeight,\n      top: boundaryTop,\n      left: boundaryLeft,\n      width: boundaryWidth,\n    } = boundary || container;\n\n    boundaryHeight = boundaryHeight || 0;\n    boundaryTop = boundaryTop || 0;\n    boundaryWidth = boundaryWidth || 0;\n    boundaryLeft = boundaryLeft || 0;\n\n    if (spot && spot.height) {\n      const beforeSpot = sticky.top < spot.top;\n\n      if (beforeSpot) {\n        // when sticky direction is bottom and is before its spot\n        if (directionDown) {\n          const spotPoint = spot.top - viewportHeight;\n\n          // disable sticky when is in same viewport height as its spot\n          if (spotPoint < sticky.top) {\n            boundaryHeight = 0;\n            boundaryTop = 0;\n          // adjust sticky boundary height according to its spot when spot point is in base boundary\n          } else if (spotPoint < boundaryTop + boundaryHeight) {\n            boundaryHeight = spotPoint - boundaryTop + sticky.height;\n          }\n        }\n      } else {\n        // when sticky direction is top and is after its spot\n        if (!directionDown) {\n          const spotPoint = spot.top + spot.height + viewportHeight;\n\n          // disable sticky when is in same viewport height as its spot\n          if (spotPoint > sticky.top) {\n            boundaryHeight = 0;\n            boundaryTop = 0;\n            // adjust sticky boundary top according to its spot when spot point is in base boundary\n          } else if (spotPoint > boundaryTop && spotPoint < boundaryTop + boundaryHeight) {\n            boundaryHeight -= spotPoint - boundaryTop;\n            boundaryTop = spotPoint;\n          }\n        }\n      }\n    }\n\n    return {\n      height: boundaryHeight,\n      top: boundaryTop,\n      width: boundaryWidth,\n      left: boundaryLeft,\n      unstacked: boundary && boundary.unstacked || container.unstacked || false,\n      offsetBottom: 0,\n      offsetTop: 0,\n    };\n  }\n\n  /**\n   * Compute sticky sticked line.\n   *\n   * @param boundary Sticky boundary line\n   * @param sticky Sticky line\n   * @param positionBottom Position bottom\n   * @param directionDown Direction down\n   * @param viewportHeight Viewport height\n   * @returns Sticked line\n   */\n  computeStickyStickedLine(\n    boundary: NgxStickyLine,\n    sticky: NgxStickyLine,\n    positionBottom: boolean,\n    directionDown: boolean,\n    viewportHeight: number,\n  ): NgxStickyLine {\n    let stickedTop: number;\n    let stickedHeight: number;\n\n    if (positionBottom) {\n      if (directionDown) {\n        stickedTop = sticky.top + sticky.height - viewportHeight;\n        stickedHeight = boundary.height + boundary.top - stickedTop - viewportHeight;\n      } else {\n        stickedTop = boundary.top - viewportHeight;\n        stickedHeight = sticky.top - stickedTop - viewportHeight;\n      }\n    } else {\n      if (directionDown) {\n        stickedTop = sticky.top;\n        stickedHeight = boundary.height + boundary.top - stickedTop;\n      } else {\n        stickedTop = boundary.top;\n        stickedHeight = sticky.top - stickedTop;\n      }\n    }\n\n    return { top: stickedTop, height: stickedHeight };\n  }\n\n  /**\n   * Compute sticky sort point.\n   *\n   * @param sticky Sticky line\n   * @param positionBottom Position bottom\n   * @param directionDown Direction down\n   * @param viewportHeight Viewport height\n   * @returns Sticky sort point\n   */\n  computeStickySortPoint(\n    sticky: NgxStickyLine,\n    positionBottom: boolean,\n    directionDown: boolean,\n    viewportHeight: number,\n  ): number {\n    let sortPoint: number;\n\n    if (positionBottom) {\n      sortPoint = directionDown\n        ? -sticky.top - sticky.height + viewportHeight\n        : sticky.top + sticky.height - viewportHeight;\n    } else {\n      sortPoint = directionDown\n        ? -sticky.top\n        : sticky.top;\n    }\n\n    return sortPoint;\n  }\n\n  /**\n   * Determines intersection state.\n   *\n   * @param snap Intersection snap\n   * @param viewportTop Viewport/scroll top position\n   * @returns Intersection computation\n   */\n  determineIntersectionState(snap: NgxIntersectionSnap, viewportTop: number): NgxIntersectionComputation {\n    const enter = this.determineStickyState(snap.enter, viewportTop);\n    const exit = this.determineStickyState(snap.exit, viewportTop);\n\n    // Intersection state can be easily determined from enter sticky and exit sticky states:\n    // - enter: when enter sticky (on bottom) is _sticked_ and exit sticky (on top) is _normal_ ;\n    // - entered: when enter (on bottom) and exit (on top) stickies are _sticked_ ;\n    // - entered: when enter sticky (on bottom) is _stucked_ and exit sticky (on top) is _normal_ ;\n    // - exit: when enter sticky (on bottom) is _stucked_ and exit sticky (on top) is _sticked_ ;\n    // - exited: when enter (on bottom) and exit (on top) stickies are _stucked_.\n    const stateKey = [ enter.state, exit.state ].join(',');\n    const state = NGX_STICKY_ENGINE_INTERCEPTION_STATE_MAP[stateKey] || null;\n\n    const viewportOffsetless = snap.viewportHeight - enter.offsetSticked - exit.offsetSticked;\n    const maxHeightVisible = Math.min(snap.intersection.height, viewportOffsetless);\n    let height = 0;\n    let intersecting = false;\n\n    if (state === 'entered') {\n      height = maxHeightVisible;\n      intersecting = true;\n    } else if (state === 'enter') {\n      height = viewportTop + snap.viewportHeight - snap.intersection.top - enter.offsetSticked;\n      intersecting = true;\n    } else if (state === 'exit') {\n      height = snap.intersection.top + snap.intersection.height - viewportTop - exit.offsetSticked;\n      intersecting = true;\n    }\n\n    const computation: NgxIntersectionComputation = {\n      enter,\n      exit,\n      snap,\n      height,\n      intersecting,\n      ratio: Math.min(1, height / maxHeightVisible),\n      state,\n      viewportTop,\n    };\n\n    return computation;\n  }\n\n  /**\n   * Determines sticky state.\n   *\n   * @param snap Sticky snap\n   * @param viewportTop Viewport/scroll top position\n   * @returns Sticky computation\n   */\n  determineStickyState(snap: NgxStickySnap, viewportTop: number): NgxStickyComputation {\n    const computation: NgxStickyComputation = {\n      offsetSticked: 0,\n      offsetStucked: 0,\n      state: 'normal',\n      snap,\n      viewportTop,\n    };\n\n    // cancel computation when stickyComputed is outside its boundary\n    if (snap.stickyComputed.disabled) {\n      return computation;\n    }\n\n    // last value stored in _stickyComputedState will be related to stickyComputed\n    let _stickyComputedState: NgxStickyState;\n\n    // compute state for each sibling and stickyComputed in last\n    for (const _stickyComputed of snap.stickies) {\n      const boundaryOffset = _stickyComputed.directionDown\n        ? _stickyComputed.boundary.offsetBottom\n        : _stickyComputed.boundary.offsetTop;\n      let {\n        top: _stickedTop,\n        height: _stickedHeight,\n      } = _stickyComputed.sticked;\n\n      // adjust _stickyComputed sticked line with previous sibling\n      if (_stickyComputed.positionBottom) {\n        if (_stickyComputed.directionDown) {\n          _stickedTop += computation.offsetSticked + computation.offsetStucked;\n          _stickedHeight -= computation.offsetStucked;\n        } else {\n          _stickedTop += boundaryOffset;\n          _stickedTop += computation.offsetSticked;\n          _stickedHeight -= boundaryOffset - computation.offsetStucked;\n          _stickedHeight += _stickyComputed.height;\n        }\n      } else {\n        if (_stickyComputed.directionDown) {\n          _stickedTop -= computation.offsetSticked + computation.offsetStucked;\n          _stickedHeight += computation.offsetStucked;\n          _stickedHeight -= boundaryOffset;\n        } else {\n          _stickedTop -= computation.offsetSticked;\n          _stickedHeight -= computation.offsetStucked;\n        }\n      }\n\n      // set default state to \"normal\"\n      _stickyComputedState = 'normal';\n\n      // determine _stickyComputed state with its sticked line adjusted\n      // if (viewportTop > _stickedTop) {\n      if (viewportTop >= _stickedTop) {\n        _stickyComputedState = 'sticked';\n\n        if (viewportTop > _stickedTop + _stickedHeight) {\n          _stickyComputedState = _stickyComputed.directionDown ? 'stucked' : 'normal';\n        }\n      } else if (!_stickyComputed.directionDown) {\n        _stickyComputedState = 'stucked';\n      }\n\n      // cumulate sibling height to the right offset\n      if (\n        // when _stickyComputed isn't stickyComputed\n        _stickyComputed !== snap.stickyComputed\n        // and state determined is \"sticked\" or \"stucked\"\n        && _stickyComputedState !== 'normal'\n        // and _stickyComputed is stacked\n        && !_stickyComputed.boundary.unstacked\n      ) {\n        if (\n          _stickyComputed.boundary.top === snap.stickyComputed.boundary.top\n            && _stickyComputed.boundary.height === snap.stickyComputed.boundary.height\n        ) {\n          computation.offsetStucked += _stickyComputed.height;\n        } else if (_stickyComputedState === 'sticked') {\n          computation.offsetSticked += _stickyComputed.height;\n        }\n      }\n      // (computation as any)._state = _stickyComputedState;\n    }\n\n    computation.state = _stickyComputedState;\n\n    return computation;\n  }\n\n  /**\n   * Returns scroll top offset height used by stickies for a given viewport position.\n   *\n   * @param container Container\n   * @param stickies Stickies\n   * @param position Position `\"top\"` or `\"bottom\"`\n   * @param viewportHeight Viewport height\n   * @param offsetTop Viewport top\n   * @returns Top offset height used by stickies.\n   */\n  getStickedOffset(\n    container: NgxStickyContainer,\n    stickies: NgxSticky[],\n    position: NgxStickyPosition,\n    viewportHeight: number,\n    viewportTop: number,\n  ): number {\n    const positionBottom = isStickyPositionBottom(position);\n    let maxStickyUnstackedHeight = 0;\n    let stickedOffset = 0;\n\n    for (const _sticky of stickies) {\n      // skip sticky when is position bottom\n      if (isStickyPositionBottom(_sticky.position) !== positionBottom) {\n        continue;\n      }\n\n      const snap = this.snapSticky(container, stickies, _sticky, viewportHeight);\n\n      // skip sticky when is disabled\n      if (snap.sticky.disabled) {\n        continue;\n      }\n\n      const computation = this.determineStickyState(snap, viewportTop);\n\n      // add sticky height to offset top when state is sticked\n      if (computation.state === 'sticked') {\n        const _elementHeight = snap.stickyComputed.height;\n\n        // substract height when sticy is stacked\n        if (!snap.stickyComputed.boundary.unstacked) {\n          stickedOffset += _elementHeight;\n        // or update the biggest sticky unstacked\n        } else if (_elementHeight > maxStickyUnstackedHeight) {\n          maxStickyUnstackedHeight = _elementHeight;\n        }\n      }\n    }\n\n    stickedOffset += maxStickyUnstackedHeight;\n\n    if (positionBottom) {\n      stickedOffset += container.offsetBottom || 0;\n    } else {\n      stickedOffset += container.offsetTop || 0;\n    }\n\n    return stickedOffset;\n  }\n\n  /**\n   * Create intersection snap.\n   *\n   * @param container Container\n   * @param stickies Stickies\n   * @param intersection Intersection\n   * @param viewportHeight Viewport height\n   * @returns Intersection snap\n   */\n  snapIntersection(\n    container: NgxStickyContainer,\n    stickies: NgxSticky[],\n    intersection: NgxIntersection,\n    viewportHeight: number,\n  ): NgxIntersectionSnap {\n    const disabled = intersection.disabled;\n\n    // enter sticky is sticked on bottom\n    const enterSticky: NgxSticky = {\n      boundary: {\n        top: intersection.top - 1,\n        height: intersection.height,\n        left: container.left,\n        width: container.width,\n      },\n      disabled,\n      top: intersection.top - 1,\n      height: 1,\n      position: 'bottom',\n      direction: 'down',\n    };\n\n    // exit sticky is sticked on top\n    const exitSticky: NgxSticky = {\n      boundary: {\n        top: intersection.top,\n        height: intersection.height - 1,\n        left: container.left,\n        width: container.width,\n      },\n      disabled,\n      top: intersection.top,\n      height: 1,\n      position: 'top',\n      direction: 'down',\n    };\n\n    return {\n      container,\n      enter: this.snapSticky(container, stickies, enterSticky, viewportHeight),\n      exit: this.snapSticky(container, stickies, exitSticky, viewportHeight),\n      intersection: {\n        disabled,\n        height: intersection.height,\n        thresholds: intersection.thresholds ? [ ...intersection.thresholds ] : [ 0, 1 ],\n        top: intersection.top,\n      },\n      viewportHeight,\n    };\n  }\n\n  /**\n   * Create sticky snap.\n   *\n   * @param container Container\n   * @param stickies Stickies\n   * @param sticky Sticky\n   * @param viewportHeight Viewport height\n   * @returns Sticky snap\n   */\n  snapSticky(\n    container: NgxStickyContainer,\n    stickies: NgxSticky[],\n    sticky: NgxSticky,\n    viewportHeight: number,\n  ): NgxStickySnap {\n    const boundariesMap: Record<string, NgxStickyBoundaryComputed> = {};\n\n    const directionDown = isStickyDirectionDown(sticky.direction);\n    const positionBottom = isStickyPositionBottom(sticky.position);\n\n    const stickyComputed: NgxStickyComputed = {\n      boundary: this.computeStickyBoundary(\n        container,\n        sticky.boundary,\n        sticky,\n        directionDown,\n        sticky.spot,\n        viewportHeight,\n      ),\n      directionDown,\n      disabled: false,\n      height: sticky.height,\n      positionBottom,\n      sortPoint: this.computeStickySortPoint(sticky, positionBottom, directionDown, viewportHeight),\n      sticked: null,\n      top: sticky.top,\n    };\n\n    if (\n      container.disabled\n      || sticky.disabled\n      || !sticky.height\n      || sticky.top < stickyComputed.boundary.top\n      || sticky.top > stickyComputed.boundary.top + stickyComputed.boundary.height\n    ) {\n      stickyComputed.disabled = true;\n      stickyComputed.sticked = { height: 0, top: 0 };\n    } else {\n      stickyComputed.sticked = this.computeStickyStickedLine(\n        stickyComputed.boundary,\n        sticky,\n        positionBottom,\n        directionDown,\n        viewportHeight,\n      );\n    }\n\n    const stickiesComputed: NgxStickyComputed[] = [];\n    let offsetSpacer: NgxSticky;\n\n    if (sticky.disabled) {\n      return {\n        boundaries: boundariesMap,\n        container,\n        stickies: stickiesComputed,\n        sticky,\n        stickyComputed,\n        viewportHeight,\n      };\n    }\n\n    // insert fake sticky which represent container offset top\n    if (container.offsetTop && !stickyComputed.positionBottom) {\n      offsetSpacer = {\n        boundary: container,\n        direction: 'down',\n        height: container.offsetTop,\n        position: 'top',\n        disabled: false,\n        top: container.top,\n      };\n\n      stickies = [ offsetSpacer, ...stickies ];\n    }\n\n    // insert fake sticky which represent container offset bottom\n    if (container.offsetBottom && stickyComputed.positionBottom) {\n      offsetSpacer = {\n        boundary: container,\n        direction: 'up',\n        height: container.offsetBottom,\n        position: 'bottom',\n        disabled: false,\n        top: container.top + container.height - container.offsetBottom,\n      };\n\n      stickies = [ offsetSpacer, ...stickies ];\n    }\n\n    // remove 1px to fix round sizes (offsetLeft and offsetWidth)\n    const stickyComputedBoundaryRight = stickyComputed.boundary.left + stickyComputed.boundary.width - 1;\n\n    for (let _stickyIndex = 0; _stickyIndex < stickies.length; ++_stickyIndex) {\n      const _sticky = stickies[_stickyIndex];\n      let _directionDown: boolean;\n      let _positionBottom: boolean;\n      let _stickyComputed: NgxStickyComputed;\n      let _stickyComputedBoundaryRight: number;\n\n      if (_sticky === sticky) {\n        _directionDown = stickyComputed.directionDown;\n        _positionBottom = stickyComputed.positionBottom;\n        _stickyComputed = stickyComputed;\n        _stickyComputedBoundaryRight = stickyComputedBoundaryRight;\n      } else {\n        _directionDown = isStickyDirectionDown(_sticky.direction);\n        _positionBottom = isStickyPositionBottom(_sticky.position);\n\n        _stickyComputed = {\n          boundary: this.computeStickyBoundary(\n            container,\n            _sticky.boundary,\n            _sticky,\n            _directionDown,\n            _sticky.spot,\n            viewportHeight,\n          ),\n          disabled: false,\n          directionDown: _directionDown,\n          height: _sticky.height,\n          positionBottom: _positionBottom,\n          sortPoint: this.computeStickySortPoint(_sticky, _positionBottom, _directionDown, viewportHeight),\n          sticked: null,\n          top: _sticky.top,\n        };\n\n        // remove 1px to fix round sizes (offsetLeft and offsetWidth)\n        _stickyComputedBoundaryRight = _stickyComputed.boundary.left + _stickyComputed.boundary.width - 1;\n\n        if (\n          _sticky.disabled\n          || !_sticky.height\n          // skip sticky which isn't in its boundary\n          || _sticky.top < _stickyComputed.boundary.top\n          || _sticky.top > _stickyComputed.boundary.top + _stickyComputed.boundary.height\n          // skip sticky sibling when its boundary isn't align horizontaly\n          || stickyComputedBoundaryRight <= _stickyComputed.boundary.left\n          || stickyComputed.boundary.left >= _stickyComputedBoundaryRight\n        ) {\n          _stickyComputed.disabled = true;\n          _stickyComputed.sticked = { height: 0, top: 0 };\n        } else {\n          _stickyComputed.sticked = this.computeStickyStickedLine(\n            _stickyComputed.boundary,\n            _sticky,\n            _positionBottom,\n            _directionDown,\n            viewportHeight,\n          );\n        }\n      }\n\n      // compute boundary unique key\n      const boundaryKey = [ _stickyComputed.boundary.top, _stickyComputed.boundary.height ].join(',');\n\n      // ensure stickies computed to use same boundary instance\n      if (boundariesMap[boundaryKey]) {\n        _stickyComputed.boundary = boundariesMap[boundaryKey];\n      } else {\n        boundariesMap[boundaryKey] = _stickyComputed.boundary;\n      }\n\n      // skip sticky sibling when is disabled\n      if (_stickyComputed.disabled) {\n        continue;\n      }\n\n      // set sticky sibling height as max boundary offset when it unstacked\n      if (_stickyComputed.boundary.unstacked) {\n        if (_directionDown) {\n          if (_sticky.height > _stickyComputed.boundary.offsetBottom) {\n            _stickyComputed.boundary.offsetBottom = _sticky.height;\n          }\n        } else {\n          if (_sticky.height > _stickyComputed.boundary.offsetTop) {\n            _stickyComputed.boundary.offsetTop = _sticky.height;\n          }\n        }\n      // add sticky sibling height to right boundary offset when it stacked\n      } else {\n        if (_directionDown) {\n          _stickyComputed.boundary.offsetBottom += _sticky.height;\n        } else {\n          _stickyComputed.boundary.offsetTop += _sticky.height;\n        }\n      }\n\n      // pushforce offset spacer as sticky siblings\n      if (_sticky === offsetSpacer) {\n        stickiesComputed.push(_stickyComputed);\n\n        continue;\n      }\n\n      // collect stickyComputed siblings\n      if (\n        // when _stickyComputed isn't stickyComputed\n        _stickyComputed !== stickyComputed\n        // and its position equals to stickyComputed position\n        && _stickyComputed.positionBottom === stickyComputed.positionBottom\n        // and its sticked line intersects top of stickyComputed sticked line\n        && stickyComputed.sticked.top >= _stickyComputed.sticked.top\n        && stickyComputed.sticked.top <= _stickyComputed.sticked.top + _stickyComputed.sticked.height\n        // and its top is before stickyComputed top according to its own position\n        && (\n          _stickyComputed.directionDown\n            ? _stickyComputed.top < stickyComputed.top\n            : _stickyComputed.top > stickyComputed.top\n        )\n      ) {\n        stickiesComputed.push(_stickyComputed);\n      }\n    }\n\n    // sort stickyComputed siblings according to their respective sortPoint and boundary top\n    stickiesComputed.sort((a, b) => {\n      return a.positionBottom === stickyComputed.positionBottom\n        ? a.sortPoint < b.sortPoint && a.boundary.top >= b.boundary.top ? 1 : -1\n        : -1;\n    });\n\n    // add stickyComputed in last position\n    stickiesComputed.push(stickyComputed);\n\n    return {\n      container,\n      boundaries: boundariesMap,\n      stickies: stickiesComputed,\n      sticky,\n      stickyComputed,\n      viewportHeight,\n    };\n  }\n}\n","import { Inject, Injectable, NgZone } from '@angular/core';\n\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\nimport { NgxStickyEngine } from './sticky-engine';\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\nimport { NgxStickyContainerController } from './sticky.types';\n\n\n/**\n * Defines the sticky root container which is used to manage sticky without container.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class NgxStickyRootContainerController extends NgxStickyBaseContainerDirective {\n  // root container never has parent container\n  readonly containerParent: NgxStickyContainerController = null;\n  // root container never has element\n  readonly element: HTMLElement = null;\n\n  constructor(\n    readonly stickyEngine: NgxStickyEngine,\n    readonly ngZone: NgZone,\n    @Inject(NGX_STICKY_WINDOW)\n    readonly _win: Window,\n  ) {\n    super(null, stickyEngine, ngZone, _win);\n  }\n}\n","import { Directive, HostBinding, Input } from '@angular/core';\n\nimport { coerceNumberProperty } from './utils';\n\n@Directive({\n  selector: '[ngxStickySpot], [ngx-sticky-spot], ngx-sticky-spot',\n  exportAs: 'ngxStickySpot',\n})\nexport class NgxStickySpotDirective {\n  @HostBinding('class.ngx-sticky-spot')\n  readonly cssClassStickySpot = true;\n\n  @HostBinding('style.position')\n  readonly cssStylePosition = 'absolute';\n\n  @HostBinding('style.height.px')\n  @Input()\n  get stickySpotHeight(): number { return this._stickySpotHeight; }\n  set stickySpotHeight(value: number) { this._stickySpotHeight = coerceNumberProperty(value); }\n\n  private _stickySpotHeight = 1;\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  Renderer2,\n  SimpleChanges,\n  SkipSelf,\n  forwardRef,\n  isDevMode,\n} from '@angular/core';\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\nimport { distinctUntilChanged, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\n\nimport { NgxStickyBaseController } from './sticky-base.controller';\nimport { NgxStickyBoundaryDirective } from './sticky-boundary.directive';\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\nimport { coerceStickyDirection, coerceStickyPosition, getStuckedPositionTop } from './sticky.helpers';\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\nimport {\n  NgxSticky,\n  NgxStickyBoundaryController,\n  NgxStickyComputation,\n  NgxStickyContainerController,\n  NgxStickyController,\n  NgxStickyDirection,\n  NgxStickyPosition,\n  NgxStickyState,\n} from './sticky.types';\nimport { coerceBooleanProperty, coerceNumberProperty } from './utils/coercion';\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\nimport { getElementAbsoluteRect, getElementRelativeRect, setElementStyles } from './utils/dom';\nimport { fromImageEvents } from './utils/from-image-events';\n\n\n/**\n * Interface for a sticky style.\n */\nexport interface NgxStickyElementStyle {\n  // [prop: string]: string;\n  width: string;\n  position: string;\n  top: string;\n  right: string;\n  bottom: string;\n  left: string;\n  cssFloat: string;\n  margin: string;\n  marginTop: string;\n  marginRight: string;\n  marginBottom: string;\n  marginLeft: string;\n}\n\n/**\n * Interface for a sticky ghost style.\n */\nexport interface NgxStickyGhostStyle {\n  // [prop: string]: string;\n  width: string;\n  position: string;\n  top: string;\n  right: string;\n  bottom: string;\n  left: string;\n  cssFloat: string;\n  marginTop: string;\n  marginRight: string;\n  marginBottom: string;\n  marginLeft: string;\n\n  height: string;\n  maxHeight: string;\n  minHeight: string;\n  boxSizing: string;\n  borderTop: string;\n  borderBottom: string;\n  borderLeft: string;\n  borderRight: string;\n  paddingTop: string;\n  paddingBottom: string;\n  paddingLeft: string;\n  paddingRight: string;\n}\n\n\nexport interface NgxStickyConfig {\n  classes: boolean;\n  disabled: boolean;\n  direction: NgxStickyDirection;\n  height: number;\n  // orbit: boolean;\n  position: NgxStickyPosition;\n  spacer: HTMLElement | null;\n  spot: HTMLElement | null;\n  spotHeight: number;\n}\n\n\nexport const NGX_STICKY_BASE_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyConfig> = {\n  classes: {\n    aliasKey: 'stickyClasses',\n    defaultValue: false,\n    coercion: coerceBooleanProperty,\n  },\n  disabled: {\n    aliasKey: 'stickyDisabled',\n    defaultValue: false,\n    coercion: coerceBooleanProperty,\n  },\n  direction: {\n    aliasKey: 'stickyDirection',\n    defaultValue: 'down',\n    coercion: coerceStickyDirection,\n  },\n  height: {\n    aliasKey: 'stickyHeight',\n    defaultValue: 0,\n    coercion: coerceNumberProperty,\n  },\n  // orbit: {\n  //   aliasKey: 'stickyOrbit',\n  //   defaultValue: false,\n  //   coercion: coerceBooleanProperty,\n  // },\n  position: {\n    aliasKey: 'stickyPosition',\n    defaultValue: 'top',\n    coercion: coerceStickyPosition,\n  },\n  spacer: {\n    aliasKey: 'stickySpacer',\n    defaultValue: null,\n  },\n  spot: {\n    aliasKey: 'stickySpot',\n    defaultValue: null,\n  },\n  spotHeight: {\n    aliasKey: 'stickySpotHeight',\n    defaultValue: 0,\n    coercion: coerceNumberProperty,\n  },\n};\n\n\n/**\n * Defines a sticky.\n */\n@Directive({\n  selector: '[ngxSticky], [ngx-sticky], ngx-sticky',\n  exportAs: 'ngxSticky',\n})\nexport class NgxStickyDirective extends NgxStickyBaseController implements AfterViewInit, OnChanges, OnDestroy {\n  /**\n   * Binding sticky classes.\n   *\n   * Defaults to `false`.\n   */\n  @Input()\n  stickyClasses: boolean;\n\n  /**\n   * Direction of the sticky; one of 'up' or 'down'.\n   *\n   * Defaults to `'down'`.\n   */\n  @Input()\n  stickyDirection: NgxStickyDirection;\n\n  /**\n   * Disable sticky.\n   *\n   * Defaults to `false`.\n   */\n  @Input()\n  stickyDisabled: boolean;\n\n  /**\n   * Force element height when calculate sticky element height.\n   */\n  @Input()\n  stickyHeight: number;\n\n  // /**\n  //  * Indicate sticky element is an orbit.\n  //  *\n  //  * An orbit is a sticky element which isn't visible until\n  //  * it's sticked.\n  //  *\n  //  * Generally an orbit spot on another element to be sticked.\n  //  *\n  //  * Defaults to `false`.\n  //  */\n  // @Input()\n  // stickyOrbit: boolean;\n\n  /**\n   * Position of the sticky; one of 'top' or 'bottom'.\n   *\n   * Defaults to `'top'`.\n   */\n  @Input()\n  stickyPosition: NgxStickyPosition;\n\n  /**\n   * Sticky spacer.\n   *\n   * Defaults to `null`.\n   */\n  @Input()\n  stickySpacer: HTMLElement | null;\n\n  /**\n   * Reference to an element used to determine sticky state.\n   *\n   * The sticky directive will stick element only when spot\n   * isn't visible.\n   *\n   * Defaults to `null`.\n   */\n  @Input()\n  stickySpot: HTMLElement | null;\n\n  /**\n   * Force spot height when calculate sticky spot height.\n   */\n  @Input()\n  stickySpotHeight: number;\n\n  /**\n   * Emit sticky computation.\n   */\n  @Output()\n  readonly stickyComputation = new EventEmitter<NgxStickyComputation>();\n\n  /**\n   * Emit sticky state.\n   */\n  @Output()\n  readonly stickyState = new EventEmitter<NgxStickyState>();\n\n  @HostBinding('attr.data-sticky-state')\n  get attrDataStickyState() { return !this.stickyParent ? this.state : null; }\n\n  @HostBinding('class.ngx-sticky')\n  get cssClassSticky() { return !this.stickyParent && this.config.classes; }\n\n  @HostBinding('class.ngx-sticky--normal')\n  get cssClassStickyNormal() { return this.cssClassSticky && this.state === 'normal'; }\n\n  @HostBinding('class.ngx-sticky--sticked')\n  get cssClassStickySticked() { return this.cssClassSticky && this.state === 'sticked'; }\n\n  @HostBinding('class.ngx-sticky--stucked')\n  get cssClassStickyStucked() { return this.cssClassSticky && this.state === 'stucked'; }\n\n  @HostBinding('class.ngx-sticky--disabled')\n  get cssClassStickyDisabled() { return this.cssClassSticky && this.disabled; }\n\n  // @HostBinding('class.ngx-sticky--spot')\n  // get cssClassStickySpot() { return this.cssClassSticky && !!this.config.spot; }\n\n  // @HostBinding('class.ngx-sticky--position-top')\n  // get cssClassStickyPositionTop() { return this.cssClassSticky && !isStickyPositionBottom(this.config.position); }\n\n  // @HostBinding('class.ngx-sticky--position-bottom')\n  // get cssClassStickyPositionBottom() { return this.cssClassSticky && isStickyPositionBottom(this.config.position); }\n\n  // @HostBinding('class.ngx-sticky--direction-up')\n  // get cssClassStickyDirectionUp() { return this.cssClassSticky && !isStickyDirectionDown(this.config.direction); }\n\n  // @HostBinding('class.ngx-sticky--direction-down')\n  // get cssClassStickydirectionDown() { return this.cssClassSticky && isStickyDirectionDown(this.config.direction); }\n\n  get boundary(): NgxStickyBoundaryController {\n    return this._boundary;\n  }\n\n  get container(): NgxStickyContainerController {\n    return this._container;\n  }\n\n  get config(): NgxStickyConfig {\n    return this.config$.getValue();\n  }\n\n  get disabled(): boolean {\n    return this.config.disabled;\n  }\n\n  /**\n   * State of the sticky.\n   */\n  get state(): NgxStickyState {\n    return this._stickyState;\n  }\n\n  /** Inputs config */\n  readonly config$ = new ConfigSubject<NgxStickyConfig>(NGX_STICKY_BASE_CONFIG_SCHEMA);\n\n  /** Sticky container controller */\n  readonly _container: NgxStickyContainerController;\n\n  /** Sticky boundary controller */\n  readonly _boundary?: NgxStickyBoundaryController;\n\n  /** Emits when the component is destroyed. */\n  readonly _destroyed$ = new Subject<void>();\n\n  /** Sticky element style original */\n  _elementOriginStyle: NgxStickyElementStyle;\n\n  /** Monitoring subscription which trigger update stickies and handle refresh */\n  _monitoring: Subscription;\n\n  /** Sticky spacer generated */\n  _spacerGenerated: HTMLElement;\n\n  /** Sticky which reflect last call of _computeSticky() */\n  _sticky: NgxSticky;\n\n  /** Emits when refresh() is called */\n  readonly _refresh$ = new Subject<NgxStickyComputation>();\n\n  /** Sticky computation which reflect last call of _refreshSticky()  */\n  _stickyComputation: NgxStickyComputation;\n\n  /** Sticky element state which reflect last call of _refreshStickyElement() */\n  _stickyElementState: NgxStickyState = null;\n\n  /** Sticky element state which reflect last sticky state output */\n  _stickyState: NgxStickyState = null;\n\n  constructor(\n    readonly rootContainer: NgxStickyRootContainerController,\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\n    readonly stickyContainer: NgxStickyContainerController,\n    @Optional() @Inject(forwardRef(() => NgxStickyBoundaryDirective))\n    readonly stickyBoundary: NgxStickyBoundaryController,\n    @SkipSelf() @Optional() @Inject(forwardRef(() => NgxStickyDirective))\n    readonly stickyParent: NgxStickyController,\n    readonly elementRef: ElementRef<HTMLElement>,\n    readonly renderer: Renderer2,\n    // readonly changeDetectorRef: ChangeDetectorRef,\n    readonly ngZone: NgZone,\n    @Inject(NGX_STICKY_WINDOW)\n    readonly _win: Window,\n  ) {\n    super();\n\n    // use root container when sticky isn't in container\n    this._container = stickyContainer || rootContainer;\n\n    // ensure sticky boundary is in same container\n    this._boundary = stickyBoundary && stickyBoundary.container === this._container ? stickyBoundary : null;\n\n    // register sticky in container only if isn't in another sticky\n    if (!this.stickyParent) {\n      // register in parent container for first update calls\n      this.container.registerSticky(this);\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.config$.nextChanges(changes);\n  }\n\n  ngAfterViewInit(): void {\n    // avoid sticky initialization when sticky has a parent\n    if (this._preventNestedStickyError()) {\n      return;\n    }\n\n    this._initMonitoring();\n  }\n\n  ngOnDestroy(): void {\n    this.container.unregisterSticky(this);\n\n    if (!this._destroyed$.isStopped) {\n      this._destroyed$.next();\n      this._destroyed$.complete();\n    }\n\n    this._destroyMonitoring();\n  }\n\n  beforeRefresh(fastUpdate?: boolean): void {\n    if (!fastUpdate) {\n      this._sticky = null;\n    }\n  }\n\n  disableSticky(): void {\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\n  }\n\n  enableSticky(): void {\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\n  }\n\n  getSticky(): NgxSticky {\n    if (!this._sticky) {\n      this._sticky = this._computeSticky();\n    }\n\n    return this._sticky;\n  }\n\n  refresh(computation: NgxStickyComputation): void {\n    this._refresh$.next(computation);\n  }\n\n  _computeSticky(): NgxSticky {\n    // IMPORTANT: refresh sticky element to its normal state is required to compute repainted element height.\n    this._refreshStickyElement(null);\n    this._refreshStickyElement('normal');\n\n    const config = this.config$.getValue();\n\n    // element and spot rects which reflects last screen repaint\n    const elementRect = getElementAbsoluteRect(this.elementRef.nativeElement);\n    const spotRect = config.spot ? getElementAbsoluteRect(config.spot) : null;\n\n    if (config.height) {\n      elementRect.height = config.height;\n    }\n\n    if (spotRect && config.spotHeight) {\n      spotRect.height = config.spotHeight;\n    }\n\n    return {\n      disabled: config.disabled,\n      boundary: this.boundary ? this.boundary.getBoundary() : null,\n      direction: config.direction,\n      height: elementRect.height,\n      position: config.position,\n      top: elementRect.top,\n      spot: spotRect,\n    };\n  }\n\n  /**\n   * Create sticky monitoring observable.\n   */\n  _createMonitoringObservable(): Observable<boolean> {\n    return merge(\n      this.config$,\n      fromImageEvents(this.elementRef.nativeElement),\n      fromImageEvents(this.config.spot),\n      animationFrameScheduler,\n    ).pipe(\n      // throttleTime(0, animationFrameScheduler),\n      mapTo(false),\n    );\n  }\n\n  /**\n   * Destroy sticky monitoring subscription.\n   */\n  _destroyMonitoring(): void {\n    if (this._monitoring) {\n      this._monitoring.unsubscribe();\n      this._monitoring = null;\n    }\n  }\n\n  /**\n   * Returns styles of the given state.\n   *\n   * `computation` is required when `state` is `\"sticked\"` or `\"stucked\"`.\n   *\n   * @param state Sticky state\n   * @param computation Sticky state computation\n   * @returns Styles of the sticky state\n   */\n  _getStickyElementStyle(state: NgxStickyState, computation?: NgxStickyComputation): Partial<NgxStickyElementStyle> {\n    const win = this._win;\n\n    if (!win || !state) {\n      return null;\n    }\n\n    const ghost = this.config.spacer || this._spacerGenerated;\n    const ghostParent = ghost.offsetParent as HTMLElement;\n    const ghostParentIsRootElement = ghostParent === win.document.body || ghostParent === win.document.documentElement;\n\n    // when state is normal (computation isn't needed)\n    if (state === 'normal') {\n      const ghostRelativeRect = getElementRelativeRect(win, ghost);\n      const ghostStyle = win.getComputedStyle(ghost);\n      const ghostBorderBox = ghostStyle.boxSizing === 'border-box';\n\n      let elementWidth = ghostRelativeRect.width;\n\n      if (!ghostBorderBox) {\n        elementWidth +=\n          - ((parseFloat(ghostStyle.borderLeft) || 0) + (parseFloat(ghostStyle.borderRight) || 0))\n          - ((parseFloat(ghostStyle.paddingLeft) || 0) + (parseFloat(ghostStyle.paddingRight) || 0));\n      }\n\n      let elementTop = ghostRelativeRect.top;\n      let elementLeft = ghostRelativeRect.left;\n\n      if (ghostParentIsRootElement) {\n        if (this.container !== this.rootContainer) {\n          const ghostRect = getElementAbsoluteRect(ghost);\n          const viewportTop = this.container.getViewportTop();\n\n          elementTop = ghostRect.top - viewportTop;\n        }\n\n        elementTop += win.document.documentElement.offsetTop;\n        elementLeft += win.document.documentElement.offsetLeft;\n      }\n\n      const styles = {\n        position: 'absolute',\n        width: `${elementWidth}px`,\n        top: `${elementTop}px`,\n        right: '',\n        bottom: '',\n        left: `${elementLeft}px`,\n        float: '',\n        margin: '0px',\n      };\n\n      return styles;\n    }\n\n    const { container, stickyComputed, viewportHeight } = computation.snap;\n\n    // when state is sticked\n    if (state === 'sticked') {\n      const positionBottom = stickyComputed.positionBottom;\n\n      let elementTop: number;\n      let elementLeft: number;\n\n      if (this.container !== this.rootContainer) {\n        const ghostRelativeRect = getElementRelativeRect(win, ghost);\n\n        elementLeft = ghostRelativeRect.left;\n\n        if (ghostParentIsRootElement) {\n          elementTop = container.top;\n\n          elementTop += win.document.documentElement.offsetTop;\n          elementLeft += win.document.documentElement.offsetLeft;\n        } else {\n          const ghostParentRect = getElementAbsoluteRect(ghostParent);\n\n          elementTop = computation.viewportTop - ghostParentRect.top;\n        }\n\n        if (positionBottom) {\n          elementTop += viewportHeight - stickyComputed.height - computation.offsetSticked - computation.offsetStucked;\n        } else {\n          elementTop += computation.offsetSticked + computation.offsetStucked;\n        }\n\n        return {\n          position: 'absolute',\n          top: `${elementTop}px`,\n          bottom: '',\n          left: `${elementLeft}px`,\n        };\n      } else {\n        const ghostRect = getElementAbsoluteRect(ghost);\n\n        elementTop = computation.offsetSticked + computation.offsetStucked;\n        elementLeft = ghostRect.left + win.document.documentElement.offsetLeft;\n\n        return {\n          position: 'fixed',\n          top: !positionBottom ? `${elementTop}px` : '',\n          bottom: positionBottom ? `${elementTop}px` : '',\n          left: `${elementLeft}px`,\n        };\n      }\n    }\n\n    // when state is stucked\n    if (state === 'stucked') {\n      const ghostRect = getElementAbsoluteRect(ghost);\n\n      let elementTop: number;\n      let elementLeft: number;\n\n      elementTop = getStuckedPositionTop(computation);\n\n      elementLeft = ghostRect.left;\n\n      if (ghostParentIsRootElement) {\n        if (this.container !== this.rootContainer) {\n          // we can't use computation.viewportTop because it's absolute viewport top\n          const relativeViewportTop = this.container.getViewportTop();\n\n          elementTop -= relativeViewportTop;\n        }\n\n        elementTop += win.document.documentElement.offsetTop;\n        elementLeft += win.document.documentElement.offsetLeft;\n      } else {\n        const ghostParentRect = getElementAbsoluteRect(ghostParent);\n\n        elementTop -= ghostParentRect.top;\n        elementLeft -= ghostParentRect.left;\n      }\n\n      return {\n        position: 'absolute',\n        top: `${elementTop}px`,\n        bottom: '',\n        left: `${elementLeft}px`,\n      };\n    }\n\n    // throw new Error(`Invalid state: ${state}`);\n    return null;\n  }\n\n  /**\n   * Returns sticky ghost style.\n   *\n   * @returns Styles of the sticky ghost\n   */\n  _getStickyGhostStyle(): NgxStickyGhostStyle {\n    const stickySpacer = this.config.spacer || this._spacerGenerated;\n\n    if (!this._win || !stickySpacer) {\n      return null;\n    }\n\n    const element = this.elementRef.nativeElement;\n    const elementStyle = this._win.getComputedStyle(element);\n    const elementnBorderBox = elementStyle.boxSizing === 'border-box';\n\n    let ghostHeight = element.offsetHeight;\n    // const ghostWidth = elementStyle.width;\n\n    // substract borders and paddings when element isn't border-boxed\n    if (!elementnBorderBox) {\n      ghostHeight +=\n        // substract vertical borders\n        - (parseFloat(elementStyle.borderTopWidth) || 0)\n        - (parseFloat(elementStyle.borderBottomWidth) || 0)\n        // substract vertical paddings\n        - (parseFloat(elementStyle.paddingTop) || 0)\n        - (parseFloat(elementStyle.paddingBottom) || 0);\n    }\n\n    const styles: NgxStickyGhostStyle = {\n      boxSizing: elementStyle.boxSizing,\n      position: elementStyle.position,\n      top: elementStyle.top,\n      right: elementStyle.right,\n      bottom: elementStyle.bottom,\n      left: elementStyle.left,\n      width: element.style.width,\n      // width: element.style.width || elementStyle.width,\n      // width: `${ghostWidth}px`,\n      height: `${ghostHeight}px`,\n      maxHeight: `${ghostHeight}px`,\n      minHeight: `${ghostHeight}px`,\n      borderTop: elementStyle.borderTop,\n      borderBottom: elementStyle.borderBottom,\n      borderLeft: elementStyle.borderLeft,\n      borderRight: elementStyle.borderRight,\n      // borderColor: 'transparent',\n      cssFloat: elementStyle.cssFloat,\n      marginTop: elementStyle.marginTop,\n      marginBottom: elementStyle.marginBottom,\n      marginLeft: elementStyle.marginLeft,\n      marginRight: elementStyle.marginRight,\n      paddingTop: elementStyle.paddingTop,\n      paddingBottom: elementStyle.paddingBottom,\n      paddingLeft: elementStyle.paddingLeft,\n      paddingRight: elementStyle.paddingRight,\n    };\n\n    // if (this.config.orbit) {\n    //   styles.position = 'absolute';\n    //   styles.width = element.style.width || elementStyle.width;\n    // }\n\n    return styles;\n  }\n\n  /**\n   * Hides sticky ghost.\n   */\n  _hideStickyGhost(): void {\n    const ghost = this.config.spacer || this._spacerGenerated;\n\n    if (!ghost) {\n      return;\n    }\n\n    this.renderer.setStyle(ghost, 'display', 'none');\n  }\n\n  /**\n   * Init sticky monitoring.\n   */\n  _initMonitoring(): void {\n    if (!this._win || this._monitoring) {\n      return;\n    }\n\n    this.ngZone.runOutsideAngular(() => {\n      const handleRefreshSubscription = this._refresh$\n        .pipe(\n          takeUntil(this._destroyed$),\n          distinctUntilChanged(),\n          throttleTime(0, animationFrameScheduler, { leading: true, trailing: true }),\n          share(),\n        )\n        .subscribe(computation => {\n          this._refreshSticky(computation);\n        });\n\n      const triggerUpdateSubscription = this._createMonitoringObservable()\n        .pipe(\n          takeUntil(this._destroyed$),\n          share(),\n        )\n        .subscribe(fastUpdate => {\n          this.update(fastUpdate);\n        });\n\n      this._monitoring = new Subscription();\n      this._monitoring.add(handleRefreshSubscription);\n      this._monitoring.add(triggerUpdateSubscription);\n    });\n  }\n\n  /**\n   * Inserts sticky ghost generated.\n   */\n  _insertStickyGhostGenerated(): void {\n    if (this._spacerGenerated) {\n      return;\n    }\n\n    const element = this.elementRef.nativeElement;\n\n    const ghost = this.renderer.createElement(element.tagName);\n    this.renderer.addClass(ghost, 'ngx-sticky-spacer');\n    // this.renderer.setStyle(ghost, 'borderStyle', 'solid');\n    // this.renderer.setStyle(ghost, 'borderColor', 'transparent');\n    this.renderer.insertBefore(element.parentElement, ghost, element);\n\n    this._spacerGenerated = ghost;\n  }\n\n  /**\n   * Log nested sticky error and returns `true` when sticky is in another sticky.\n   *\n   * @returns `true` when sticky is in another sticky\n   */\n  _preventNestedStickyError(): boolean {\n    if (!this.stickyParent) {\n      return false;\n    }\n\n    const nestedStickyError = new Error('Nested sticky is not support. Sticky will not work.');\n\n    const logLevel = isDevMode() ? 'error' : 'warn';\n    const logLevelLogger = console[logLevel];\n\n    logLevelLogger(nestedStickyError);\n\n    return true;\n  }\n\n  /**\n   * Refresh sticky with given computation.\n   *\n   * @param computation Sticky state computation\n   */\n  _refreshSticky(computation: NgxStickyComputation): void {\n    if (\n      // refresh sticky when state has changed\n      computation.state !== this._stickyElementState\n      // or when sticky is in container (other than window)\n      || this.container !== this.rootContainer\n    ) {\n      this._refreshStickyElement(computation.state, computation);\n    }\n\n    this._stickyComputation = computation;\n    this.stickyComputation.next(computation);\n\n    if (computation.state === this._stickyState) {\n      return;\n    }\n\n    this.ngZone.run(() => {\n      this._stickyState = computation.state;\n      this.stickyState.next(computation.state);\n\n      // this.changeDetectorRef.detectChanges();\n    });\n  }\n\n  /**\n   * Refreshs sticky element style.\n   *\n   * @param state Sticky state\n   * @param computation Sticky state computation when state is sticked or stucked\n   */\n  _refreshStickyElement(state: NgxStickyState, computation?: NgxStickyComputation): void {\n    if (!this._win) {\n      return;\n    }\n\n    // hide ghost and refresh original style when state is null\n    if (!state) {\n      this._stickyElementState = null;\n\n      this._hideStickyGhost();\n      this._restoreStickyElementStyle();\n\n      return;\n    }\n\n    this._stickyElementState = state;\n\n    this._saveStickyElementStyle();\n    this._showStickyGhost();\n\n    const elementStyle = this._getStickyElementStyle(state, computation);\n\n    setElementStyles(this.renderer, this.elementRef.nativeElement, elementStyle);\n  }\n\n  /**\n   * Refreshs sticky ghost.\n   */\n  _refreshStickyGhost(): void {\n    const ghost = this.config.spacer || this._spacerGenerated;\n    const ghostStyle = this._getStickyGhostStyle();\n\n    setElementStyles(this.renderer, ghost, ghostStyle);\n  }\n\n  /**\n   * Restore original styles of the sticky.\n   */\n  _restoreStickyElementStyle(): void {\n    setElementStyles(this.renderer, this.elementRef.nativeElement, this._elementOriginStyle);\n    this._elementOriginStyle = null;\n  }\n\n  /**\n   * Saves origin styles of the sticky.\n   */\n  _saveStickyElementStyle(): void {\n    if (!this._elementOriginStyle) {\n      this._elementOriginStyle = {\n        position: this.elementRef.nativeElement.style.position,\n        width: this.elementRef.nativeElement.style.width,\n        top: this.elementRef.nativeElement.style.top,\n        right: this.elementRef.nativeElement.style.right,\n        bottom: this.elementRef.nativeElement.style.bottom,\n        left: this.elementRef.nativeElement.style.left,\n        cssFloat: this.elementRef.nativeElement.style.cssFloat,\n        margin: this.elementRef.nativeElement.style.margin,\n        marginTop: this.elementRef.nativeElement.style.marginTop,\n        marginRight: this.elementRef.nativeElement.style.marginRight,\n        marginBottom: this.elementRef.nativeElement.style.marginBottom,\n        marginLeft: this.elementRef.nativeElement.style.marginLeft,\n      };\n    }\n  }\n\n  /**\n   * Shows sticky ghost.\n   */\n  _showStickyGhost(): void {\n    if (!this.config.spacer && !this._spacerGenerated) {\n      this._insertStickyGhostGenerated();\n      this._refreshStickyGhost();\n\n      return;\n    } else if (this.config.spacer && this._spacerGenerated) {\n      this._spacerGenerated.remove();\n      this._spacerGenerated = null;\n    }\n\n    const ghost = this.config.spacer || this._spacerGenerated;\n\n    if (ghost.style.display === 'none') {\n      this.renderer.setStyle(ghost, 'display', 'block');\n      this._refreshStickyGhost();\n    }\n  }\n}\n","import {\n  NgxStickyComputation,\n  NgxStickyDirection,\n  NgxStickyPosition,\n} from './sticky.types';\n\n\nexport function coerceStickyPosition(value: any): NgxStickyPosition {\n  return isStickyPositionBottom(value) ? 'bottom' : 'top';\n}\n\nexport function coerceStickyDirection(value: any): NgxStickyDirection {\n  return isStickyDirectionDown(value) ? 'down' : 'up';\n}\n\n\nexport function getStuckedPositionTop(computation: NgxStickyComputation): number {\n  const {\n    boundary,\n    directionDown,\n    height: elementHeight,\n    positionBottom,\n  } = computation.snap.stickyComputed;\n\n  return directionDown\n    ? boundary.top\n      + boundary.height\n      - elementHeight\n      - (positionBottom\n          ? computation.offsetStucked\n          : boundary.offsetBottom - elementHeight - computation.offsetStucked)\n    : positionBottom\n      ? boundary.top + boundary.offsetTop - elementHeight - computation.offsetStucked\n      : boundary.top + computation.offsetStucked;\n}\n\n\nexport function isStickyPositionBottom(position: NgxStickyPosition) {\n  return position === 'bottom';\n}\n\nexport function isStickyDirectionDown(direction: NgxStickyDirection) {\n  return direction !== 'up';\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { NgxInViewportDirective } from './in-viewport.directive';\nimport { NgxStickyBoundaryDirective } from './sticky-boundary.directive';\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\nimport { NgxStickySpotDirective } from './sticky-spot.directive';\nimport { NgxStickyDirective } from './sticky.directive';\n\n/**\n * Adds sticky directives and providers.\n *\n * Managing sticky elements is one of the hardest parts of building web applications.\n *\n * The NgxStickyModule allows to manage sticky elements in the best way.\n *\n * @example\n * NgxStickyModule can be imported multiple times: once per lazily-loaded bundle.\n *\n * ```\n * @NgModule({\n *   imports: [ NgxStickyModule ]\n * })\n * class MyNgModule {}\n * ```\n */\n@NgModule({\n  declarations: [\n    NgxInViewportDirective,\n    NgxStickyBoundaryDirective,\n    NgxStickyContainerDirective,\n    NgxStickyDirective,\n    NgxStickySpotDirective,\n  ],\n  exports: [\n    NgxInViewportDirective,\n    NgxStickyBoundaryDirective,\n    NgxStickyContainerDirective,\n    NgxStickyDirective,\n    NgxStickySpotDirective,\n  ],\n  imports: [ CommonModule ],\n})\nexport class NgxStickyModule { }\n","import { InjectionToken } from '@angular/core';\n\n\nexport const NGX_STICKY_WINDOW = new InjectionToken<Window>('NGX_STICKY_WINDOW', {\n  providedIn: 'root',\n  factory: () => typeof window !== 'undefined' ? window : null,\n});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport function coerceBooleanProperty(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n\n\n/** Coerces a data-bound value (typically a string) to a number. */\nexport function coerceNumberProperty(value: any): number;\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\n  return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nexport function _isNumberValue(value: any): boolean {\n  // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n  // and other non-number values as NaN, where Number just uses 0) but it considers the string\n  // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n  return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\n}\n","\n\n/**\n * Add entry into set.\n *\n * @param set Array list\n * @param entry Entry to add\n * @returns Entry index added\n */\nexport function addEntry<T>(set: T[], entry: T): number {\n  let entryIndex = set.indexOf(entry);\n\n  if (entryIndex === -1) {\n    entryIndex = set.length;\n\n    set[entryIndex] = entry;\n  }\n\n  return entryIndex;\n}\n\n\n/**\n * Delete entry from set.\n *\n * @param set Array list\n * @param entry Entry to delete\n * @returns Entry index deleted\n */\nexport function deleteEntry<T>(set: T[], entry: T): number {\n  const entryIndex = set.indexOf(entry);\n\n  if (entryIndex !== -1) {\n    set.splice(entryIndex, 1);\n  }\n\n  return entryIndex;\n}\n","import { Subject, Subscription } from 'rxjs';\n\nimport { InputCoercionFn, InputSubject, InputSubjectChange, InputSubjectNextOptions } from './input-subject';\n\n\nexport type ConfigInputSubjects<T> = { [K in keyof T]: InputSubject<T[K]> };\nexport type ConfigSubjectChanges<T> = { [K in keyof T]: InputSubjectChange<T[K]> };\nexport type ConfigSubjectSchema<T> = { [K in keyof T]: ConfigSubjectInputOptions<T, K> };\n\nexport interface ConfigSubjectInputOptions<T, K extends keyof T> {\n  defaultValue: T[K];\n  aliasKey?: string;\n  coercion?: InputCoercionFn<T[K]>;\n}\n\n\n/**\n * A ConfigSubject is an Observable that coerces key-values and emit when change is detected\n */\nexport class ConfigSubject<T> extends Subject<T> {\n  /** Emit key-values changes */\n  readonly changes$ = new Subject<ConfigSubjectChanges<T>>();\n  /** Input subjects for each config key-value */\n  readonly inputs: ConfigInputSubjects<T>;\n\n  _config: T;\n  _configChanged: boolean;\n  _configChanges: ConfigSubjectChanges<T>;\n\n  readonly _aliases: { [key: string]: keyof T };\n\n  readonly _pushChangesSubscription = new Subscription();\n\n  constructor(schema: ConfigSubjectSchema<T>) {\n    super();\n\n    this.inputs = {} as ConfigInputSubjects<T>;\n    this._config = {} as T;\n    this._configChanges = {} as ConfigSubjectChanges<T>;\n    this._aliases = {};\n\n    const inputKeys = Object.keys(schema) as (keyof T)[];\n\n    for (const inputKey of inputKeys) {\n      const inputOptions = schema[inputKey];\n\n      if (inputOptions.aliasKey) {\n        this._aliases[inputOptions.aliasKey] = inputKey;\n      }\n\n      const input = new InputSubject<T[keyof T]>(inputOptions.defaultValue, inputOptions.coercion);\n\n      this._config[inputKey] = inputOptions.defaultValue;\n      this.inputs[inputKey] = input;\n\n      const pushChangeSubscription = input.change$.subscribe(inputChange => {\n        this._configChanged = true;\n        this._configChanges[inputKey] = inputChange;\n\n        this._config = { ...this._config };\n        this._config[inputKey] = inputChange.currentValue;\n      });\n\n      this._pushChangesSubscription.add(pushChangeSubscription);\n    }\n  }\n\n  /**\n   * Returns current config.\n   */\n  getValue(): T {\n    return this._config;\n  }\n\n  /**\n   * Returns key-value.\n   *\n   * @param inputKey Input key\n   * @returns key-value\n   */\n  getKeyValue<K extends keyof T>(inputKey: K): T[K] {\n    return this._config[inputKey];\n  }\n\n  /**\n   * Emit next config.\n   *\n   * @param partialConfig Partial next config\n   * @param options Options to skip coercion\n   */\n  next(partialConfig?: Partial<T>, options?: InputSubjectNextOptions): void {\n    const inputKeys = Object.keys(partialConfig);\n\n    for (const key of inputKeys) {\n      const inputKey = (this._aliases[key] || key) as keyof T;\n\n      if (inputKey in this.inputs) {\n        const inputValue = partialConfig[key] as T[keyof T];\n        const inputSubject = this.inputs[inputKey];\n\n        inputSubject.next(inputValue, options);\n      }\n    }\n\n    if (this._configChanged) {\n      const changes = { ...this._configChanges };\n\n      this._configChanged = false;\n      this._configChanges = {} as ConfigSubjectChanges<T>;\n\n      this.changes$.next(changes);\n\n      super.next(this._config);\n    }\n  }\n\n  /**\n   * Emit next key-value.\n   *\n   * @param inputKey Input key\n   * @param value key-value\n   * @param options Options to skip coercion\n   */\n  nextKeyValue<K extends keyof T>(inputKey: K, value: T[K], options?: InputSubjectNextOptions): void {\n    this.next({ [inputKey]: value } as {} as Partial<T>, options);\n  }\n\n  /**\n   * Apply simple changes as like ngOnChange(changes: SimpleChanges) input.\n   *\n   * @param changes Simple changes\n   */\n  nextChanges(changes: { [key: string]: { currentValue: any } }) {\n    const changeKeys = Object.keys(changes);\n    const config: Partial<T> = {};\n\n    for (const inputKey of changeKeys) {\n      config[inputKey] = changes[inputKey].currentValue;\n    }\n\n    this.next(config);\n  }\n}\n","import { Renderer2 } from '@angular/core';\n\n\n/**\n * Returns getter for document height.\n *\n * @param win Window reference\n * @returns Getter for document height.\n */\nexport function getDocumentHeightFactory(win: Window): () => number {\n  if (!win) {\n    return () => 0;\n  }\n\n  const documentHeightGetters = [\n    () => win.document.body.scrollHeight,\n    () => win.document.documentElement.scrollHeight,\n    () => win.document.body.offsetHeight,\n    () => win.document.documentElement.offsetHeight,\n    () => win.document.body.clientHeight,\n    () => win.document.documentElement.clientHeight,\n  ];\n\n  let documentHeightGetter = documentHeightGetters[0];\n  let documentHeight = 0;\n\n  for (const _documentHeightGetter of documentHeightGetters) {\n    const _documentHeight = _documentHeightGetter();\n\n    if (_documentHeight > documentHeight) {\n      documentHeightGetter = _documentHeightGetter;\n      documentHeight = _documentHeight;\n    }\n  }\n\n  return documentHeightGetter;\n}\n\n\n/**\n * Returns getter for document width.\n *\n * @param win Window reference\n * @returns Getter for document width.\n */\nexport function getDocumentWidthFactory(win: Window): () => number {\n  if (!win) {\n    return () => 0;\n  }\n\n  const documentWidthGetters = [\n    () => win.document.body.scrollWidth,\n    () => win.document.documentElement.scrollWidth,\n    () => win.document.body.offsetWidth,\n    () => win.document.documentElement.offsetWidth,\n    () => win.document.body.clientWidth,\n    () => win.document.documentElement.clientWidth,\n  ];\n\n  let documentWidthGetter = documentWidthGetters[0];\n  let documentWidth = 0;\n\n  for (const _documentWidthGetter of documentWidthGetters) {\n    const _documentWidth = _documentWidthGetter();\n\n    if (_documentWidth > documentWidth) {\n      documentWidthGetter = _documentWidthGetter;\n      documentWidth = _documentWidth;\n    }\n  }\n\n  return documentWidthGetter;\n}\n\n\n/**\n * Returns element absolute rect.\n *\n * @param element Element\n * @returns Element absolute rect\n */\nexport function getElementAbsoluteRect(element: HTMLElement) {\n  const rect = {\n    height: element.offsetHeight,\n    width: element.offsetWidth,\n    left: 0,\n    top: 0,\n  };\n\n  let currentElement = element;\n\n  do {\n    rect.top += currentElement.offsetTop || 0;\n    rect.left += currentElement.offsetLeft || 0;\n\n    currentElement = currentElement.offsetParent as HTMLElement;\n  } while (currentElement);\n\n  return rect;\n}\n\n\n/**\n * Returns element relative rect.\n *\n * @param win Window reference\n * @param element Element\n * @returns Element relative rect.\n */\nexport function getElementRelativeRect(win: Window, element: HTMLElement) {\n  const rect = {\n    height: element.offsetHeight,\n    width: element.offsetWidth,\n    left: 0,\n    top: 0,\n  };\n\n  let currentElement = element;\n  let currentElementStyle: CSSStyleDeclaration;\n\n  do {\n    currentElementStyle = currentElement !== element ? win.getComputedStyle(currentElement) : {} as CSSStyleDeclaration;\n\n    if (currentElementStyle.position === 'relative') {\n      break;\n    }\n\n    if (currentElementStyle.position !== 'absolute') {\n      rect.top += currentElement.offsetTop || 0;\n      rect.left += currentElement.offsetLeft || 0;\n    }\n\n    currentElement = currentElement.offsetParent as HTMLElement;\n  } while (currentElement);\n\n  return rect;\n}\n\n\n/**\n * Get window viewport height.\n *\n * @param win Window reference\n * @returns Window viewport height\n */\nexport function getWindowViewportHeight(win: Window): number {\n  return win && win.innerHeight || 0;\n}\n\n\n/**\n * Get window scroll left position.\n *\n * @param win Window reference\n * @returns Window scroll left position\n */\nexport function getWindowViewportLeft(win: Window): number {\n  if (!win) {\n    return 0;\n  }\n\n  // The top-left-corner of the viewport is determined by the scroll position of the document\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n  // `document.documentElement` works consistently, where the `top` and `left` values will\n  // equal negative the scroll position.\n  const documentRect = win.document.documentElement.getBoundingClientRect();\n\n  return -documentRect.left\n    || win.document.body.scrollLeft\n    || win.scrollX\n    || win.document.documentElement.scrollLeft\n    || 0;\n}\n\n\n/**\n * Get window scroll top position.\n *\n * @param win Window reference\n * @returns Window scroll top position\n */\nexport function getWindowViewportTop(win: Window): number {\n  if (!win) {\n    return 0;\n  }\n\n  // The top-left-corner of the viewport is determined by the scroll position of the document\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n  // `document.documentElement` works consistently, where the `top` and `left` values will\n  // equal negative the scroll position.\n  const documentRect = win.document.documentElement.getBoundingClientRect();\n\n  return -documentRect.top\n    || win.document.body.scrollTop\n    || win.scrollY\n    || win.document.documentElement.scrollTop\n    || 0;\n}\n\n\n/**\n * Returns `true` when element is scrollable.\n *\n * @param win Window reference\n * @param element Element\n * @returns `true` when element is scrollable\n */\nexport function isElementScrollableY(win: Window, element: HTMLElement): boolean {\n  return element.offsetHeight < element.scrollHeight && win.getComputedStyle(element).overflowY === 'auto';\n}\n\n\n/**\n * Set styles on a given element.\n *\n * @param renderer Renderer2 instance\n * @param element Element\n * @param styles Styles\n */\nexport function setElementStyles(\n  renderer: Renderer2,\n  element: HTMLElement,\n  styles: any,\n): void {\n  if (!element || !styles) {\n    return;\n  }\n\n  const propKeys = Object.keys(styles);\n\n  for (const prop of propKeys) {\n    const value = styles[prop];\n\n    if (value) {\n      renderer.setStyle(element, prop, value);\n    } else {\n      renderer.removeStyle(element, prop);\n    }\n  }\n}\n\n","import { Observable, fromEvent, merge, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n\n/**\n * Create observable which emit image events.\n *\n * @param element Element\n * @returns Observable on image events\n */\nexport function fromImageEvents(element: HTMLElement): Observable<{ event: Event; target: HTMLImageElement }> {\n  if (!element) {\n    return of();\n  }\n\n  const images$: Observable<{ event: Event; target: HTMLImageElement }>[] = [];\n\n  const addImage = (target: HTMLImageElement) => images$.push(\n    fromEvent(target, 'load').pipe(map(event => ({ event, target }))),\n    fromEvent(target, 'error').pipe(map(event => ({ event, target }))),\n  );\n\n  // if (element instanceof HTMLImageElement) {\n  if (element.tagName === 'IMG' || element.tagName === 'img') {\n    addImage(element as HTMLImageElement);\n  } else {\n    element.querySelectorAll('img').forEach(addImage);\n  }\n\n  return merge(...images$);\n}\n","import { BehaviorSubject, Observable, of } from 'rxjs';\n\n/**\n * Create observable which emit media query events.\n *\n * @param win Window reference\n * @param query Media query\n * @returns Observable on media query events\n */\nexport function fromMediaQuery(win: Window, query: string): Observable<MediaQueryListEvent> {\n  if (!win || !win.matchMedia) {\n    return of();\n  }\n\n  const mql = win.matchMedia(query);\n\n  const initEvent = {\n    matches: mql.matches,\n    media: query,\n  };\n\n  const initMqlEvent = typeof MediaQueryListEvent !== 'undefined'\n    ? new MediaQueryListEvent('change', initEvent)\n    : { type: 'change', ...initEvent} as MediaQueryListEvent;\n\n  const mql$ = new BehaviorSubject<MediaQueryListEvent>(initMqlEvent);\n\n  const onQueryChange = (mqlEvent: MediaQueryListEvent) => mql$.next(mqlEvent);\n  const complete = mql$.complete;\n\n  mql$.complete = function() {\n    complete.call(mql$);\n    mql.removeListener(onQueryChange);\n  };\n\n  mql.addListener(onQueryChange);\n\n  return mql$;\n}\n","export * from './coercion';\nexport * from './collections';\nexport * from './config-subject';\nexport * from './dom';\nexport * from './from-image-events';\nexport * from './from-media-query';\nexport * from './input-subject';\nexport * from './intersection';\n","import { Subject } from 'rxjs';\n\n\nexport type InputCoercionFn<T> = (value: T) => T;\n\nexport interface InputSubjectNextOptions {\n  skipCoercion?: boolean;\n}\n\nexport interface InputSubjectChange<T> {\n  previousValue: T;\n  currentValue: T;\n  firstChange: boolean;\n}\n\n\n/**\n * An InputSubject is an Observable that coerces values and emit when change is detected.\n */\nexport class InputSubject<T> extends Subject<T> {\n  /** Emit value changes */\n  readonly change$ = new Subject<InputSubjectChange<T>>();\n\n  _firstChange = true;\n  _value: T;\n  _valueSetted: T;\n\n  constructor(\n    readonly defaultValue: T,\n    readonly coercion?: InputCoercionFn<T>,\n  ) {\n    super();\n\n    this._value = defaultValue;\n  }\n\n  /**\n   * Returns current value.\n   */\n  getValue(): T {\n    return this._value;\n  }\n\n  /**\n   * Emit next value.\n   *\n   * @param value Next value\n   * @param options Options to skip coercion\n   */\n  next(value?: T, options?: InputSubjectNextOptions): void {\n    if (!options || !options.skipCoercion) {\n      if (value === this._valueSetted) {\n        return;\n      }\n\n      this._valueSetted = value;\n\n      if (this.coercion) {\n        value = this.coercion(value);\n      }\n    }\n\n    if (value !== this._value) {\n      const firstChange = this._firstChange;\n      const previousValue = this._value;\n\n      this._firstChange = false;\n      this._value = value;\n\n      this.change$.next({\n        previousValue,\n        currentValue: value,\n        firstChange,\n      });\n\n      super.next(value);\n    }\n  }\n}\n","\n\n/** Coerces a data-bound value (typically a string) to intersection thresholds. */\nexport function coerceIntersectionThresholds(thresholds: any) {\n  if (typeof thresholds === 'number') {\n    return [ thresholds ];\n  }\n\n  if (typeof thresholds === 'string') {\n    return (thresholds as string)\n      .split(',')\n      .map(x => (parseFloat(x) || 0))\n      .sort();\n  }\n\n  if (!thresholds) {\n    return [ 0, 1 ];\n  }\n\n  if (!Array.isArray(thresholds)) {\n    thresholds = [ thresholds ];\n  }\n\n  return [ ...thresholds ].sort();\n}\n\n\n/**\n * Returns threshold crossed for a given ratio change.\n *\n * @param thresholds Thresholds\n * @param oldRatio Old ratio\n * @param newRatio New ratio\n * @returns Threshold crossed or `undefined`\n */\nexport function getCrossedThreshold(thresholds: number[], oldRatio: number, newRatio: number): number {\n  let crossedThreshold: number;\n\n  for (const threshold of thresholds) {\n    if (\n      // threshold is perfect-crossed by old ratio\n      threshold === oldRatio\n      // or threshold is perfect-crossed by new ratio\n      || threshold === newRatio\n      // or threshold is crossed by new ratio and old ratio (there are on the opposite sides)\n      || threshold < oldRatio !== threshold < newRatio\n    ) {\n      crossedThreshold = threshold;\n      break;\n    }\n  }\n\n  return crossedThreshold;\n}\n","/*\n * Public API Surface of @enten/ngx-sticky\n */\n\nexport * from './lib/in-viewport.directive';\nexport * from './lib/sticky-base-boundary.controller';\nexport * from './lib/sticky-base-container.controller';\nexport * from './lib/sticky-base-container.directive';\nexport * from './lib/sticky-base.controller';\nexport * from './lib/sticky-boundary.directive';\nexport * from './lib/sticky-container.directive';\nexport * from './lib/sticky-engine';\nexport * from './lib/sticky-root-container.controller';\nexport * from './lib/sticky-spot.directive';\nexport * from './lib/sticky.directive';\nexport * from './lib/sticky.helpers';\nexport * from './lib/sticky.module';\nexport * from './lib/sticky.tokens';\nexport * from './lib/sticky.types';\nexport * from './lib/utils';\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [];\n\n@NgModule({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ RouterModule ],\n})\nexport class AppRoutingModule { }\n","import { ChangeDetectorRef, Component, Inject, OnDestroy, OnInit } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\nimport {\n  NGX_STICKY_WINDOW,\n  NgxStickyDirection,\n  NgxStickyPosition,\n  fromMediaQuery,\n} from '../../projects/ngx-sticky/src/public-api';\n\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: [ './app.component.scss' ],\n})\nexport class AppComponent implements OnDestroy, OnInit  {\n  apiBoundaryStickyDisabled = false;\n  apiBoundaryStickyOrbit = false;\n  apiBoundaryStickyDirection: NgxStickyDirection = 'down';\n  apiBoundaryStickyPosition: NgxStickyPosition = 'top';\n\n  apiContainerStickyDisabled = false;\n  apiContainerStickyOrbit = false;\n  apiContainerStickyDirection: NgxStickyDirection = 'down';\n  apiContainerStickyOffsetTop = 0;\n  apiContainerStickyOffsetBottom = 0;\n  apiContainerStickyPosition: NgxStickyPosition = 'top';\n\n  apiInViewportStickyDisabled = false;\n  apiInViewportStickyOrbit = false;\n  apiInViewportStickyDirection: NgxStickyDirection = 'down';\n  apiInViewportStickyPosition: NgxStickyPosition = 'top';\n\n  _isSmallScreen: boolean;\n  _smallBreakpointSubscription: Subscription;\n\n  constructor(\n    readonly changeDetectorRef: ChangeDetectorRef,\n    @Inject(NGX_STICKY_WINDOW)\n    readonly win: Window,\n  ) { }\n\n  ngOnInit(): void {\n    const smallBreakpoint$ = fromMediaQuery(this.win, '(min-width: 640px)');\n\n    this._smallBreakpointSubscription = smallBreakpoint$.subscribe(mqlEvent => {\n      this._isSmallScreen = !mqlEvent.matches;\n    });\n  }\n\n  ngOnDestroy(): void {\n    if (this._smallBreakpointSubscription) {\n      this._smallBreakpointSubscription.unsubscribe();\n      this._smallBreakpointSubscription = null;\n    }\n  }\n}\n","<nav ngx-sticky class=\"navigation\">\n  <section class=\"container\">\n    <a href=\"https://github.com/enten/ngx-sticky\">\n      <h1>ngx-sticky</h1>\n    </a>\n  </section>\n</nav>\n\n<header class=\"header\">\n  <section class=\"features container text\">\n    <h2>Features</h2>\n    <ul>\n      <li>Stick all the things!</li>\n      <li>Super smooth!</li>\n      <li>Tested in real world projects</li>\n      <li>Support for <strong>Angular Universal</strong></li>\n      <li>Prevents page-jumping when switching to sticky mode</li>\n      <li>No jQuery or other dependencies - <strong>pure Angular</strong> solution</li>\n      <li>Support for boundaries to make elements stop.</li>\n    </ul>\n  </section>\n  <section class=\"installation container text\">\n    <h2>Installation</h2>\n    <p>with npm:</p>\n    <pre data-header=\"shell\" class=\"code\"><code>npm install @enten/ngx-sticky</code></pre>\n    <p>with yarn:</p>\n    <pre data-header=\"shell\" class=\"code\"><code>yarn add @enten/ngx-sticky</code></pre>\n    <p>Now import the <code>NgxStickyModule</code> in the corresponding Module</p>\n    <pre data-header=\"ts\" class=\"code\"><code><span class=\"ts-keyword\">import</span> <span class=\"ts-sign\">{{ '{' }}</span> <span class=\"ts-user-declaration\">NgxStickyModule</span> <span class=\"ts-sign\">{{ '}' }}</span> <span class=\"ts-keyword\">from</span> <span class=\"ts-sign\">'</span><span class=\"ts-string\">@enten/ngx-sticky</span><span class=\"ts-sign\">';</span>\n\n<span class=\"ts-decorator\">@NgModule</span><span class=\"ts-sign\">({{ '{' }}</span>\n  imports<span class=\"ts-sign\">: [</span>\n    <span class=\"ts-user-declaration\">NgxStickyModule</span><span class=\"ts-sign\">,</span> \n  <span class=\"ts-sign\">],</span> \n  declarations<span class=\"ts-sign\">: [],</span>\n  providers<span class=\"ts-sign\">: [],</span>\n<span class=\"ts-sign\">{{ '}' }})</span>\n<span class=\"ts-keyword\">export</span> <span class=\"ts-keyword\">class</span> <span class=\"ts-user-declaration\">SomeModule</span> <span class=\"ts-sign\">{{ '{ }' }}</span></code></pre>\n  </section>\n  <section class=\"usage container text\">\n    <h2>Usage</h2>\n    <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\n  I am sticky!\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n  </section>\n  <section class=\"more container text\">\n    <h2>More</h2>\n    <div>\n      For more information see: <a href=\"https://github.com/enten/ngx-sticky\">https://github.com/enten/ngx-sticky</a>.\n    </div>\n  </section>\n</header>\n\n<section class=\"examples\">\n  <div class=\"container\">\n    <h2>Examples</h2>\n\n    <div class=\"example\">\n      <h3>Sticky</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">stickyDisabled</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [value]=\"exampleSticky1.disabled\" (change)=\"exampleSticky1.config$.nextKeyValue('disabled', $event.target.checked)\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n  I am sticky!\n<span class=\"html-tag\">&lt;/p&gt;</span></code></pre>\n        </div>\n        <div ngx-sticky-boundary class=\"preview\">\n          <p ngx-sticky #exampleSticky1=\"ngxSticky\">\n            I am sticky!\n          </p>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"example\">\n      <h3>Sticky inside boundary</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-attr\">stickyDisabled</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [value]=\"exampleStickyOutsideBoundary.disabled\" (change)=\"exampleStickyOutsideBoundary.config$.nextKeyValue('disabled', $event.target.checked)\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n  I am sticky!\n<span class=\"html-tag\">&lt;/p&gt;</span>\n\n<span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\n    Sticky inside boundary\n  <span class=\"html-tag\">&lt;/p&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n        </div>\n        <div ngx-sticky-boundary class=\"preview\">\n          <p #exampleStickyOutsideBoundary=\"ngxSticky\" ngx-sticky>I am sticky!</p>\n          <div ngx-sticky-boundary style=\"margin: 5rem auto; height: 30rem; width: 80%;\">\n            <p ngx-sticky>Sticky inside boundary</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"example\">\n      <h3>Sticky boundary unstacked</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span>\n  <span class=\"html-attr\">ngx-sticky-boundary</span>\n  <span class=\"html-attr\">stickyUnstacked</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [checked]=\"exampleBoundaryUnstacked.config.unstacked\" (change)=\"exampleBoundaryUnstacked.config$.nextKeyValue('unstacked', $event.target.checked)\"><span class=\"html-sign\">&quot;</span>\n<span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n        </div>\n        <div class=\"preview\">\n          <div #exampleBoundaryUnstacked=\"ngxStickyBoundary\" ngx-sticky-boundary stickyUnstacked style=\"margin: 5rem auto; width: 80%;\">\n            <div style=\"height: 5rem\"></div>\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 1</p>\n            <div style=\"height: 5rem\"></div>\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 2</p>\n            <div style=\"height: 5rem\"></div>\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 3</p>\n            <div style=\"height: 5rem\"></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"example\">\n      <h3>Sticky position bottom</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span>\n  <span class=\"html-tag\">&gt;</span>Sticky bottom direction up<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">down</span><span class=\"html-sign\">&quot;</span>\n  <span class=\"html-tag\">&gt;</span>Sticky bottom direction down<span class=\"html-tag\">&lt;/p&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n        </div>\n        <div ngx-sticky-boundary offsetTop=\"0\" offsetBottom=\"200\" class=\"preview\">\n          <div style=\"height: 800px;\"></div>\n          <p ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">\n            Sticky bottom direction up\n          </p>\n          <p ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"down\">\n            Sticky bottom direction down\n          </p>\n          <div style=\"height: 800px;\"></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"example\">\n      <h3>Sticky container</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-container</span>\n  <span class=\"html-attr\">style</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">height: 400px; overflow: auto;</span><span class=\"html-sign\">&quot;</span>\n&gt;\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">ngx-sticky</span>\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">top</span><span class=\"html-sign\">&quot;</span>\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">down</span><span class=\"html-sign\">&quot;</span>\n  <span class=\"html-tag\">&gt;</span>Header<span class=\"html-tag\">&lt;/header&gt;</span>\n  <span class=\"html-tag\">&lt;section</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;/section&gt;</span>\n  <span class=\"html-tag\">&lt;footer</span> <span class=\"html-attr\">ngx-sticky</span>\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span>\n  <span class=\"html-tag\">&gt;</span>Footer<span class=\"html-tag\">&lt;/div&gt;</span>\n<span class=\"html-tag\">&lt;/footer&gt;</span></code></pre>\n        </div>\n        <div ngx-sticky-container class=\"preview\" style=\"position: relative; overflow: auto; height: 40rem\">\n          <header ngx-sticky>Header</header>\n          <div style=\"height: 12rem\"></div>\n          <section ngx-sticky-boundary style=\"position: relative;\">\n            <!-- <p ngx-sticky style=\"position: absolute; top: 50px; right: 50px; width: 50px; height: 50px; padding: 0; background: lightsteelblue;\">\n              Sticky\n            </p> -->\n            <div style=\"height: 10rem;\"></div>\n            <p ngx-sticky>Sticky 1</p>\n            <div style=\"height: 5rem;\"></div>\n            <p ngx-sticky>Sticky 2</p>\n            <div style=\"height: 5rem;\"></div>\n            <p ngx-sticky stickyPosition=\"bottom\">Sticky 3</p>\n            <div style=\"height: 10rem;\"></div>\n          </section>\n          <div style=\"height: 36rem\"></div>\n          <footer ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">Footer</footer>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"example sticky-classes\">\n      <h3>Sticky classes</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">container</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">header</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>Header<span class=\"html-tag\">&lt;/header&gt;</span>\n  <span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">#headerSticky</span>\n    <span class=\"html-attr\">ngx-sticky</span>\n    <span class=\"html-attr\">stickyClasses</span>\n    <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">header-sticky</span><span class=\"html-sign\">&quot;</span>\n  <span class=\"html-tag\">&gt;</span>\n    {{ '{{' }} headerSticky.className {{ '\\}\\}' }}\n  <span class=\"html-tag\">&lt;/div&gt;</span>\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span>\n\n<span class=\"html-tag\">&lt;style&gt;</span>\n.container {{ '{' }}\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">relative</span>;\n{{ '\\}' }}\n.header {{ '{' }}\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">relative</span>;\n  <span class=\"css-prop\">z-index</span>: <span class=\"css-user-value\">2</span>;\n{{ '\\}' }}\n.header-sticky {{ '{' }}\n  <span class=\"css-prop\">display</span>: <span class=\"css-value\">none</span>;\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">absolute</span>;\n  <span class=\"css-prop\">transform</span>: <span class=\"css-user-value\">translateY(-100%)</span>;\n  <span class=\"css-prop\">transition</span>: <span class=\"css-user-value\">transform 0.3s</span>;\n  <span class=\"css-prop\">width</span>: <span class=\"css-user-value\">100%</span>;\n  <span class=\"css-prop\">z-index</span>: <span class=\"css-user-value\">1</span>;\n{{ '\\}' }}\n.header-sticky:not(.ngx-sticky--disabled) {{ '{' }}\n  <span class=\"css-prop\">display</span>: <span class=\"css-value\">block</span>;\n{{ '\\}' }}\n.header-sticky:not(.ngx-sticky--normal) {{ '{' }}\n  <span class=\"css-prop\">transform</span>: <span class=\"css-user-value\">translateY(0%)</span>;\n{{ '\\}' }}\n<span class=\"html-tag\">&lt;/style&gt;</span>\n</code></pre>\n        </div>\n        <div ngx-sticky-boundary class=\"preview\">\n          <header style=\"padding: 2rem 1rem\">Header</header>\n          <div #exampleStickyClasses=\"ngxSticky\" ngx-sticky stickyClasses stickyDisabled=\"false\" class=\"header-sticky\">.ngx-sticky--{{ exampleStickyClasses.state }}</div>\n          <p></p>\n          <p></p>\n          <p></p>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"example\">\n      <h3>Sticky with spot</h3>\n      <div class=\"sidepanes\">\n        <div ngx-sticky-boundary class=\"controls\">\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">[stickySpot]</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">spot</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n    Sticky with spot\n  <span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">[style.height.px]</span><span class=\"html-sign\">=&quot;</span><input #stickyWithSpotBlankHeight type=\"number\" value=\"1500\" class=\"html-attr-value\" style=\"width: 5rem;\" (change)=\"changeDetectorRef.detectChanges(); exampleStickyWithSpot.update()\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;/div&gt;</span>\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">#spot</span><span class=\"html-tag\">&gt;</span>Spot<span class=\"html-tag\">&lt;/p&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n        </div>\n        <div ngx-sticky-boundary class=\"preview\">\n          <p #exampleStickyWithSpot=\"ngxSticky\" ngx-sticky [stickySpot]=\"spot\">Sticky with spot</p>\n          <div [style.height.px]=\"stickyWithSpotBlankHeight.value\"></div>\n          <div #spot style=\"padding: 2em 1em; background: lightblue;\">\n            Spot<br>\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</section>\n\n<section class=\"api\">\n  <div class=\"container\">\n    <h2>API</h2>\n\n    <div>\n      <h3>NgxStickyDirective</h3>\n      <div class=\"sidepanes\">\n        <div class=\"controls\" ngx-sticky-boundary>\n          <div ngx-sticky [stickyDisabled]=\"_isSmallScreen\">\n            <div class=\"controls-header\">\n              ngx-sticky\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                inputs\n              </div>\n              <div>\n                <label>stickyDisabled</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiSticky.disabled\"\n                  (change)=\"apiSticky.config$.nextKeyValue('disabled', $event.target.checked)\"\n                >\n              </div>\n              <div>\n                <label>stickyPosition</label>\n                <select\n                  [value]=\"apiSticky.config.position\"\n                  (change)=\"apiSticky.config$.nextKeyValue('position', $event.target.value)\"\n                >\n                  <option value=\"top\">top</option>\n                  <option value=\"bottom\">bottom</option>\n                </select>\n              </div>\n              <div>\n                <label>stickyDirection</label>\n                <select\n                  [value]=\"apiSticky.config.direction\"\n                  (change)=\"apiSticky.config$.nextKeyValue('direction', $event.target.value)\"\n                >\n                  <option value=\"up\">up</option>\n                  <option value=\"down\">down</option>\n                </select>\n              </div>\n              <!--\n              <div>\n                <label>stickyOrbit</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiSticky.config.orbit\"\n                  (change)=\"apiSticky.config$.nextKeyValue('orbit', $event.target.checked)\"\n                >\n              </div>\n              -->\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                outputs\n              </div>\n              <div>\n                <label>stickyState</label>\n                {{ apiSticky.state }}\n              </div>\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                methods\n              </div>\n              <div>\n                <label>enableSticky</label>\n                <button (click)=\"apiSticky.enableSticky()\">call</button>\n              </div>\n              <div>\n                <label>disableSticky</label>\n                <button (click)=\"apiSticky.disableSticky()\">call</button>\n              </div>\n              <!--\n              <div>\n                <label>update</label>\n                <button (click)=\"apiSticky.update()\">call</button>\n              </div>\n              -->\n            </div>\n          </div>\n        </div>\n  \n        <div ngx-sticky-boundary class=\"preview\">\n          <div style=\"height: 15rem;\"></div>\n          <p #apiSticky=\"ngxSticky\" ngx-sticky>\n            I am sticky!\n          </p>\n          <div style=\"height: 15rem;\"></div>\n        </div>\n      </div>\n  \n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span *ngIf=\"apiSticky.disabled\" class=\"html-attr\"> stickyDisabled</span><!--<span *ngIf=\"apiSticky.config.orbit\" class=\"html-attr\"> stickyOrbit</span>--><ng-container *ngIf=\"apiSticky.config.position === 'bottom'\"><span class=\"html-attr\"> stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span></ng-container><ng-container *ngIf=\"apiSticky.config.direction === 'up'\"><span class=\"html-attr\"> stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span></ng-container><span class=\"html-tag\">&gt;</span>\n  I am sticky!\n<span class=\"html-tag\">&lt;/p&gt;</span></code></pre>\n    </div>\n\n    <div>\n      <h3>NgxStickyBoundaryDirective</h3>\n      <div class=\"sidepanes\">\n        <div class=\"controls\" ngx-sticky-boundary>\n          <div ngx-sticky [stickyDisabled]=\"_isSmallScreen\">\n            <div class=\"controls-header\">\n              ngx-sticky-boundary\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                inputs\n              </div>\n              <div>\n                <label>stickyUnstacked</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiBoundary.config.unstacked\"\n                  (change)=\"apiBoundary.config$.nextKeyValue('unstacked', $event.target.checked)\"\n                >\n              </div>\n            </div>\n            <!--\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                methods\n              </div>\n              <div>\n                <label>updateStickies</label>\n                <button (click)=\"apiBoundary.updateStickies()\">call</button>\n              </div>\n            </div>\n            -->\n            <div class=\"controls-header\">\n              ngx-sticky\n            </div>\n            <div class=\"controls-group\">\n              <div>\n                <label>stickyDisabled</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiBoundaryStickyDisabled\"\n                  (change)=\"apiBoundaryStickyDisabled = !apiBoundaryStickyDisabled\"\n                >\n              </div>\n              <div>\n                <label>stickyPosition</label>\n                <select\n                  [value]=\"apiBoundaryStickyPosition\"\n                  (change)=\"apiBoundaryStickyPosition = $event.target.value\"\n                >\n                  <option value=\"top\">top</option>\n                  <option value=\"bottom\">bottom</option>\n                </select>\n              </div>\n              <div>\n                <label>stickyDirection</label>\n                <select\n                  [value]=\"apiBoundaryStickyDirection\"\n                  (change)=\"apiBoundaryStickyDirection = $event.target.value\"\n                >\n                  <option value=\"up\">up</option>\n                  <option value=\"down\">down</option>\n                </select>\n              </div>\n              <!--\n              <div>\n                <label>stickyOrbit</label>\n                <input type=\"checkbox\"\n                  [checked]=\"stickyOrbit\"\n                  (change)=\"stickyOrbit = !stickyOrbit\"\n                >\n              </div>\n              -->\n            </div>\n          </div>\n        </div>\n  \n        <div class=\"preview\">\n          <div style=\"height: 5rem;\"></div>\n          <div #apiBoundary=\"ngxStickyBoundary\" ngx-sticky-boundary>\n            <div style=\"height: 10rem;\"></div>\n            <p ngx-sticky\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\n            >\n              Sticky 1\n            </p>\n            <div style=\"height: 5rem\"></div>\n            <p ngx-sticky\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\n            >\n              Sticky 2\n            </p>\n            <div style=\"height: 5rem\"></div>\n            <p ngx-sticky\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\n            >\n              Sticky 3\n            </p>\n            <div style=\"height: 10rem;\"></div>\n          </div>\n          <div style=\"height: 5rem;\"></div>\n        </div>\n      </div>\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span *ngIf=\"apiBoundary.config.unstacked\" class=\"html-attr\"> stickyUnstacked</span><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n    </div>\n\n    <div>\n      <h3>NgxStickyContainerDirective</h3>\n      <div class=\"sidepanes\">\n        <div class=\"controls\">\n          <div>\n            <div class=\"controls-header\">\n              ngx-sticky-container\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                inputs\n              </div>\n              <div>\n                <label>stickyDisabled</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiContainer.disabled\"\n                  (change)=\"apiContainer.config$.nextKeyValue('disabled', $event.target.checked)\"\n                >\n              </div>\n              <div>\n                <label>stickyOffsetTop</label>\n                <input type=\"number\"\n                  [value]=\"apiContainerStickyOffsetTop\"\n                  (change)=\"apiContainerStickyOffsetTop = +$event.target.value\"\n                >\n              </div>\n              <div>\n                <label>stickyOffsetBottom</label>\n                <input type=\"number\"\n                  [value]=\"apiContainerStickyOffsetBottom\"\n                  (change)=\"apiContainerStickyOffsetBottom = +$event.target.value\"\n                >\n              </div>\n              <div>\n                <label>stickyUnstacked</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiContainer.config.unstacked\"\n                  (change)=\"apiContainer.config$.nextKeyValue('unstacked', $event.target.checked)\"\n                >\n              </div>\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                methods\n              </div>\n              <div>\n                <label>enableStickies</label>\n                <button (click)=\"apiContainer.enableStickies()\">call</button>\n              </div>\n              <div>\n                <label>disableStickies</label>\n                <button (click)=\"apiContainer.disableStickies()\">call</button>\n              </div>\n              <div>\n                <label>scrollToTop</label>\n                <button (click)=\"apiContainer.scrollToTop('#apiContainerScrollTarget')\">call</button>\n              </div>\n              <!--\n              <div>\n                <label>updateStickies</label>\n                <button (click)=\"apiContainer.updateStickies()\">call</button>\n              </div>\n              -->\n            </div>\n            <div class=\"controls-header\">\n              ngx-sticky\n            </div>\n            <div class=\"controls-group\">\n              <div>\n                <label>stickyDisabled</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiContainerStickyDisabled\"\n                  (change)=\"apiContainerStickyDisabled = !apiContainerStickyDisabled\"\n                >\n              </div>\n              <div>\n                <label>stickyPosition</label>\n                <select\n                  [value]=\"apiContainerStickyPosition\"\n                  (change)=\"apiContainerStickyPosition = $event.target.value\"\n                >\n                  <option value=\"top\">top</option>\n                  <option value=\"bottom\">bottom</option>\n                </select>\n              </div>\n              <div>\n                <label>stickyDirection</label>\n                <select\n                  [value]=\"apiContainerStickyDirection\"\n                  (change)=\"apiContainerStickyDirection = $event.target.value\"\n                >\n                  <option value=\"up\">up</option>\n                  <option value=\"down\">down</option>\n                </select>\n              </div>\n              <!--\n              <div>\n                <label>stickyOrbit</label>\n                <input type=\"checkbox\"\n                  [checked]=\"stickyOrbit\"\n                  (change)=\"stickyOrbit = !stickyOrbit\"\n                >\n              </div>\n              -->\n            </div>\n          </div>\n        </div>\n  \n        <div #apiContainer=\"ngxStickyContainer\" ngx-sticky-container\n          [stickyOffsetTop]=\"apiContainerStickyOffsetTop\"\n          [stickyOffsetBottom]=\"apiContainerStickyOffsetBottom\"\n          class=\"preview\"\n          style=\"position: relative; height: 40rem; overflow: auto;\"\n        >\n          <header ngx-sticky>\n            Header\n          </header>\n          <div style=\"height: 30rem;\"></div>\n          <p ngx-sticky\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\n            [stickyPosition]=\"apiContainerStickyPosition\"\n            [stickyDirection]=\"apiContainerStickyDirection\"\n          >\n            Sticky 1\n          </p>\n          <div style=\"height: 5rem;\"></div>\n          <p ngx-sticky\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\n            [stickyPosition]=\"apiContainerStickyPosition\"\n            [stickyDirection]=\"apiContainerStickyDirection\"\n          >\n            Sticky 2\n          </p>\n          <div style=\"height: 5rem;\"></div>\n          <p ngx-sticky\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\n            [stickyPosition]=\"apiContainerStickyPosition\"\n            [stickyDirection]=\"apiContainerStickyDirection\"\n          >\n            Sticky 3\n          </p>\n          <div style=\"height: 5rem;\"></div>\n          <p id=\"apiContainerScrollTarget\" style=\"background: lightblue; opacity: 1;\">Scroll target</p>\n          <div style=\"height: 40rem;\"></div>\n          <footer ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">\n            Footer\n          </footer>\n        </div>\n      </div>\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-container</span><span *ngIf=\"apiContainer.disabled\" class=\"html-attr\"> stickyDisabled</span><span *ngIf=\"apiContainer.config.unstacked\" class=\"html-attr\"> stickyUnstacked</span><ng-container *ngIf=\"apiContainerStickyOffsetTop\" ><span class=\"html-attr\"> stickyOffsetTop</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiContainerStickyOffsetTop }}</span><span class=\"html-sign\">&quot;</span></ng-container><ng-container *ngIf=\"apiContainerStickyOffsetBottom\"><span class=\"html-attr\"> stickyOffsetBottom</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiContainerStickyOffsetBottom }}</span><span class=\"html-sign\">&quot;</span></ng-container><span class=\"html-tag\">&gt;</span>\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\n    Header\n  <span class=\"html-tag\">&lt;/header&gt;</span>\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\n  <span class=\"html-tag\">&lt;footer</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span> <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n    Footer\n  <span class=\"html-tag\">&lt;/footer&gt;</span>\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n    </div>\n\n    <div>\n      <h3>NgxInViewportDirective</h3>\n      <div class=\"sidepanes\">\n        <div class=\"controls\">\n          <div>\n            <div class=\"controls-header\">\n              ngx-in-viewport\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                inputs\n              </div>\n              <div>\n                <label>intersectionDisabled</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiInViewport.disabled\"\n                  (change)=\"apiInViewport.config$.nextKeyValue('disabled', $event.target.checked)\"\n                >\n              </div>\n              <div>\n                <label>intersectionThresholds</label>\n                <input type=\"text\"\n                  [value]=\"apiInViewport.config.thresholds.join(',')\"\n                  (change)=\"apiInViewport.config$.nextKeyValue('thresholds', $event.target.value)\"\n                >\n              </div>\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                methods\n              </div>\n              <div>\n                <label>enableIntersection</label>\n                <button (click)=\"apiInViewport.enableIntersection()\">call</button>\n              </div>\n              <div>\n                <label>disableIntersection</label>\n                <button (click)=\"apiInViewport.disableIntersection()\">call</button>\n              </div>\n              <!--\n              <div>\n                <label>update</label>\n                <button (click)=\"apiInViewport.update()\">call</button>\n              </div>\n              -->\n            </div>\n            <div class=\"controls-group\">\n              <div class=\"controls-group-header\">\n                outputs\n              </div>\n              <div>\n                <label>intersectionState</label>\n                {{ apiInViewport.state || 'null' }}\n              </div>\n              <div>\n                <label>intersectionThreshold</label>\n                {{ apiInViewport._intersectionThreshold }}\n              </div>\n              <!--\n              <div>\n                <label>intersectionComputation</label>\n                <pre class=\"code\" style=\"margin: 0\"><code>{{ getIntersectionComputationAsText() }}</code></pre>\n              </div>\n              -->\n            </div>\n            <div class=\"controls-header\">\n              ngx-sticky\n            </div>\n            <div class=\"controls-group\">\n              <div>\n                <label>stickyDisabled</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiInViewportStickyDisabled\"\n                  (change)=\"apiInViewportStickyDisabled = !apiInViewportStickyDisabled\"\n                >\n              </div>\n              <div>\n                <label>stickyPosition</label>\n                <select\n                  [value]=\"apiInViewportStickyPosition\"\n                  (change)=\"apiInViewportStickyPosition = $event.target.value\"\n                >\n                  <option value=\"top\">top</option>\n                  <option value=\"bottom\">bottom</option>\n                </select>\n              </div>\n              <div>\n                <label>stickyDirection</label>\n                <select\n                  [value]=\"apiInViewportStickyDirection\"\n                  (change)=\"apiInViewportStickyDirection = $event.target.value\"\n                >\n                  <option value=\"up\">up</option>\n                  <option value=\"down\">down</option>\n                </select>\n              </div>\n              <!--\n              <div>\n                <label>stickyOrbit</label>\n                <input type=\"checkbox\"\n                  [checked]=\"apiInViewportStickyOrbit\"\n                  (change)=\"apiInViewportStickyOrbit = !apiInViewportStickyOrbit\"\n                >\n              </div>\n              -->\n            </div>\n          </div>\n        </div>\n  \n        <div #container=\"ngxStickyContainer\" ngx-sticky-container class=\"preview\" style=\"position: relative; height: 40rem; overflow: auto;\">\n          <header ngx-sticky>\n            Header\n          </header>\n          <div style=\"height: 30rem;\"></div>\n          <p ngx-sticky\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\n            [stickyPosition]=\"apiInViewportStickyPosition\"\n            [stickyDirection]=\"apiInViewportStickyDirection\"\n          >\n            Sticky 1\n          </p>\n          <div style=\"height: 5rem;\"></div>\n          <p ngx-sticky\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\n            [stickyPosition]=\"apiInViewportStickyPosition\"\n            [stickyDirection]=\"apiInViewportStickyDirection\"\n          >\n            Sticky 2\n          </p>\n          <div style=\"height: 5rem;\"></div>\n          <p #apiInViewport=\"ngxInViewport\" ngx-in-viewport style=\"opacity: 1; padding: 8rem 1rem; background: lightblue; text-align: center\">\n            In viewport element\n          </p>\n          <div style=\"height: 5rem;\"></div>\n          <p ngx-sticky\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\n            [stickyPosition]=\"apiInViewportStickyPosition\"\n            [stickyDirection]=\"apiInViewportStickyDirection\"\n          >\n            Sticky 3\n          </p>\n          <div style=\"height: 40rem;\"></div>\n          <footer ngx-sticky\n            stickyPosition=\"bottom\"\n            stickyDirection=\"up\"\n            style=\"margin-bottom: 0;\"\n          >\n            Footer\n          </footer>\n        </div>\n      </div>\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-in-viewport</span><span *ngIf=\"apiInViewport.disabled\" class=\"html-attr\"> intersectionDisabled</span><span class=\"html-attr\"> intersectionThresholds</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiInViewport.config.thresholds.join(',') }}</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\n  in viewport element\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\n    </div>\n  </div>\n</section>\n\n<footer class=\"footer\">\n  <p class=\"container\">made with ☕ by <a href=\"http://enten.fr\">enten</a></p>\n</footer>\n  \n  ","import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { NgxStickyModule } from '../../projects/ngx-sticky/src/public-api';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n\n\n@NgModule({\n  declarations: [\n    AppComponent,\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    NgxStickyModule,\n  ],\n  providers: [],\n  bootstrap: [ AppComponent ],\n})\nexport class AppModule { }\n","export const environment = {\n  production: true,\n};\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n"],"x_google_ignoreList":[]}