{"version":3,"mappings":"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","names":["a","t","C","e","y","c","n","m","r","u","i","exports","disabled","aliasKey","defaultValue","coercion","coercion_1","thresholds","intersection_1","constructor","rootContainer","stickyContainer","elementRef","ngZone","_win","this","core_1","config_subject_1","rxjs_1","_container","container","registerIntersection","config$","getValue","config","_intersectionState","ngOnChanges","changes","nextChanges","ngAfterViewInit","_initMonitoring","ngOnDestroy","unregisterIntersection","_destroyed$","isStopped","next","complete","_destroyMonitoring","beforeRefresh","fastUpdate","_intersection","disableIntersection","nextKeyValue","skipCoercion","enableIntersection","getIntersection","_computeIntersection","refresh","computation","_refresh$","update","updateStickies","elementRect","dom_1","nativeElement","height","top","_createMonitoringObservable","pipe","operators_1","_monitoring","unsubscribe","runOutsideAngular","handleRefreshSubscription","leading","trailing","subscribe","_refreshIntersection","triggerUpdateSubscription","add","_intersectionComputation","intersectionComputation","state","run","intersectionState","oldEntry","_intersectionCrossed","newEntry","oldRatio","ratio","newRatio","crossedThreshold","snap","intersection","isNaN","_intersectionThreshold","intersectionThreshold","emit","NgxInViewportDirective","i0","sticky_container_directive_1","sticky_tokens_1","selectors","disableAllStickies","disableStickies","containers","enableAllStickies","enableStickies","getStickedOffset","position","viewportTop","getContainer","viewportHeight","getViewportHeight","stickies","stickyController","push","getSticky","stickyEngine","fixViewportTop","userOffsetTop","viewportTopOffsetless","viewportTopFixed","containerParent","registerContainer","containerController","collections_1","registerBoundary","boundaryController","boundaries","intersectionController","intersectionIndex","intersections","_intersectionSnaps","_intersectionComputations","registerSticky","stickyIndex","_stickySnaps","_stickyComputations","updateAllStickies","length","getViewportTop","stickyComputation","stickySnap","_stickyController","snapSticky","determineStickyState","intersectionSnap","snapIntersection","determineIntersectionState","unregisterContainer","unregisterBoundary","boundary","unregisterSticky","sticky","offsetTop","offsetBottom","unstacked","sticky_base_container_controller_1","super","_getDocumentHeight","_getDocumentWidth","destroyed$","createScrollPlan","target","scrollPlan","scrollToFn","element","scrollTo","bind","targetContainer","targetContainerScrollPlan","containsElement","elementAsNumber","parseFloat","querySelector","document","elementTop","scrollToOptions","left","getViewportLeft","tagName","contains","containerScrollPlan","targetLine","targetTopFixed","_computeContainer","scrollToTop","scrollStep","_updateStickies$","containerRect","scrollHeight","width","scrollWidth","_createMonitoringInputsObservable","_createMonitoringScrollObservable","_createMonitoringWindowObservable","passive","_updateStickies","NgxStickyBaseContainerDirective","inputs","sticky_base_boundary_controller_1","ngOnInit","_boundary","getBoundary","_computeBoundary","boundaryStyle","getComputedStyle","paddingTop","paddingBottom","NgxStickyBoundaryDirective","sticky_base_container_directive_1","stickyContainerParent","offsetHeight","scrollLeft","scrollTop","NgxStickyContainerDirective","computeStickyBoundary","directionDown","spot","boundaryHeight","boundaryTop","boundaryLeft","boundaryWidth","spotPoint","computeStickyStickedLine","positionBottom","stickedTop","stickedHeight","computeStickySortPoint","sortPoint","enter","exit","stateKey","join","maxHeightVisible","Math","min","offsetSticked","intersecting","S","offsetStucked","stickyComputed","_stickyComputedState","_stickyComputed","boundaryOffset","_stickedTop","_stickedHeight","sticked","sticky_helpers_1","maxStickyUnstackedHeight","stickedOffset","_sticky","_elementHeight","exitSticky","direction","boundariesMap","stickiesComputed","offsetSpacer","stickyComputedBoundaryRight","_stickyIndex","_directionDown","_positionBottom","_stickyComputedBoundaryRight","p","boundaryKey","l","f","sort","b","NgxStickyEngine","factory","NgxStickyRootContainerController","_stickySpotHeight","value","utils_1","NgxStickySpotDirective","s","d","classes","spacer","spotHeight","sticky_base_controller_1","stickyBoundary","stickyParent","renderer","cssClassSticky","cssClassStickySticked","cssClassStickyStucked","cssClassStickyDisabled","_stickyState","_preventNestedStickyError","disableSticky","enableSticky","_computeSticky","_refreshStickyElement","spotRect","from_image_events_1","_getStickyElementStyle","win","ghost","_spacerGenerated","ghostParent","offsetParent","ghostParentIsRootElement","body","documentElement","ghostRelativeRect","ghostStyle","elementWidth","boxSizing","borderLeft","borderRight","paddingLeft","paddingRight","elementLeft","ghostRect","offsetLeft","right","bottom","float","margin","ghostParentRect","_getStickyGhostStyle","elementStyle","ghostHeight","borderTopWidth","borderBottomWidth","style","maxHeight","minHeight","borderTop","borderBottom","cssFloat","marginTop","marginBottom","marginLeft","marginRight","_hideStickyGhost","setStyle","_refreshSticky","_insertStickyGhostGenerated","createElement","addClass","insertBefore","parentElement","nestedStickyError","Error","logLevel","logLevelLogger","console","_stickyElementState","_stickyComputation","stickyState","_restoreStickyElementStyle","_saveStickyElementStyle","_showStickyGhost","_refreshStickyGhost","_elementOriginStyle","remove","display","NgxStickyDirective","sticky_boundary_directive_1","isStickyPositionBottom","isStickyDirectionDown","elementHeight","NgxStickyModule","common_1","providedIn","window","Number","fallbackValue","_isNumberValue","set","entry","entryIndex","indexOf","splice","schema","_config","_configChanges","_aliases","inputKeys","Object","keys","inputKey","inputOptions","input","input_subject_1","pushChangeSubscription","change$","inputChange","_configChanged","currentValue","_pushChangesSubscription","getKeyValue","partialConfig","options","key","changes$","changeKeys","documentHeightGetters","clientHeight","documentHeightGetter","documentHeight","_documentHeightGetter","_documentHeight","documentWidthGetters","offsetWidth","clientWidth","documentWidthGetter","documentWidth","_documentWidthGetter","_documentWidth","rect","currentElement","currentElementStyle","innerHeight","documentRect","getBoundingClientRect","scrollX","scrollY","overflowY","styles","propKeys","prop","removeStyle","images$","addImage","event","querySelectorAll","forEach","query","matchMedia","mql","initEvent","matches","media","initMqlEvent","MediaQueryListEvent","type","mql$","onQueryChange","mqlEvent","call","removeListener","addListener","tslib_1","_value","_valueSetted","firstChange","_firstChange","previousValue","split","map","x","Array","isArray","threshold","AppRoutingModule","router_1","forRoot","changeDetectorRef","smallBreakpoint$","public_api_1","_smallBreakpointSubscription","_isSmallScreen","AppComponent","_r0","$event","_r1","_r2","ctx","_r5","_r7","_r11","_r13","_r19","AppModule","bootstrap","app_component_1","imports","platform_browser_1","app_routing_module_1","production","environment_1","__NgCli_bootstrap_1","bootstrapModule","app_module_1","catch","err","error"],"sources":["webpack:///$_lazy_route_resources|lazy|groupOptions:%20%7B%7D|namespace%20object","webpack:///projects/ngx-sticky/src/lib/in-viewport.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base-boundary.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base-container.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base-container.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-boundary.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-container.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-engine.ts","webpack:///projects/ngx-sticky/src/lib/sticky-root-container.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-spot.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky.helpers.ts","webpack:///projects/ngx-sticky/src/lib/sticky.module.ts","webpack:///projects/ngx-sticky/src/lib/sticky.tokens.ts","webpack:///projects/ngx-sticky/src/lib/utils/coercion.ts","webpack:///projects/ngx-sticky/src/lib/utils/collections.ts","webpack:///projects/ngx-sticky/src/lib/utils/config-subject.ts","webpack:///projects/ngx-sticky/src/lib/utils/dom.ts","webpack:///projects/ngx-sticky/src/lib/utils/from-image-events.ts","webpack:///projects/ngx-sticky/src/lib/utils/from-media-query.ts","webpack:///projects/ngx-sticky/src/lib/utils/index.ts","webpack:///projects/ngx-sticky/src/lib/utils/input-subject.ts","webpack:///projects/ngx-sticky/src/lib/utils/intersection.ts","webpack:///projects/ngx-sticky/src/public-api.ts","webpack:///src/app/app-routing.module.ts","webpack:///src/app/app.component.ts","webpack:///src/app/app.component.html","webpack:///src/app/app.module.ts","webpack:///src/environments/environment.prod.ts","webpack:///src/main.ts"],"sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 8255;\nmodule.exports = webpackEmptyAsyncContext;","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnChanges,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  SimpleChanges,\r\n  forwardRef,\r\n} from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\r\nimport { distinctUntilChanged, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport {\r\n  NgxIntersection,\r\n  NgxIntersectionComputation,\r\n  NgxIntersectionController,\r\n  NgxIntersectionState,\r\n  NgxStickyContainerController,\r\n} from './sticky.types';\r\nimport { coerceBooleanProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport { getElementAbsoluteRect } from './utils/dom';\r\nimport { coerceIntersectionThresholds, getCrossedThreshold } from './utils/intersection';\r\n\r\n\r\nexport interface NgxIntersectionConfig {\r\n  disabled: boolean;\r\n  thresholds: number[];\r\n}\r\n\r\n\r\nexport const NGX_BASE_INTERSECTION_CONFIG_SCHEMA: ConfigSubjectSchema<NgxIntersectionConfig> = {\r\n  disabled: {\r\n    aliasKey: 'intersectionDisabled',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  thresholds: {\r\n    aliasKey: 'intersectionThresholds',\r\n    defaultValue: [ 0, 1 ],\r\n    coercion: coerceIntersectionThresholds,\r\n  },\r\n};\r\n\r\n\r\n@Directive({\r\n  selector: '[ngxInViewport], [ngx-in-viewport], ngx-in-viewport',\r\n  exportAs: 'ngxInViewport',\r\n})\r\nexport class NgxInViewportDirective implements NgxIntersectionController, AfterViewInit, OnChanges, OnDestroy {\r\n  /**\r\n   * Disable intersection.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  intersectionDisabled: boolean;\r\n\r\n  /**\r\n   * Intersection thresholds.\r\n   *\r\n   * Defaults to `[ 0, 1 ]`.\r\n   */\r\n  @Input()\r\n  intersectionThresholds: number[];\r\n\r\n  /**\r\n   * Emit intersection.\r\n   */\r\n  @Output()\r\n  readonly intersection = new EventEmitter<NgxIntersectionComputation>();\r\n\r\n  /**\r\n   * Emit intersection computation.\r\n   */\r\n  @Output()\r\n  readonly intersectionComputation = new EventEmitter<NgxIntersectionComputation>();\r\n\r\n  /**\r\n   * Emit intersection state.\r\n   */\r\n  @Output()\r\n  readonly intersectionState = new EventEmitter<NgxIntersectionState>();\r\n\r\n  /**\r\n   * Emit intersection threshold.\r\n   */\r\n  @Output()\r\n  readonly intersectionThreshold = new EventEmitter<number>();\r\n\r\n  get container(): NgxStickyContainerController {\r\n    return this._container;\r\n  }\r\n\r\n  get config(): NgxIntersectionConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.config.disabled;\r\n  }\r\n\r\n  /**\r\n   * State of the intersection.\r\n   */\r\n  get state(): NgxIntersectionState {\r\n    return this._intersectionState;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject<NgxIntersectionConfig>(NGX_BASE_INTERSECTION_CONFIG_SCHEMA);\r\n\r\n  /** Intersection container controller */\r\n  readonly _container: NgxStickyBaseContainerDirective;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  readonly _destroyed$ = new Subject<void>();\r\n\r\n  /** Intersection which reflect last call of _computeIntersection() */\r\n  _intersection: NgxIntersection;\r\n\r\n  /** Intersection computation which reflect last call of _refreshIntersection()  */\r\n  _intersectionComputation: NgxIntersectionComputation;\r\n\r\n  /** Intersection computation with last threshold crossed */\r\n  _intersectionCrossed: NgxIntersectionComputation;\r\n\r\n  /** Last inetersection state crossed */\r\n  _intersectionState: NgxIntersectionState;\r\n\r\n  /** Last inetersection threshold crossed */\r\n  _intersectionThreshold: number;\r\n\r\n  /** Monitoring subscription which trigger update stickies and handle refresh */\r\n  _monitoring: Subscription;\r\n\r\n  /** Emits when refresh() is called */\r\n  readonly _refresh$ = new Subject<NgxIntersectionComputation>();\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainer: NgxStickyContainerDirective,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    // use root container when sticky isn't in container\r\n    this._container = stickyContainer || rootContainer;\r\n\r\n    // register in parent container for first update calls\r\n    this.container.registerIntersection(this);\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    this._initMonitoring();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.container.unregisterIntersection(this);\r\n\r\n    if (!this._destroyed$.isStopped) {\r\n      this._destroyed$.next();\r\n      this._destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._intersection = null;\r\n    }\r\n  }\r\n\r\n  disableIntersection(): void {\r\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\r\n  }\r\n\r\n  enableIntersection(): void {\r\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\r\n  }\r\n\r\n  getIntersection(): NgxIntersection {\r\n    if (!this._intersection) {\r\n      this._intersection = this._computeIntersection();\r\n    }\r\n\r\n    return this._intersection;\r\n  }\r\n\r\n  refresh(computation: NgxIntersectionComputation): void {\r\n    this._refresh$.next(computation);\r\n  }\r\n\r\n  update(fastUpdate?: boolean): void {\r\n    this.container.updateStickies(fastUpdate);\r\n  }\r\n\r\n  _computeIntersection(): NgxIntersection {\r\n    const config = this.config$.getValue();\r\n\r\n    const elementRect = getElementAbsoluteRect(this.elementRef.nativeElement);\r\n\r\n    return {\r\n      disabled: config.disabled,\r\n      height: elementRect.height,\r\n      top: elementRect.top,\r\n      thresholds: config.thresholds,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create intersection monitoring observable.\r\n   */\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    return merge(\r\n      this.config$,\r\n      animationFrameScheduler,\r\n    ).pipe(\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy intersection monitoring subscription.\r\n   */\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Init intersection monitoring.\r\n   */\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      const handleRefreshSubscription = this._refresh$\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          distinctUntilChanged(),\r\n          throttleTime(0, animationFrameScheduler, { leading: true, trailing: true }),\r\n          share(),\r\n        )\r\n        .subscribe(computation => {\r\n          this._refreshIntersection(computation);\r\n        });\r\n\r\n      const triggerUpdateSubscription = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this.update(fastUpdate);\r\n        });\r\n\r\n      this._monitoring = new Subscription();\r\n      this._monitoring.add(handleRefreshSubscription);\r\n      this._monitoring.add(triggerUpdateSubscription);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refresh intersection with given computation.\r\n   *\r\n   * @param computation Intersection state computation\r\n   */\r\n  _refreshIntersection(computation: NgxIntersectionComputation): void {\r\n    this._intersectionComputation = computation;\r\n    this.intersectionComputation.next(computation);\r\n\r\n    if (computation.state !== this._intersectionState) {\r\n      this.ngZone.run(() => {\r\n        this._intersectionState = computation.state;\r\n        this.intersectionState.next(computation.state);\r\n      });\r\n    }\r\n\r\n    const oldEntry = this._intersectionCrossed;\r\n    const newEntry = computation;\r\n\r\n    const oldRatio = oldEntry ? oldEntry.ratio : 0;\r\n    const newRatio = newEntry.ratio;\r\n\r\n    // ignore when ratios are unchanged\r\n    if (oldEntry && oldRatio === newRatio) {\r\n      return;\r\n    }\r\n\r\n    const crossedThreshold = getCrossedThreshold(computation.snap.intersection.thresholds, oldRatio, newRatio);\r\n\r\n    // ignore when no treshold is crossed\r\n    if (isNaN(crossedThreshold)) {\r\n      return;\r\n    }\r\n\r\n    this._intersectionCrossed = newEntry;\r\n\r\n    this.ngZone.run(() => {\r\n      this._intersectionThreshold = crossedThreshold;\r\n      this.intersectionThreshold.next(crossedThreshold);\r\n\r\n      this.intersection.emit(newEntry);\r\n    });\r\n  }\r\n}\r\n","import {\r\n  NgxStickyBoundary,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyContainerController,\r\n} from './sticky.types';\r\n\r\n\r\n/**\r\n * Abstract sticky boundary controller.\r\n */\r\nexport abstract class NgxStickyBaseBoundaryController implements NgxStickyBoundaryController {\r\n  abstract readonly container: NgxStickyContainerController;\r\n\r\n  abstract beforeRefresh(fastUpdate?: boolean): void;\r\n  abstract getBoundary(): NgxStickyBoundary;\r\n\r\n  updateStickies(fastUpdate?: boolean) {\r\n    this.container.updateStickies(fastUpdate);\r\n  }\r\n}\r\n","import { NgxStickyEngine } from './sticky-engine';\r\nimport {\r\n  NgxIntersectionComputation,\r\n  NgxIntersectionController,\r\n  NgxIntersectionSnap,\r\n  NgxScrollPlan,\r\n  NgxSticky,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyComputation,\r\n  NgxStickyContainer,\r\n  NgxStickyContainerController,\r\n  NgxStickyController,\r\n  NgxStickyPosition,\r\n  NgxStickySnap,\r\n} from './sticky.types';\r\nimport { addEntry, deleteEntry } from './utils/collections';\r\n\r\n\r\n/**\r\n * Abstract sticky container controller.\r\n */\r\nexport abstract class NgxStickyBaseContainerController implements NgxStickyContainerController {\r\n  abstract readonly containerParent?: NgxStickyContainerController;\r\n  abstract readonly stickyEngine: NgxStickyEngine;\r\n\r\n  abstract disabled: boolean;\r\n\r\n  readonly boundaries: NgxStickyBoundaryController[] = [];\r\n  readonly containers: NgxStickyContainerController[] = [];\r\n  readonly intersections: NgxIntersectionController[] = [];\r\n  readonly stickies: NgxStickyController[] = [];\r\n\r\n  readonly _stickyComputations: Record<number, NgxStickyComputation> = {};\r\n  readonly _stickySnaps: Record<number, NgxStickySnap> = {};\r\n  _stickySnapContainerHeight: number;\r\n\r\n  readonly _intersectionComputations: Record<number, NgxIntersectionComputation> = {};\r\n  readonly _intersectionSnaps: Record<number, NgxIntersectionSnap> = {};\r\n\r\n  abstract beforeRefresh(fastUpdate?: boolean): void;\r\n  abstract createScrollPlan(element: number | string | HTMLElement, userOffsetTop?: number): NgxScrollPlan;\r\n  abstract disableStickies(): void;\r\n  abstract enableStickies(): void;\r\n  abstract getContainer(): NgxStickyContainer;\r\n  abstract getViewportHeight(): number;\r\n  abstract getViewportLeft(): number;\r\n  abstract getViewportTop(): number;\r\n  abstract scrollToTop(target: number | string | HTMLElement, userOffsetTop?: number): void;\r\n\r\n  abstract _computeContainer(): NgxStickyContainer;\r\n\r\n  disableAllStickies(): void {\r\n    this.disableStickies();\r\n\r\n    for (const container of this.containers) {\r\n      container.disableStickies();\r\n    }\r\n  }\r\n\r\n  enableAllStickies(): void {\r\n    this.enableStickies();\r\n\r\n    for (const container of this.containers) {\r\n      container.enableStickies();\r\n    }\r\n  }\r\n\r\n  getStickedOffset(position: NgxStickyPosition, viewportTop: number): number {\r\n    const container = this.getContainer();\r\n    const viewportHeight = this.getViewportHeight();\r\n    const stickies: NgxSticky[] = [];\r\n\r\n    for (const stickyController of this.stickies) {\r\n      stickies.push(stickyController.getSticky());\r\n    }\r\n\r\n    return this.stickyEngine.getStickedOffset(container, stickies, position, viewportHeight, viewportTop);\r\n  }\r\n\r\n  fixViewportTop(viewportTop: number, userOffsetTop?: number): number {\r\n    // const container = this.getContainer();\r\n    const viewportTopOffsetless = viewportTop - (userOffsetTop || 0);\r\n    const stickedOffsetTop = this.getStickedOffset('top', viewportTopOffsetless);\r\n\r\n    let viewportTopFixed = viewportTopOffsetless /* - container.offsetTop*/ - stickedOffsetTop;\r\n\r\n    if (this.containerParent) {\r\n      viewportTopFixed -= this.getContainer().top;\r\n    }\r\n\r\n    return viewportTopFixed;\r\n  }\r\n\r\n  registerContainer(containerController: NgxStickyContainerController): void {\r\n    addEntry(this.containers, containerController);\r\n  }\r\n\r\n  registerBoundary(boundaryController: NgxStickyBoundaryController): void {\r\n    addEntry(this.boundaries, boundaryController);\r\n  }\r\n\r\n  registerIntersection(intersectionController: NgxIntersectionController): void {\r\n    const intersectionIndex = addEntry(this.intersections, intersectionController);\r\n\r\n    if (intersectionIndex !== -1) {\r\n      this._intersectionSnaps[intersectionIndex] = null;\r\n      this._intersectionComputations[intersectionIndex] = null;\r\n    }\r\n  }\r\n\r\n  registerSticky(stickyController: NgxStickyController): void {\r\n    const stickyIndex = addEntry(this.stickies, stickyController);\r\n\r\n    if (stickyIndex !== -1) {\r\n      this._stickySnaps[stickyIndex] = null;\r\n      this._stickyComputations[stickyIndex] = null;\r\n    }\r\n  }\r\n\r\n  updateAllStickies(fastUpdate?: boolean): void {\r\n    this.updateStickies(fastUpdate);\r\n\r\n    for (const containerController of this.containers) {\r\n      containerController.updateAllStickies(fastUpdate);\r\n    }\r\n  }\r\n\r\n  updateStickies(fastUpdate?: boolean): void {\r\n    // // avoid update when there is no stickies\r\n    // if (!this.stickies.length) {\r\n    //   return;\r\n    // }\r\n\r\n    // // force full update when container size change\r\n    // if (this.getContainerHeight() !== this._stickySnapContainerHeight) {\r\n    //   fastUpdate = false;\r\n    // }\r\n\r\n    if (!fastUpdate) {\r\n      this.beforeRefresh(fastUpdate);\r\n\r\n      for (const boundaryController of this.boundaries) {\r\n        boundaryController.beforeRefresh(fastUpdate);\r\n      }\r\n\r\n      for (let stickyIndex = 0; stickyIndex < this.stickies.length; ++stickyIndex) {\r\n        this._stickyComputations[stickyIndex] = null;\r\n        this._stickySnaps[stickyIndex] = null;\r\n\r\n        this.stickies[stickyIndex].beforeRefresh(fastUpdate);\r\n      }\r\n\r\n      for (let intersectionIndex = 0; intersectionIndex < this.intersections.length; ++intersectionIndex) {\r\n        this._intersectionComputations[intersectionIndex] = null;\r\n        this._intersectionSnaps[intersectionIndex] = null;\r\n\r\n        this.intersections[intersectionIndex].beforeRefresh(fastUpdate);\r\n      }\r\n    }\r\n\r\n    //   // legacy code\r\n    //   const viewportHeight = this.getViewportHeight() - this.stickyOffsetTop - this.stickyOffsetBottom;\r\n    //   const viewportTop = this.getViewportTop() + this.getContainer().top + this.stickyOffsetTop;\r\n\r\n    const container = this.getContainer();\r\n    const viewportHeight = this.getViewportHeight();\r\n    // compute absolute viewport top\r\n    const viewportTop = this.getViewportTop() + this.getContainer().top;\r\n    let stickies: NgxSticky[];\r\n\r\n    // refresh stickies\r\n    for (let stickyIndex = 0; stickyIndex < this.stickies.length; ++stickyIndex) {\r\n      const stickyController = this.stickies[stickyIndex];\r\n      let stickyComputation = this._stickyComputations[stickyIndex];\r\n\r\n      if (!stickyComputation || stickyComputation.viewportTop !== viewportTop) {\r\n        let stickySnap = this._stickySnaps[stickyIndex];\r\n\r\n        if (!stickySnap) {\r\n          if (!stickies) {\r\n            stickies = [];\r\n            for (const _stickyController of this.stickies) {\r\n              stickies.push(_stickyController.getSticky());\r\n            }\r\n          }\r\n\r\n          stickySnap = this.stickyEngine.snapSticky(container, stickies, stickies[stickyIndex], viewportHeight);\r\n\r\n          this._stickySnaps[stickyIndex] = stickySnap;\r\n        }\r\n\r\n        stickyComputation = this.stickyEngine.determineStickyState(stickySnap, viewportTop);\r\n\r\n        this._stickyComputations[stickyIndex] = stickyComputation;\r\n      }\r\n\r\n      stickyController.refresh(stickyComputation);\r\n    }\r\n\r\n    // refresh intersections\r\n    for (let intersectionIndex = 0; intersectionIndex < this.intersections.length; ++intersectionIndex) {\r\n      const intersectionController = this.intersections[intersectionIndex];\r\n      let intersectionComputation = this._intersectionComputations[intersectionIndex];\r\n\r\n      if (!intersectionComputation || intersectionComputation.viewportTop !== viewportTop) {\r\n        let intersectionSnap = this._intersectionSnaps[intersectionIndex];\r\n\r\n        if (!intersectionSnap) {\r\n          if (!stickies) {\r\n            stickies = [];\r\n            for (const _stickyController of this.stickies) {\r\n              stickies.push(_stickyController.getSticky());\r\n            }\r\n          }\r\n\r\n          const intersection = intersectionController.getIntersection();\r\n\r\n          intersectionSnap = this.stickyEngine.snapIntersection(container, stickies, intersection, viewportHeight);\r\n\r\n          this._intersectionSnaps[intersectionIndex] = intersectionSnap;\r\n        }\r\n\r\n        intersectionComputation = this.stickyEngine.determineIntersectionState(intersectionSnap, viewportTop);\r\n\r\n        this._intersectionComputations[intersectionIndex] = intersectionComputation;\r\n      }\r\n\r\n      intersectionController.refresh(intersectionComputation);\r\n    }\r\n  }\r\n\r\n  unregisterContainer(container: NgxStickyContainerController): void {\r\n    deleteEntry(this.containers, container);\r\n  }\r\n\r\n  unregisterBoundary(boundary: NgxStickyBoundaryController): void {\r\n    deleteEntry(this.boundaries, boundary);\r\n  }\r\n\r\n  unregisterIntersection(intersectionController: NgxIntersectionController): void {\r\n    const intersectionIndex = deleteEntry(this.intersections, intersectionController);\r\n\r\n    if (intersectionIndex !== -1) {\r\n      this._intersectionSnaps[intersectionIndex] = null;\r\n      this._intersectionComputations[intersectionIndex] = null;\r\n    }\r\n  }\r\n\r\n  unregisterSticky(sticky: NgxStickyController): void {\r\n    const stickyIndex = deleteEntry(this.stickies, sticky);\r\n\r\n    if (stickyIndex !== -1) {\r\n      this._stickySnaps[stickyIndex] = null;\r\n      this._stickyComputations[stickyIndex] = null;\r\n    }\r\n  }\r\n}\r\n","import { Directive, Input, NgZone, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, fromEvent, merge, of } from 'rxjs';\r\nimport { debounceTime, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseContainerController } from './sticky-base-container.controller';\r\nimport { NgxStickyEngine } from './sticky-engine';\r\nimport { NgxScrollPlan, NgxStickyContainer, NgxStickyContainerController, NgxStickyController } from './sticky.types';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport {\r\n  getDocumentHeightFactory,\r\n  getDocumentWidthFactory,\r\n  getElementAbsoluteRect,\r\n  getWindowViewportHeight,\r\n  getWindowViewportLeft,\r\n  getWindowViewportTop,\r\n  isElementScrollableY,\r\n} from './utils/dom';\r\n\r\n\r\nexport interface NgxStickyContainerConfig {\r\n  disabled: boolean;\r\n  offsetTop: number;\r\n  offsetBottom: number;\r\n  unstacked: boolean;\r\n}\r\n\r\n\r\nexport const NGX_STICKY_BASE_CONTAINER_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyContainerConfig> = {\r\n  disabled: {\r\n    aliasKey: 'stickyDisabled',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  offsetTop: {\r\n    aliasKey: 'stickyOffsetTop',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n  offsetBottom: {\r\n    aliasKey: 'stickyOffsetBottom',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n  unstacked: {\r\n    aliasKey: 'stickyUnstacked',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n};\r\n\r\n\r\n/**\r\n * Abstract sticky container directive.\r\n */\r\n@Directive()\r\nexport abstract class NgxStickyBaseContainerDirective extends NgxStickyBaseContainerController implements OnChanges, OnDestroy {\r\n  /**\r\n   * Returns HTMLElement of the container or `null` in case of root container.\r\n   */\r\n  abstract readonly element: HTMLElement;\r\n\r\n  /**\r\n   * Disable sticky. container.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyDisabled: boolean;\r\n\r\n  /**\r\n   * Defines offset bottom inside the sticky container.\r\n   */\r\n  @Input()\r\n  stickyOffsetBottom: (element: HTMLElement) => number;\r\n\r\n  /**\r\n   * Defines offset top inside the sticky container.\r\n   */\r\n  @Input()\r\n  stickyOffsetTop: (element: HTMLElement) => number;\r\n\r\n  /**\r\n   * Enable/disable sticky stack inside container.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyUnstacked: boolean;\r\n\r\n  get config(): NgxStickyContainerConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.config.disabled;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject(NGX_STICKY_BASE_CONTAINER_CONFIG_SCHEMA);\r\n\r\n  /** Container which reflect last call of _computeContainer() */\r\n  _container: NgxStickyContainer;\r\n\r\n  /** Emits when the service is destroyed. */\r\n  readonly destroyed$ = new Subject<void>();\r\n\r\n  /** Monitoring subscription which trigger update stickies */\r\n  _monitoring: Subscription;\r\n\r\n  /** Emits when updateStickies() is called */\r\n  _updateStickies$ = new Subject<boolean>();\r\n\r\n  /** Getter for document height */\r\n  readonly _getDocumentHeight: () => number;\r\n  /** Getter for document width */\r\n  readonly _getDocumentWidth: () => number;\r\n\r\n  constructor(\r\n    readonly containerParent: NgxStickyContainerController,\r\n    readonly stickyEngine: NgxStickyEngine,\r\n    readonly ngZone: NgZone,\r\n    readonly _win: Window,\r\n  ) {\r\n    super();\r\n\r\n    if (this.containerParent) {\r\n      this.containerParent.registerContainer(this);\r\n    }\r\n\r\n    this._getDocumentHeight = getDocumentHeightFactory(this._win);\r\n    this._getDocumentWidth = getDocumentWidthFactory(this._win);\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    if (this.containerParent) {\r\n      this.containerParent.unregisterContainer(this);\r\n    }\r\n\r\n    if (!this.destroyed$.isStopped) {\r\n      this.destroyed$.next();\r\n      this.destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._container = null;\r\n    }\r\n  }\r\n\r\n  createScrollPlan(target: number | string | HTMLElement, userOffsetTop?: number): NgxScrollPlan {\r\n    const scrollPlan: NgxScrollPlan = [];\r\n\r\n    if (!this._win) {\r\n      return scrollPlan;\r\n    }\r\n\r\n    const scrollToFn = this.element\r\n      ? this.element.scrollTo.bind(this.element)\r\n      : this._win.scrollTo.bind(this._win);\r\n\r\n    let containsElement = false;\r\n\r\n    if (typeof target === 'string') {\r\n      const elementAsNumber = parseFloat(target as string);\r\n\r\n      if (!isNaN(elementAsNumber)) {\r\n        target = elementAsNumber;\r\n      } else {\r\n        if (this.element) {\r\n          target = this.element.querySelector<HTMLElement>(target);\r\n        } else {\r\n          target = this._win.document.querySelector<HTMLElement>(target);\r\n        }\r\n\r\n        if (target) {\r\n          containsElement = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof target === 'number' && !isNaN(target)) {\r\n      const elementTop = this.fixViewportTop(target, userOffsetTop);\r\n\r\n      scrollPlan.push({\r\n        scrollToOptions: { left: this.getViewportLeft(), top: elementTop },\r\n        scrollToFn,\r\n      });\r\n\r\n      return scrollPlan;\r\n    }\r\n\r\n    // if (!target || !(target instanceof HTMLElement)) {\r\n    if (!target || !((target as HTMLElement).tagName)) {\r\n      return scrollPlan;\r\n    }\r\n\r\n    containsElement = containsElement || !this.element || this.element.contains(target as HTMLElement);\r\n\r\n    if (!containsElement) {\r\n      return scrollPlan;\r\n    }\r\n\r\n    let targetContainer: NgxStickyBaseContainerDirective;\r\n    let targetContainerScrollPlan: NgxScrollPlan;\r\n\r\n    for (const containerController of (this.containers as NgxStickyBaseContainerDirective[])) {\r\n      const containerScrollPlan = containerController.createScrollPlan(target, userOffsetTop);\r\n\r\n      if (containerScrollPlan.length) {\r\n        targetContainerScrollPlan = containerScrollPlan;\r\n        targetContainer = containerController as NgxStickyBaseContainerDirective;\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    const containerScrollable = !this.element || isElementScrollableY(this._win, this.element);\r\n\r\n    if (containerScrollable) {\r\n      const targetLine = targetContainer\r\n        ? targetContainer.getContainer()\r\n        : getElementAbsoluteRect(target as HTMLElement);\r\n      const targetTopFixed = this.fixViewportTop(targetLine.top, userOffsetTop);\r\n\r\n      scrollPlan.push({\r\n        scrollToFn,\r\n        scrollToOptions: { left: this.getViewportLeft(), top: targetTopFixed },\r\n      });\r\n    }\r\n\r\n    if (targetContainerScrollPlan) {\r\n      scrollPlan.push(...targetContainerScrollPlan);\r\n    }\r\n\r\n    return scrollPlan;\r\n  }\r\n\r\n  disableStickies(): void {\r\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\r\n  }\r\n\r\n  enableStickies(): void {\r\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\r\n  }\r\n\r\n  getContainer(): NgxStickyContainer {\r\n    if (!this._container) {\r\n      this._container = this._computeContainer();\r\n    }\r\n\r\n    return this._container;\r\n  }\r\n\r\n  getViewportHeight(): number {\r\n    return getWindowViewportHeight(this._win);\r\n  }\r\n\r\n  getViewportLeft(): number {\r\n    return getWindowViewportLeft(this._win);\r\n  }\r\n\r\n  getViewportTop(): number {\r\n    return getWindowViewportTop(this._win);\r\n  }\r\n\r\n  registerSticky(sticky: NgxStickyController): void {\r\n    super.registerSticky(sticky);\r\n\r\n    if (this.stickies.length) {\r\n      this._initMonitoring();\r\n    }\r\n  }\r\n\r\n  unregisterSticky(sticky: NgxStickyController): void {\r\n    super.unregisterSticky(sticky);\r\n\r\n    if (!this.stickies.length) {\r\n      this._destroyMonitoring();\r\n    }\r\n  }\r\n\r\n  scrollToTop(target: number | string | HTMLElement, userOffsetTop?: number): void {\r\n    const scrollPlan = this.createScrollPlan(target, userOffsetTop);\r\n\r\n    for (const scrollStep of scrollPlan) {\r\n      scrollStep.scrollToFn(scrollStep.scrollToOptions);\r\n    }\r\n  }\r\n\r\n  updateStickies(fastUpdate?: boolean): void {\r\n    // intercept update stickies to throttle calls\r\n    this._updateStickies$.next(fastUpdate);\r\n  }\r\n\r\n  _computeContainer(): NgxStickyContainer {\r\n    const config = this.config$.getValue();\r\n\r\n    const containerRect = this.element ? getElementAbsoluteRect(this.element) : null;\r\n\r\n    return {\r\n      disabled: this.disabled,\r\n      height: containerRect ? this.element.scrollHeight : this._getDocumentHeight(),\r\n      left: containerRect ? containerRect.left : 0,\r\n      offsetBottom: config.offsetBottom,\r\n      offsetTop: config.offsetTop,\r\n      top: containerRect ? containerRect.top : 0,\r\n      unstacked: config.unstacked,\r\n      width: containerRect ? this.element.scrollWidth : this._getDocumentWidth(),\r\n    };\r\n  }\r\n\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    if (!this._win) {\r\n      return of();\r\n    }\r\n\r\n    return merge(\r\n      this._createMonitoringInputsObservable(),\r\n      this._createMonitoringScrollObservable(),\r\n      this._createMonitoringWindowObservable(),\r\n      this._updateStickies$,\r\n      animationFrameScheduler,\r\n    )/*.pipe(throttleTime(0, animationFrameScheduler))*/;\r\n  }\r\n\r\n  _createMonitoringInputsObservable(): Observable<boolean> {\r\n    return this.config$.pipe(\r\n      debounceTime(0),\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  _createMonitoringScrollObservable(): Observable<boolean> {\r\n    return fromEvent(this.element || this._win, 'scroll', { passive: true })\r\n      .pipe(\r\n        throttleTime(0, animationFrameScheduler),\r\n        mapTo(true),\r\n      );\r\n  }\r\n\r\n  _createMonitoringWindowObservable(): Observable<boolean> {\r\n    return merge(\r\n      fromEvent(this._win, 'load', { passive: true }),\r\n      fromEvent(this._win, 'orientationchange', { passive: true }),\r\n      fromEvent(this._win, 'resize', { passive: true }),\r\n    ).pipe(\r\n      debounceTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this._monitoring = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this.destroyed$),\r\n          // throttleTime(0, animationFrameScheduler),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this._updateStickies(fastUpdate);\r\n        });\r\n\r\n      // fromMediaQuery(this._win, 'print').subscribe(mqlEvent => {\r\n      //   if (mqlEvent.matches) {\r\n      //     this.disableStickies();\r\n      //   } else {\r\n      //     this.enableStickies();\r\n      //   }\r\n      // });\r\n    });\r\n  }\r\n\r\n  _updateStickies(fastUpdate?: boolean): void {\r\n    super.updateStickies(fastUpdate);\r\n  }\r\n}\r\n","import {\r\n  NgxSticky,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyComputation,\r\n  NgxStickyContainerController,\r\n  NgxStickyController,\r\n  NgxStickyState,\r\n} from './sticky.types';\r\n\r\n\r\n/**\r\n * Abstract sticky controller.\r\n */\r\nexport abstract class NgxStickyBaseController implements NgxStickyController {\r\n  abstract readonly boundary?: NgxStickyBoundaryController;\r\n  abstract readonly container: NgxStickyContainerController;\r\n  abstract readonly disabled: boolean;\r\n  abstract readonly state: NgxStickyState;\r\n\r\n  abstract beforeRefresh(fastUpdate?: boolean): void;\r\n  abstract disableSticky(): void;\r\n  abstract enableSticky(): void;\r\n  abstract getSticky(): NgxSticky;\r\n  abstract refresh(computation: NgxStickyComputation): void;\r\n\r\n  update(fastUpdate?: boolean): void {\r\n    // all stickies need to be updated when one of them changed\r\n    this.container.updateStickies(fastUpdate);\r\n  }\r\n}\r\n","import {\r\n  Directive,\r\n  ElementRef,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnChanges,\r\n  OnDestroy,\r\n  OnInit,\r\n  Optional,\r\n  SimpleChanges,\r\n  forwardRef,\r\n} from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\r\nimport { mapTo, share, takeUntil } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseBoundaryController } from './sticky-base-boundary.controller';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport { NgxStickyBoundary, NgxStickyContainerController } from './sticky.types';\r\nimport { coerceBooleanProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport { getElementAbsoluteRect } from './utils/dom';\r\n\r\n\r\nexport interface NgxStickyBoundaryConfig {\r\n  unstacked: boolean;\r\n}\r\n\r\n\r\nexport const NGX_STICKY_BASE_BOUNDARY_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyBoundaryConfig> = {\r\n  unstacked: {\r\n    aliasKey: 'stickyUnstacked',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n};\r\n\r\n\r\n/**\r\n * Defines a sticky boundary.\r\n */\r\n@Directive({\r\n  selector: '[ngxStickyBoundary], [ngx-sticky-boundary], ngx-sticky-boundary',\r\n  exportAs: 'ngxStickyBoundary',\r\n})\r\nexport class NgxStickyBoundaryDirective extends NgxStickyBaseBoundaryController implements OnChanges, OnDestroy, OnInit {\r\n  /**\r\n   * Enable/disable sticky stack inside boudary.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyUnstacked: boolean;\r\n\r\n  get config(): NgxStickyBoundaryConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get container(): NgxStickyContainerController {\r\n    return this._container;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject(NGX_STICKY_BASE_BOUNDARY_CONFIG_SCHEMA);\r\n\r\n  /** Boundary line which reflect last call of _computeBoundary() */\r\n  _boundary: NgxStickyBoundary;\r\n\r\n  /** Boundary container controller */\r\n  readonly _container: NgxStickyContainerController;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  readonly _destroyed$ = new Subject<void>();\r\n\r\n  /** Monitoring subscription which trigger update stickies */\r\n  _monitoring: Subscription;\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainer: NgxStickyContainerController,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    super();\r\n\r\n    // use root container when boundary isn't in container\r\n    this._container = stickyContainer || rootContainer;\r\n\r\n    // register boundary in container for first update calls\r\n    this.container.registerBoundary(this);\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    this._initMonitoring();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.container.unregisterBoundary(this);\r\n\r\n    if (!this._destroyed$.isStopped) {\r\n      this._destroyed$.next();\r\n      this._destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._boundary = null;\r\n    }\r\n  }\r\n\r\n  getBoundary(): NgxStickyBoundary {\r\n    if (!this._boundary) {\r\n      this._boundary = this._computeBoundary();\r\n    }\r\n\r\n    return this._boundary;\r\n  }\r\n\r\n  _computeBoundary(): NgxStickyBoundary {\r\n    const boundary: NgxStickyBoundary = getElementAbsoluteRect(this.elementRef.nativeElement);\r\n\r\n    if (this._win) {\r\n      const boundaryStyle = this._win.getComputedStyle(this.elementRef.nativeElement);\r\n      const paddingTop = parseFloat(boundaryStyle.paddingTop) || 0;\r\n      const paddingBottom = parseFloat(boundaryStyle.paddingBottom) || 0;\r\n\r\n      // substract paddings from computed boundary line\r\n      boundary.top += paddingTop;\r\n      boundary.height -= paddingTop + paddingBottom;\r\n    }\r\n\r\n    boundary.unstacked = this.config.unstacked;\r\n\r\n    return boundary;\r\n  }\r\n\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    return merge(\r\n      this.config$,\r\n      animationFrameScheduler,\r\n    ).pipe(\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this._monitoring = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this.updateStickies(fastUpdate);\r\n        });\r\n    });\r\n  }\r\n}\r\n","import { Directive, ElementRef, Inject, NgZone, Optional, SkipSelf, forwardRef } from '@angular/core';\r\n\r\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\r\nimport { NgxStickyEngine } from './sticky-engine';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport { NgxStickyContainerController } from './sticky.types';\r\n\r\n\r\n/**\r\n * Defines a sticky container.\r\n */\r\n@Directive({\r\n  selector: '[ngxStickyContainer], [ngx-sticky-container], ngx-sticky-container',\r\n  exportAs: 'ngxStickyContainer',\r\n})\r\nexport class NgxStickyContainerDirective extends NgxStickyBaseContainerDirective {\r\n  /**\r\n   * Returns HTMLElement of the container.\r\n   */\r\n  get element(): HTMLElement {\r\n    return this.elementRef.nativeElement;\r\n  }\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @SkipSelf() @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainerParent: NgxStickyContainerController,\r\n    readonly stickyEngine: NgxStickyEngine,\r\n    readonly ngZone: NgZone,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    // use root container when boundary isn't in container\r\n    super(stickyContainerParent || rootContainer, stickyEngine, ngZone, _win);\r\n  }\r\n\r\n  getViewportHeight(): number {\r\n    return this.element.offsetHeight;\r\n  }\r\n\r\n  getViewportLeft(): number {\r\n    return this.element.scrollLeft;\r\n  }\r\n\r\n  getViewportTop(): number {\r\n    return this.element.scrollTop;\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\nimport { isStickyDirectionDown, isStickyPositionBottom } from './sticky.helpers';\r\nimport {\r\n  NgxIntersection,\r\n  NgxIntersectionComputation,\r\n  NgxIntersectionSnap,\r\n  NgxSticky,\r\n  NgxStickyBoundary,\r\n  NgxStickyBoundaryComputed,\r\n  NgxStickyComputation,\r\n  NgxStickyComputed,\r\n  NgxStickyContainer,\r\n  NgxStickyLine,\r\n  NgxStickyPosition,\r\n  NgxStickySnap,\r\n  NgxStickyState,\r\n} from './sticky.types';\r\n\r\n\r\nexport const NGX_STICKY_ENGINE_INTERCEPTION_STATE_MAP = {\r\n  'sticked,normal': 'enter',\r\n  'stucked,normal': 'entered',\r\n  'sticked,sticked': 'entered',\r\n  'stucked,sticked': 'exit',\r\n  'stucked,stucked': 'exited',\r\n};\r\n\r\n\r\n/**\r\n * Defines a sticky engine. Implemented in universal way.\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class NgxStickyEngine {\r\n  /**\r\n   * Compute sticky boundary.\r\n   *\r\n   * @param container Container\r\n   * @param boundary Sticky boundary\r\n   * @param sticky Sticky line\r\n   * @param directionDown Direction down\r\n   * @param spot Spot line\r\n   * @param viewportHeight Viewport height\r\n   * @returns Boundary instance\r\n   */\r\n  computeStickyBoundary(\r\n    container: NgxStickyContainer,\r\n    boundary: NgxStickyBoundary | null,\r\n    sticky: NgxStickyLine,\r\n    directionDown: boolean,\r\n    spot: NgxStickyLine | null,\r\n    viewportHeight: number,\r\n  ): NgxStickyBoundaryComputed {\r\n    let {\r\n      height: boundaryHeight,\r\n      top: boundaryTop,\r\n      left: boundaryLeft,\r\n      width: boundaryWidth,\r\n    } = boundary || container;\r\n\r\n    boundaryHeight = boundaryHeight || 0;\r\n    boundaryTop = boundaryTop || 0;\r\n    boundaryWidth = boundaryWidth || 0;\r\n    boundaryLeft = boundaryLeft || 0;\r\n\r\n    if (spot && spot.height) {\r\n      const beforeSpot = sticky.top < spot.top;\r\n\r\n      if (beforeSpot) {\r\n        // when sticky direction is bottom and is before its spot\r\n        if (directionDown) {\r\n          const spotPoint = spot.top - viewportHeight;\r\n\r\n          // disable sticky when is in same viewport height as its spot\r\n          if (spotPoint < sticky.top) {\r\n            boundaryHeight = 0;\r\n            boundaryTop = 0;\r\n          // adjust sticky boundary height according to its spot when spot point is in base boundary\r\n          } else if (spotPoint < boundaryTop + boundaryHeight) {\r\n            boundaryHeight = spotPoint - boundaryTop + sticky.height;\r\n          }\r\n        }\r\n      } else {\r\n        // when sticky direction is top and is after its spot\r\n        if (!directionDown) {\r\n          const spotPoint = spot.top + spot.height + viewportHeight;\r\n\r\n          // disable sticky when is in same viewport height as its spot\r\n          if (spotPoint > sticky.top) {\r\n            boundaryHeight = 0;\r\n            boundaryTop = 0;\r\n            // adjust sticky boundary top according to its spot when spot point is in base boundary\r\n          } else if (spotPoint > boundaryTop && spotPoint < boundaryTop + boundaryHeight) {\r\n            boundaryHeight -= spotPoint - boundaryTop;\r\n            boundaryTop = spotPoint;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      height: boundaryHeight,\r\n      top: boundaryTop,\r\n      width: boundaryWidth,\r\n      left: boundaryLeft,\r\n      unstacked: boundary && boundary.unstacked || container.unstacked || false,\r\n      offsetBottom: 0,\r\n      offsetTop: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Compute sticky sticked line.\r\n   *\r\n   * @param boundary Sticky boundary line\r\n   * @param sticky Sticky line\r\n   * @param positionBottom Position bottom\r\n   * @param directionDown Direction down\r\n   * @param viewportHeight Viewport height\r\n   * @returns Sticked line\r\n   */\r\n  computeStickyStickedLine(\r\n    boundary: NgxStickyLine,\r\n    sticky: NgxStickyLine,\r\n    positionBottom: boolean,\r\n    directionDown: boolean,\r\n    viewportHeight: number,\r\n  ): NgxStickyLine {\r\n    let stickedTop: number;\r\n    let stickedHeight: number;\r\n\r\n    if (positionBottom) {\r\n      if (directionDown) {\r\n        stickedTop = sticky.top + sticky.height - viewportHeight;\r\n        stickedHeight = boundary.height + boundary.top - stickedTop - viewportHeight;\r\n      } else {\r\n        stickedTop = boundary.top - viewportHeight;\r\n        stickedHeight = sticky.top - stickedTop - viewportHeight;\r\n      }\r\n    } else {\r\n      if (directionDown) {\r\n        stickedTop = sticky.top;\r\n        stickedHeight = boundary.height + boundary.top - stickedTop;\r\n      } else {\r\n        stickedTop = boundary.top;\r\n        stickedHeight = sticky.top - stickedTop;\r\n      }\r\n    }\r\n\r\n    return { top: stickedTop, height: stickedHeight };\r\n  }\r\n\r\n  /**\r\n   * Compute sticky sort point.\r\n   *\r\n   * @param sticky Sticky line\r\n   * @param positionBottom Position bottom\r\n   * @param directionDown Direction down\r\n   * @param viewportHeight Viewport height\r\n   * @returns Sticky sort point\r\n   */\r\n  computeStickySortPoint(\r\n    sticky: NgxStickyLine,\r\n    positionBottom: boolean,\r\n    directionDown: boolean,\r\n    viewportHeight: number,\r\n  ): number {\r\n    let sortPoint: number;\r\n\r\n    if (positionBottom) {\r\n      sortPoint = directionDown\r\n        ? -sticky.top - sticky.height + viewportHeight\r\n        : sticky.top + sticky.height - viewportHeight;\r\n    } else {\r\n      sortPoint = directionDown\r\n        ? -sticky.top\r\n        : sticky.top;\r\n    }\r\n\r\n    return sortPoint;\r\n  }\r\n\r\n  /**\r\n   * Determines intersection state.\r\n   *\r\n   * @param snap Intersection snap\r\n   * @param viewportTop Viewport/scroll top position\r\n   * @returns Intersection computation\r\n   */\r\n  determineIntersectionState(snap: NgxIntersectionSnap, viewportTop: number): NgxIntersectionComputation {\r\n    const enter = this.determineStickyState(snap.enter, viewportTop);\r\n    const exit = this.determineStickyState(snap.exit, viewportTop);\r\n\r\n    // Intersection state can be easily determined from enter sticky and exit sticky states:\r\n    // - enter: when enter sticky (on bottom) is _sticked_ and exit sticky (on top) is _normal_ ;\r\n    // - entered: when enter (on bottom) and exit (on top) stickies are _sticked_ ;\r\n    // - entered: when enter sticky (on bottom) is _stucked_ and exit sticky (on top) is _normal_ ;\r\n    // - exit: when enter sticky (on bottom) is _stucked_ and exit sticky (on top) is _sticked_ ;\r\n    // - exited: when enter (on bottom) and exit (on top) stickies are _stucked_.\r\n    const stateKey = [ enter.state, exit.state ].join(',');\r\n    const state = NGX_STICKY_ENGINE_INTERCEPTION_STATE_MAP[stateKey] || null;\r\n\r\n    const viewportOffsetless = snap.viewportHeight - enter.offsetSticked - exit.offsetSticked;\r\n    const maxHeightVisible = Math.min(snap.intersection.height, viewportOffsetless);\r\n    let height = 0;\r\n    let intersecting = false;\r\n\r\n    if (state === 'entered') {\r\n      height = maxHeightVisible;\r\n      intersecting = true;\r\n    } else if (state === 'enter') {\r\n      height = viewportTop + snap.viewportHeight - snap.intersection.top - enter.offsetSticked;\r\n      intersecting = true;\r\n    } else if (state === 'exit') {\r\n      height = snap.intersection.top + snap.intersection.height - viewportTop - exit.offsetSticked;\r\n      intersecting = true;\r\n    }\r\n\r\n    const computation: NgxIntersectionComputation = {\r\n      enter,\r\n      exit,\r\n      snap,\r\n      height,\r\n      intersecting,\r\n      ratio: Math.min(1, height / maxHeightVisible),\r\n      state,\r\n      viewportTop,\r\n    };\r\n\r\n    return computation;\r\n  }\r\n\r\n  /**\r\n   * Determines sticky state.\r\n   *\r\n   * @param snap Sticky snap\r\n   * @param viewportTop Viewport/scroll top position\r\n   * @returns Sticky computation\r\n   */\r\n  determineStickyState(snap: NgxStickySnap, viewportTop: number): NgxStickyComputation {\r\n    const computation: NgxStickyComputation = {\r\n      offsetSticked: 0,\r\n      offsetStucked: 0,\r\n      state: 'normal',\r\n      snap,\r\n      viewportTop,\r\n    };\r\n\r\n    // cancel computation when stickyComputed is outside its boundary\r\n    if (snap.stickyComputed.disabled) {\r\n      return computation;\r\n    }\r\n\r\n    // last value stored in _stickyComputedState will be related to stickyComputed\r\n    let _stickyComputedState: NgxStickyState;\r\n\r\n    // compute state for each sibling and stickyComputed in last\r\n    for (const _stickyComputed of snap.stickies) {\r\n      const boundaryOffset = _stickyComputed.directionDown\r\n        ? _stickyComputed.boundary.offsetBottom\r\n        : _stickyComputed.boundary.offsetTop;\r\n      let {\r\n        top: _stickedTop,\r\n        height: _stickedHeight,\r\n      } = _stickyComputed.sticked;\r\n\r\n      // adjust _stickyComputed sticked line with previous sibling\r\n      if (_stickyComputed.positionBottom) {\r\n        if (_stickyComputed.directionDown) {\r\n          _stickedTop += computation.offsetSticked + computation.offsetStucked;\r\n          _stickedHeight -= computation.offsetStucked;\r\n        } else {\r\n          _stickedTop += boundaryOffset;\r\n          _stickedTop += computation.offsetSticked;\r\n          _stickedHeight -= boundaryOffset - computation.offsetStucked;\r\n          _stickedHeight += _stickyComputed.height;\r\n        }\r\n      } else {\r\n        if (_stickyComputed.directionDown) {\r\n          _stickedTop -= computation.offsetSticked + computation.offsetStucked;\r\n          _stickedHeight += computation.offsetStucked;\r\n          _stickedHeight -= boundaryOffset;\r\n        } else {\r\n          _stickedTop -= computation.offsetSticked;\r\n          _stickedHeight -= computation.offsetStucked;\r\n        }\r\n      }\r\n\r\n      // set default state to \"normal\"\r\n      _stickyComputedState = 'normal';\r\n\r\n      // determine _stickyComputed state with its sticked line adjusted\r\n      // if (viewportTop > _stickedTop) {\r\n      if (viewportTop >= _stickedTop) {\r\n        _stickyComputedState = 'sticked';\r\n\r\n        if (viewportTop > _stickedTop + _stickedHeight) {\r\n          _stickyComputedState = _stickyComputed.directionDown ? 'stucked' : 'normal';\r\n        }\r\n      } else if (!_stickyComputed.directionDown) {\r\n        _stickyComputedState = 'stucked';\r\n      }\r\n\r\n      // cumulate sibling height to the right offset\r\n      if (\r\n        // when _stickyComputed isn't stickyComputed\r\n        _stickyComputed !== snap.stickyComputed\r\n        // and state determined is \"sticked\" or \"stucked\"\r\n        && _stickyComputedState !== 'normal'\r\n        // and _stickyComputed is stacked\r\n        && !_stickyComputed.boundary.unstacked\r\n      ) {\r\n        if (\r\n          _stickyComputed.boundary.top === snap.stickyComputed.boundary.top\r\n            && _stickyComputed.boundary.height === snap.stickyComputed.boundary.height\r\n        ) {\r\n          computation.offsetStucked += _stickyComputed.height;\r\n        } else if (_stickyComputedState === 'sticked') {\r\n          computation.offsetSticked += _stickyComputed.height;\r\n        }\r\n      }\r\n      // (computation as any)._state = _stickyComputedState;\r\n    }\r\n\r\n    computation.state = _stickyComputedState;\r\n\r\n    return computation;\r\n  }\r\n\r\n  /**\r\n   * Returns scroll top offset height used by stickies for a given viewport position.\r\n   *\r\n   * @param container Container\r\n   * @param stickies Stickies\r\n   * @param position Position `\"top\"` or `\"bottom\"`\r\n   * @param viewportHeight Viewport height\r\n   * @param offsetTop Viewport top\r\n   * @returns Top offset height used by stickies.\r\n   */\r\n  getStickedOffset(\r\n    container: NgxStickyContainer,\r\n    stickies: NgxSticky[],\r\n    position: NgxStickyPosition,\r\n    viewportHeight: number,\r\n    viewportTop: number,\r\n  ): number {\r\n    const positionBottom = isStickyPositionBottom(position);\r\n    let maxStickyUnstackedHeight = 0;\r\n    let stickedOffset = 0;\r\n\r\n    for (const _sticky of stickies) {\r\n      // skip sticky when is position bottom\r\n      if (isStickyPositionBottom(_sticky.position) !== positionBottom) {\r\n        continue;\r\n      }\r\n\r\n      const snap = this.snapSticky(container, stickies, _sticky, viewportHeight);\r\n\r\n      // skip sticky when is disabled\r\n      if (snap.sticky.disabled) {\r\n        continue;\r\n      }\r\n\r\n      const computation = this.determineStickyState(snap, viewportTop);\r\n\r\n      // add sticky height to offset top when state is sticked\r\n      if (computation.state === 'sticked') {\r\n        const _elementHeight = snap.stickyComputed.height;\r\n\r\n        // substract height when sticy is stacked\r\n        if (!snap.stickyComputed.boundary.unstacked) {\r\n          stickedOffset += _elementHeight;\r\n        // or update the biggest sticky unstacked\r\n        } else if (_elementHeight > maxStickyUnstackedHeight) {\r\n          maxStickyUnstackedHeight = _elementHeight;\r\n        }\r\n      }\r\n    }\r\n\r\n    stickedOffset += maxStickyUnstackedHeight;\r\n\r\n    if (positionBottom) {\r\n      stickedOffset += container.offsetBottom || 0;\r\n    } else {\r\n      stickedOffset += container.offsetTop || 0;\r\n    }\r\n\r\n    return stickedOffset;\r\n  }\r\n\r\n  /**\r\n   * Create intersection snap.\r\n   *\r\n   * @param container Container\r\n   * @param stickies Stickies\r\n   * @param intersection Intersection\r\n   * @param viewportHeight Viewport height\r\n   * @returns Intersection snap\r\n   */\r\n  snapIntersection(\r\n    container: NgxStickyContainer,\r\n    stickies: NgxSticky[],\r\n    intersection: NgxIntersection,\r\n    viewportHeight: number,\r\n  ): NgxIntersectionSnap {\r\n    const disabled = intersection.disabled;\r\n\r\n    // enter sticky is sticked on bottom\r\n    const enterSticky: NgxSticky = {\r\n      boundary: {\r\n        top: intersection.top - 1,\r\n        height: intersection.height,\r\n        left: container.left,\r\n        width: container.width,\r\n      },\r\n      disabled,\r\n      top: intersection.top - 1,\r\n      height: 1,\r\n      position: 'bottom',\r\n      direction: 'down',\r\n    };\r\n\r\n    // exit sticky is sticked on top\r\n    const exitSticky: NgxSticky = {\r\n      boundary: {\r\n        top: intersection.top,\r\n        height: intersection.height - 1,\r\n        left: container.left,\r\n        width: container.width,\r\n      },\r\n      disabled,\r\n      top: intersection.top,\r\n      height: 1,\r\n      position: 'top',\r\n      direction: 'down',\r\n    };\r\n\r\n    return {\r\n      container,\r\n      enter: this.snapSticky(container, stickies, enterSticky, viewportHeight),\r\n      exit: this.snapSticky(container, stickies, exitSticky, viewportHeight),\r\n      intersection: {\r\n        disabled,\r\n        height: intersection.height,\r\n        thresholds: intersection.thresholds ? [ ...intersection.thresholds ] : [ 0, 1 ],\r\n        top: intersection.top,\r\n      },\r\n      viewportHeight,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create sticky snap.\r\n   *\r\n   * @param container Container\r\n   * @param stickies Stickies\r\n   * @param sticky Sticky\r\n   * @param viewportHeight Viewport height\r\n   * @returns Sticky snap\r\n   */\r\n  snapSticky(\r\n    container: NgxStickyContainer,\r\n    stickies: NgxSticky[],\r\n    sticky: NgxSticky,\r\n    viewportHeight: number,\r\n  ): NgxStickySnap {\r\n    const boundariesMap: Record<string, NgxStickyBoundaryComputed> = {};\r\n\r\n    const directionDown = isStickyDirectionDown(sticky.direction);\r\n    const positionBottom = isStickyPositionBottom(sticky.position);\r\n\r\n    const stickyComputed: NgxStickyComputed = {\r\n      boundary: this.computeStickyBoundary(\r\n        container,\r\n        sticky.boundary,\r\n        sticky,\r\n        directionDown,\r\n        sticky.spot,\r\n        viewportHeight,\r\n      ),\r\n      directionDown,\r\n      disabled: false,\r\n      height: sticky.height,\r\n      positionBottom,\r\n      sortPoint: this.computeStickySortPoint(sticky, positionBottom, directionDown, viewportHeight),\r\n      sticked: null,\r\n      top: sticky.top,\r\n    };\r\n\r\n    if (\r\n      container.disabled\r\n      || sticky.disabled\r\n      || !sticky.height\r\n      || sticky.top < stickyComputed.boundary.top\r\n      || sticky.top > stickyComputed.boundary.top + stickyComputed.boundary.height\r\n    ) {\r\n      stickyComputed.disabled = true;\r\n      stickyComputed.sticked = { height: 0, top: 0 };\r\n    } else {\r\n      stickyComputed.sticked = this.computeStickyStickedLine(\r\n        stickyComputed.boundary,\r\n        sticky,\r\n        positionBottom,\r\n        directionDown,\r\n        viewportHeight,\r\n      );\r\n    }\r\n\r\n    const stickiesComputed: NgxStickyComputed[] = [];\r\n    let offsetSpacer: NgxSticky;\r\n\r\n    if (sticky.disabled) {\r\n      return {\r\n        boundaries: boundariesMap,\r\n        container,\r\n        stickies: stickiesComputed,\r\n        sticky,\r\n        stickyComputed,\r\n        viewportHeight,\r\n      };\r\n    }\r\n\r\n    // insert fake sticky which represent container offset top\r\n    if (container.offsetTop && !stickyComputed.positionBottom) {\r\n      offsetSpacer = {\r\n        boundary: container,\r\n        direction: 'down',\r\n        height: container.offsetTop,\r\n        position: 'top',\r\n        disabled: false,\r\n        top: container.top,\r\n      };\r\n\r\n      stickies = [ offsetSpacer, ...stickies ];\r\n    }\r\n\r\n    // insert fake sticky which represent container offset bottom\r\n    if (container.offsetBottom && stickyComputed.positionBottom) {\r\n      offsetSpacer = {\r\n        boundary: container,\r\n        direction: 'up',\r\n        height: container.offsetBottom,\r\n        position: 'bottom',\r\n        disabled: false,\r\n        top: container.top + container.height - container.offsetBottom,\r\n      };\r\n\r\n      stickies = [ offsetSpacer, ...stickies ];\r\n    }\r\n\r\n    // remove 1px to fix round sizes (offsetLeft and offsetWidth)\r\n    const stickyComputedBoundaryRight = stickyComputed.boundary.left + stickyComputed.boundary.width - 1;\r\n\r\n    for (let _stickyIndex = 0; _stickyIndex < stickies.length; ++_stickyIndex) {\r\n      const _sticky = stickies[_stickyIndex];\r\n      let _directionDown: boolean;\r\n      let _positionBottom: boolean;\r\n      let _stickyComputed: NgxStickyComputed;\r\n      let _stickyComputedBoundaryRight: number;\r\n\r\n      if (_sticky === sticky) {\r\n        _directionDown = stickyComputed.directionDown;\r\n        _positionBottom = stickyComputed.positionBottom;\r\n        _stickyComputed = stickyComputed;\r\n        _stickyComputedBoundaryRight = stickyComputedBoundaryRight;\r\n      } else {\r\n        _directionDown = isStickyDirectionDown(_sticky.direction);\r\n        _positionBottom = isStickyPositionBottom(_sticky.position);\r\n\r\n        _stickyComputed = {\r\n          boundary: this.computeStickyBoundary(\r\n            container,\r\n            _sticky.boundary,\r\n            _sticky,\r\n            _directionDown,\r\n            _sticky.spot,\r\n            viewportHeight,\r\n          ),\r\n          disabled: false,\r\n          directionDown: _directionDown,\r\n          height: _sticky.height,\r\n          positionBottom: _positionBottom,\r\n          sortPoint: this.computeStickySortPoint(_sticky, _positionBottom, _directionDown, viewportHeight),\r\n          sticked: null,\r\n          top: _sticky.top,\r\n        };\r\n\r\n        // remove 1px to fix round sizes (offsetLeft and offsetWidth)\r\n        _stickyComputedBoundaryRight = _stickyComputed.boundary.left + _stickyComputed.boundary.width - 1;\r\n\r\n        if (\r\n          _sticky.disabled\r\n          || !_sticky.height\r\n          // skip sticky which isn't in its boundary\r\n          || _sticky.top < _stickyComputed.boundary.top\r\n          || _sticky.top > _stickyComputed.boundary.top + _stickyComputed.boundary.height\r\n          // skip sticky sibling when its boundary isn't align horizontaly\r\n          || stickyComputedBoundaryRight <= _stickyComputed.boundary.left\r\n          || stickyComputed.boundary.left >= _stickyComputedBoundaryRight\r\n        ) {\r\n          _stickyComputed.disabled = true;\r\n          _stickyComputed.sticked = { height: 0, top: 0 };\r\n        } else {\r\n          _stickyComputed.sticked = this.computeStickyStickedLine(\r\n            _stickyComputed.boundary,\r\n            _sticky,\r\n            _positionBottom,\r\n            _directionDown,\r\n            viewportHeight,\r\n          );\r\n        }\r\n      }\r\n\r\n      // compute boundary unique key\r\n      const boundaryKey = [ _stickyComputed.boundary.top, _stickyComputed.boundary.height ].join(',');\r\n\r\n      // ensure stickies computed to use same boundary instance\r\n      if (boundariesMap[boundaryKey]) {\r\n        _stickyComputed.boundary = boundariesMap[boundaryKey];\r\n      } else {\r\n        boundariesMap[boundaryKey] = _stickyComputed.boundary;\r\n      }\r\n\r\n      // skip sticky sibling when is disabled\r\n      if (_stickyComputed.disabled) {\r\n        continue;\r\n      }\r\n\r\n      // set sticky sibling height as max boundary offset when it unstacked\r\n      if (_stickyComputed.boundary.unstacked) {\r\n        if (_directionDown) {\r\n          if (_sticky.height > _stickyComputed.boundary.offsetBottom) {\r\n            _stickyComputed.boundary.offsetBottom = _sticky.height;\r\n          }\r\n        } else {\r\n          if (_sticky.height > _stickyComputed.boundary.offsetTop) {\r\n            _stickyComputed.boundary.offsetTop = _sticky.height;\r\n          }\r\n        }\r\n      // add sticky sibling height to right boundary offset when it stacked\r\n      } else {\r\n        if (_directionDown) {\r\n          _stickyComputed.boundary.offsetBottom += _sticky.height;\r\n        } else {\r\n          _stickyComputed.boundary.offsetTop += _sticky.height;\r\n        }\r\n      }\r\n\r\n      // pushforce offset spacer as sticky siblings\r\n      if (_sticky === offsetSpacer) {\r\n        stickiesComputed.push(_stickyComputed);\r\n\r\n        continue;\r\n      }\r\n\r\n      // collect stickyComputed siblings\r\n      if (\r\n        // when _stickyComputed isn't stickyComputed\r\n        _stickyComputed !== stickyComputed\r\n        // and its position equals to stickyComputed position\r\n        && _stickyComputed.positionBottom === stickyComputed.positionBottom\r\n        // and its sticked line intersects top of stickyComputed sticked line\r\n        && stickyComputed.sticked.top >= _stickyComputed.sticked.top\r\n        && stickyComputed.sticked.top <= _stickyComputed.sticked.top + _stickyComputed.sticked.height\r\n        // and its top is before stickyComputed top according to its own position\r\n        && (\r\n          _stickyComputed.directionDown\r\n            ? _stickyComputed.top < stickyComputed.top\r\n            : _stickyComputed.top > stickyComputed.top\r\n        )\r\n      ) {\r\n        stickiesComputed.push(_stickyComputed);\r\n      }\r\n    }\r\n\r\n    // sort stickyComputed siblings according to their respective sortPoint and boundary top\r\n    stickiesComputed.sort((a, b) => {\r\n      return a.positionBottom === stickyComputed.positionBottom\r\n        ? a.sortPoint < b.sortPoint && a.boundary.top >= b.boundary.top ? 1 : -1\r\n        : -1;\r\n    });\r\n\r\n    // add stickyComputed in last position\r\n    stickiesComputed.push(stickyComputed);\r\n\r\n    return {\r\n      container,\r\n      boundaries: boundariesMap,\r\n      stickies: stickiesComputed,\r\n      sticky,\r\n      stickyComputed,\r\n      viewportHeight,\r\n    };\r\n  }\r\n}\r\n","import { Inject, Injectable, NgZone } from '@angular/core';\r\n\r\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\r\nimport { NgxStickyEngine } from './sticky-engine';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport { NgxStickyContainerController } from './sticky.types';\r\n\r\n\r\n/**\r\n * Defines the sticky root container which is used to manage sticky without container.\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class NgxStickyRootContainerController extends NgxStickyBaseContainerDirective {\r\n  // root container never has parent container\r\n  readonly containerParent: NgxStickyContainerController = null;\r\n  // root container never has element\r\n  readonly element: HTMLElement = null;\r\n\r\n  constructor(\r\n    readonly stickyEngine: NgxStickyEngine,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    super(null, stickyEngine, ngZone, _win);\r\n  }\r\n}\r\n","import { Directive, HostBinding, Input } from '@angular/core';\r\n\r\nimport { coerceNumberProperty } from './utils';\r\n\r\n@Directive({\r\n  selector: '[ngxStickySpot], [ngx-sticky-spot], ngx-sticky-spot',\r\n  exportAs: 'ngxStickySpot',\r\n})\r\nexport class NgxStickySpotDirective {\r\n  @HostBinding('class.ngx-sticky-spot')\r\n  readonly cssClassStickySpot = true;\r\n\r\n  @HostBinding('style.position')\r\n  readonly cssStylePosition = 'absolute';\r\n\r\n  @HostBinding('style.height.px')\r\n  @Input()\r\n  get stickySpotHeight(): number { return this._stickySpotHeight; }\r\n  set stickySpotHeight(value: number) { this._stickySpotHeight = coerceNumberProperty(value); }\r\n\r\n  private _stickySpotHeight = 1;\r\n}\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  HostBinding,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnChanges,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  Renderer2,\r\n  SimpleChanges,\r\n  SkipSelf,\r\n  forwardRef,\r\n  isDevMode,\r\n} from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\r\nimport { distinctUntilChanged, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseController } from './sticky-base.controller';\r\nimport { NgxStickyBoundaryDirective } from './sticky-boundary.directive';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { coerceStickyDirection, coerceStickyPosition, getStuckedPositionTop } from './sticky.helpers';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport {\r\n  NgxSticky,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyComputation,\r\n  NgxStickyContainerController,\r\n  NgxStickyController,\r\n  NgxStickyDirection,\r\n  NgxStickyPosition,\r\n  NgxStickyState,\r\n} from './sticky.types';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport { getElementAbsoluteRect, getElementRelativeRect, setElementStyles } from './utils/dom';\r\nimport { fromImageEvents } from './utils/from-image-events';\r\n\r\n\r\n/**\r\n * Interface for a sticky style.\r\n */\r\nexport interface NgxStickyElementStyle {\r\n  // [prop: string]: string;\r\n  width: string;\r\n  position: string;\r\n  top: string;\r\n  right: string;\r\n  bottom: string;\r\n  left: string;\r\n  cssFloat: string;\r\n  margin: string;\r\n  marginTop: string;\r\n  marginRight: string;\r\n  marginBottom: string;\r\n  marginLeft: string;\r\n}\r\n\r\n/**\r\n * Interface for a sticky ghost style.\r\n */\r\nexport interface NgxStickyGhostStyle {\r\n  // [prop: string]: string;\r\n  width: string;\r\n  position: string;\r\n  top: string;\r\n  right: string;\r\n  bottom: string;\r\n  left: string;\r\n  cssFloat: string;\r\n  marginTop: string;\r\n  marginRight: string;\r\n  marginBottom: string;\r\n  marginLeft: string;\r\n\r\n  height: string;\r\n  maxHeight: string;\r\n  minHeight: string;\r\n  boxSizing: string;\r\n  borderTop: string;\r\n  borderBottom: string;\r\n  borderLeft: string;\r\n  borderRight: string;\r\n  paddingTop: string;\r\n  paddingBottom: string;\r\n  paddingLeft: string;\r\n  paddingRight: string;\r\n}\r\n\r\n\r\nexport interface NgxStickyConfig {\r\n  classes: boolean;\r\n  disabled: boolean;\r\n  direction: NgxStickyDirection;\r\n  height: number;\r\n  // orbit: boolean;\r\n  position: NgxStickyPosition;\r\n  spacer: HTMLElement | null;\r\n  spot: HTMLElement | null;\r\n  spotHeight: number;\r\n}\r\n\r\n\r\nexport const NGX_STICKY_BASE_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyConfig> = {\r\n  classes: {\r\n    aliasKey: 'stickyClasses',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  disabled: {\r\n    aliasKey: 'stickyDisabled',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  direction: {\r\n    aliasKey: 'stickyDirection',\r\n    defaultValue: 'down',\r\n    coercion: coerceStickyDirection,\r\n  },\r\n  height: {\r\n    aliasKey: 'stickyHeight',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n  // orbit: {\r\n  //   aliasKey: 'stickyOrbit',\r\n  //   defaultValue: false,\r\n  //   coercion: coerceBooleanProperty,\r\n  // },\r\n  position: {\r\n    aliasKey: 'stickyPosition',\r\n    defaultValue: 'top',\r\n    coercion: coerceStickyPosition,\r\n  },\r\n  spacer: {\r\n    aliasKey: 'stickySpacer',\r\n    defaultValue: null,\r\n  },\r\n  spot: {\r\n    aliasKey: 'stickySpot',\r\n    defaultValue: null,\r\n  },\r\n  spotHeight: {\r\n    aliasKey: 'stickySpotHeight',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n};\r\n\r\n\r\n/**\r\n * Defines a sticky.\r\n */\r\n@Directive({\r\n  selector: '[ngxSticky], [ngx-sticky], ngx-sticky',\r\n  exportAs: 'ngxSticky',\r\n})\r\nexport class NgxStickyDirective extends NgxStickyBaseController implements AfterViewInit, OnChanges, OnDestroy {\r\n  /**\r\n   * Binding sticky classes.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyClasses: boolean;\r\n\r\n  /**\r\n   * Direction of the sticky; one of 'up' or 'down'.\r\n   *\r\n   * Defaults to `'down'`.\r\n   */\r\n  @Input()\r\n  stickyDirection: NgxStickyDirection;\r\n\r\n  /**\r\n   * Disable sticky.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyDisabled: boolean;\r\n\r\n  /**\r\n   * Force element height when calculate sticky element height.\r\n   */\r\n  @Input()\r\n  stickyHeight: number;\r\n\r\n  // /**\r\n  //  * Indicate sticky element is an orbit.\r\n  //  *\r\n  //  * An orbit is a sticky element which isn't visible until\r\n  //  * it's sticked.\r\n  //  *\r\n  //  * Generally an orbit spot on another element to be sticked.\r\n  //  *\r\n  //  * Defaults to `false`.\r\n  //  */\r\n  // @Input()\r\n  // stickyOrbit: boolean;\r\n\r\n  /**\r\n   * Position of the sticky; one of 'top' or 'bottom'.\r\n   *\r\n   * Defaults to `'top'`.\r\n   */\r\n  @Input()\r\n  stickyPosition: NgxStickyPosition;\r\n\r\n  /**\r\n   * Sticky spacer.\r\n   *\r\n   * Defaults to `null`.\r\n   */\r\n  @Input()\r\n  stickySpacer: HTMLElement | null;\r\n\r\n  /**\r\n   * Reference to an element used to determine sticky state.\r\n   *\r\n   * The sticky directive will stick element only when spot\r\n   * isn't visible.\r\n   *\r\n   * Defaults to `null`.\r\n   */\r\n  @Input()\r\n  stickySpot: HTMLElement | null;\r\n\r\n  /**\r\n   * Force spot height when calculate sticky spot height.\r\n   */\r\n  @Input()\r\n  stickySpotHeight: number;\r\n\r\n  /**\r\n   * Emit sticky computation.\r\n   */\r\n  @Output()\r\n  readonly stickyComputation = new EventEmitter<NgxStickyComputation>();\r\n\r\n  /**\r\n   * Emit sticky state.\r\n   */\r\n  @Output()\r\n  readonly stickyState = new EventEmitter<NgxStickyState>();\r\n\r\n  @HostBinding('attr.data-sticky-state')\r\n  get attrDataStickyState() { return !this.stickyParent ? this.state : null; }\r\n\r\n  @HostBinding('class.ngx-sticky')\r\n  get cssClassSticky() { return !this.stickyParent && this.config.classes; }\r\n\r\n  @HostBinding('class.ngx-sticky--normal')\r\n  get cssClassStickyNormal() { return this.cssClassSticky && this.state === 'normal'; }\r\n\r\n  @HostBinding('class.ngx-sticky--sticked')\r\n  get cssClassStickySticked() { return this.cssClassSticky && this.state === 'sticked'; }\r\n\r\n  @HostBinding('class.ngx-sticky--stucked')\r\n  get cssClassStickyStucked() { return this.cssClassSticky && this.state === 'stucked'; }\r\n\r\n  @HostBinding('class.ngx-sticky--disabled')\r\n  get cssClassStickyDisabled() { return this.cssClassSticky && this.disabled; }\r\n\r\n  // @HostBinding('class.ngx-sticky--spot')\r\n  // get cssClassStickySpot() { return this.cssClassSticky && !!this.config.spot; }\r\n\r\n  // @HostBinding('class.ngx-sticky--position-top')\r\n  // get cssClassStickyPositionTop() { return this.cssClassSticky && !isStickyPositionBottom(this.config.position); }\r\n\r\n  // @HostBinding('class.ngx-sticky--position-bottom')\r\n  // get cssClassStickyPositionBottom() { return this.cssClassSticky && isStickyPositionBottom(this.config.position); }\r\n\r\n  // @HostBinding('class.ngx-sticky--direction-up')\r\n  // get cssClassStickyDirectionUp() { return this.cssClassSticky && !isStickyDirectionDown(this.config.direction); }\r\n\r\n  // @HostBinding('class.ngx-sticky--direction-down')\r\n  // get cssClassStickydirectionDown() { return this.cssClassSticky && isStickyDirectionDown(this.config.direction); }\r\n\r\n  get boundary(): NgxStickyBoundaryController {\r\n    return this._boundary;\r\n  }\r\n\r\n  get container(): NgxStickyContainerController {\r\n    return this._container;\r\n  }\r\n\r\n  get config(): NgxStickyConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.config.disabled;\r\n  }\r\n\r\n  /**\r\n   * State of the sticky.\r\n   */\r\n  get state(): NgxStickyState {\r\n    return this._stickyState;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject<NgxStickyConfig>(NGX_STICKY_BASE_CONFIG_SCHEMA);\r\n\r\n  /** Sticky container controller */\r\n  readonly _container: NgxStickyContainerController;\r\n\r\n  /** Sticky boundary controller */\r\n  readonly _boundary?: NgxStickyBoundaryController;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  readonly _destroyed$ = new Subject<void>();\r\n\r\n  /** Sticky element style original */\r\n  _elementOriginStyle: NgxStickyElementStyle;\r\n\r\n  /** Monitoring subscription which trigger update stickies and handle refresh */\r\n  _monitoring: Subscription;\r\n\r\n  /** Sticky spacer generated */\r\n  _spacerGenerated: HTMLElement;\r\n\r\n  /** Sticky which reflect last call of _computeSticky() */\r\n  _sticky: NgxSticky;\r\n\r\n  /** Emits when refresh() is called */\r\n  readonly _refresh$ = new Subject<NgxStickyComputation>();\r\n\r\n  /** Sticky computation which reflect last call of _refreshSticky()  */\r\n  _stickyComputation: NgxStickyComputation;\r\n\r\n  /** Sticky element state which reflect last call of _refreshStickyElement() */\r\n  _stickyElementState: NgxStickyState = null;\r\n\r\n  /** Sticky element state which reflect last sticky state output */\r\n  _stickyState: NgxStickyState = null;\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainer: NgxStickyContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyBoundaryDirective))\r\n    readonly stickyBoundary: NgxStickyBoundaryController,\r\n    @SkipSelf() @Optional() @Inject(forwardRef(() => NgxStickyDirective))\r\n    readonly stickyParent: NgxStickyController,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    readonly renderer: Renderer2,\r\n    // readonly changeDetectorRef: ChangeDetectorRef,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    super();\r\n\r\n    // use root container when sticky isn't in container\r\n    this._container = stickyContainer || rootContainer;\r\n\r\n    // ensure sticky boundary is in same container\r\n    this._boundary = stickyBoundary && stickyBoundary.container === this._container ? stickyBoundary : null;\r\n\r\n    // register sticky in container only if isn't in another sticky\r\n    if (!this.stickyParent) {\r\n      // register in parent container for first update calls\r\n      this.container.registerSticky(this);\r\n    }\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    // avoid sticky initialization when sticky has a parent\r\n    if (this._preventNestedStickyError()) {\r\n      return;\r\n    }\r\n\r\n    this._initMonitoring();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.container.unregisterSticky(this);\r\n\r\n    if (!this._destroyed$.isStopped) {\r\n      this._destroyed$.next();\r\n      this._destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._sticky = null;\r\n    }\r\n  }\r\n\r\n  disableSticky(): void {\r\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\r\n  }\r\n\r\n  enableSticky(): void {\r\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\r\n  }\r\n\r\n  getSticky(): NgxSticky {\r\n    if (!this._sticky) {\r\n      this._sticky = this._computeSticky();\r\n    }\r\n\r\n    return this._sticky;\r\n  }\r\n\r\n  refresh(computation: NgxStickyComputation): void {\r\n    this._refresh$.next(computation);\r\n  }\r\n\r\n  _computeSticky(): NgxSticky {\r\n    // IMPORTANT: refresh sticky element to its normal state is required to compute repainted element height.\r\n    this._refreshStickyElement(null);\r\n    this._refreshStickyElement('normal');\r\n\r\n    const config = this.config$.getValue();\r\n\r\n    // element and spot rects which reflects last screen repaint\r\n    const elementRect = getElementAbsoluteRect(this.elementRef.nativeElement);\r\n    const spotRect = config.spot ? getElementAbsoluteRect(config.spot) : null;\r\n\r\n    if (config.height) {\r\n      elementRect.height = config.height;\r\n    }\r\n\r\n    if (spotRect && config.spotHeight) {\r\n      spotRect.height = config.spotHeight;\r\n    }\r\n\r\n    return {\r\n      disabled: config.disabled,\r\n      boundary: this.boundary ? this.boundary.getBoundary() : null,\r\n      direction: config.direction,\r\n      height: elementRect.height,\r\n      position: config.position,\r\n      top: elementRect.top,\r\n      spot: spotRect,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create sticky monitoring observable.\r\n   */\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    return merge(\r\n      this.config$,\r\n      fromImageEvents(this.elementRef.nativeElement),\r\n      fromImageEvents(this.config.spot),\r\n      animationFrameScheduler,\r\n    ).pipe(\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy sticky monitoring subscription.\r\n   */\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns styles of the given state.\r\n   *\r\n   * `computation` is required when `state` is `\"sticked\"` or `\"stucked\"`.\r\n   *\r\n   * @param state Sticky state\r\n   * @param computation Sticky state computation\r\n   * @returns Styles of the sticky state\r\n   */\r\n  _getStickyElementStyle(state: NgxStickyState, computation?: NgxStickyComputation): Partial<NgxStickyElementStyle> {\r\n    const win = this._win;\r\n\r\n    if (!win || !state) {\r\n      return null;\r\n    }\r\n\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n    const ghostParent = ghost.offsetParent as HTMLElement;\r\n    const ghostParentIsRootElement = ghostParent === win.document.body || ghostParent === win.document.documentElement;\r\n\r\n    // when state is normal (computation isn't needed)\r\n    if (state === 'normal') {\r\n      const ghostRelativeRect = getElementRelativeRect(win, ghost);\r\n      const ghostStyle = win.getComputedStyle(ghost);\r\n      const ghostBorderBox = ghostStyle.boxSizing === 'border-box';\r\n\r\n      let elementWidth = ghostRelativeRect.width;\r\n\r\n      if (!ghostBorderBox) {\r\n        elementWidth +=\r\n          - ((parseFloat(ghostStyle.borderLeft) || 0) + (parseFloat(ghostStyle.borderRight) || 0))\r\n          - ((parseFloat(ghostStyle.paddingLeft) || 0) + (parseFloat(ghostStyle.paddingRight) || 0));\r\n      }\r\n\r\n      let elementTop = ghostRelativeRect.top;\r\n      let elementLeft = ghostRelativeRect.left;\r\n\r\n      if (ghostParentIsRootElement) {\r\n        if (this.container !== this.rootContainer) {\r\n          const ghostRect = getElementAbsoluteRect(ghost);\r\n          const viewportTop = this.container.getViewportTop();\r\n\r\n          elementTop = ghostRect.top - viewportTop;\r\n        }\r\n\r\n        elementTop += win.document.documentElement.offsetTop;\r\n        elementLeft += win.document.documentElement.offsetLeft;\r\n      }\r\n\r\n      const styles = {\r\n        position: 'absolute',\r\n        width: `${elementWidth}px`,\r\n        top: `${elementTop}px`,\r\n        right: '',\r\n        bottom: '',\r\n        left: `${elementLeft}px`,\r\n        float: '',\r\n        margin: '0px',\r\n      };\r\n\r\n      return styles;\r\n    }\r\n\r\n    const { container, stickyComputed, viewportHeight } = computation.snap;\r\n\r\n    // when state is sticked\r\n    if (state === 'sticked') {\r\n      const positionBottom = stickyComputed.positionBottom;\r\n\r\n      let elementTop: number;\r\n      let elementLeft: number;\r\n\r\n      if (this.container !== this.rootContainer) {\r\n        const ghostRelativeRect = getElementRelativeRect(win, ghost);\r\n\r\n        elementLeft = ghostRelativeRect.left;\r\n\r\n        if (ghostParentIsRootElement) {\r\n          elementTop = container.top;\r\n\r\n          elementTop += win.document.documentElement.offsetTop;\r\n          elementLeft += win.document.documentElement.offsetLeft;\r\n        } else {\r\n          const ghostParentRect = getElementAbsoluteRect(ghostParent);\r\n\r\n          elementTop = computation.viewportTop - ghostParentRect.top;\r\n        }\r\n\r\n        if (positionBottom) {\r\n          elementTop += viewportHeight - stickyComputed.height - computation.offsetSticked - computation.offsetStucked;\r\n        } else {\r\n          elementTop += computation.offsetSticked + computation.offsetStucked;\r\n        }\r\n\r\n        return {\r\n          position: 'absolute',\r\n          top: `${elementTop}px`,\r\n          bottom: '',\r\n          left: `${elementLeft}px`,\r\n        };\r\n      } else {\r\n        const ghostRect = getElementAbsoluteRect(ghost);\r\n\r\n        elementTop = computation.offsetSticked + computation.offsetStucked;\r\n        elementLeft = ghostRect.left + win.document.documentElement.offsetLeft;\r\n\r\n        return {\r\n          position: 'fixed',\r\n          top: !positionBottom ? `${elementTop}px` : '',\r\n          bottom: positionBottom ? `${elementTop}px` : '',\r\n          left: `${elementLeft}px`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // when state is stucked\r\n    if (state === 'stucked') {\r\n      const ghostRect = getElementAbsoluteRect(ghost);\r\n\r\n      let elementTop: number;\r\n      let elementLeft: number;\r\n\r\n      elementTop = getStuckedPositionTop(computation);\r\n\r\n      elementLeft = ghostRect.left;\r\n\r\n      if (ghostParentIsRootElement) {\r\n        if (this.container !== this.rootContainer) {\r\n          // we can't use computation.viewportTop because it's absolute viewport top\r\n          const relativeViewportTop = this.container.getViewportTop();\r\n\r\n          elementTop -= relativeViewportTop;\r\n        }\r\n\r\n        elementTop += win.document.documentElement.offsetTop;\r\n        elementLeft += win.document.documentElement.offsetLeft;\r\n      } else {\r\n        const ghostParentRect = getElementAbsoluteRect(ghostParent);\r\n\r\n        elementTop -= ghostParentRect.top;\r\n        elementLeft -= ghostParentRect.left;\r\n      }\r\n\r\n      return {\r\n        position: 'absolute',\r\n        top: `${elementTop}px`,\r\n        bottom: '',\r\n        left: `${elementLeft}px`,\r\n      };\r\n    }\r\n\r\n    // throw new Error(`Invalid state: ${state}`);\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns sticky ghost style.\r\n   *\r\n   * @returns Styles of the sticky ghost\r\n   */\r\n  _getStickyGhostStyle(): NgxStickyGhostStyle {\r\n    const stickySpacer = this.config.spacer || this._spacerGenerated;\r\n\r\n    if (!this._win || !stickySpacer) {\r\n      return null;\r\n    }\r\n\r\n    const element = this.elementRef.nativeElement;\r\n    const elementStyle = this._win.getComputedStyle(element);\r\n    const elementnBorderBox = elementStyle.boxSizing === 'border-box';\r\n\r\n    let ghostHeight = element.offsetHeight;\r\n    // const ghostWidth = elementStyle.width;\r\n\r\n    // substract borders and paddings when element isn't border-boxed\r\n    if (!elementnBorderBox) {\r\n      ghostHeight +=\r\n        // substract vertical borders\r\n        - (parseFloat(elementStyle.borderTopWidth) || 0)\r\n        - (parseFloat(elementStyle.borderBottomWidth) || 0)\r\n        // substract vertical paddings\r\n        - (parseFloat(elementStyle.paddingTop) || 0)\r\n        - (parseFloat(elementStyle.paddingBottom) || 0);\r\n    }\r\n\r\n    const styles: NgxStickyGhostStyle = {\r\n      boxSizing: elementStyle.boxSizing,\r\n      position: elementStyle.position,\r\n      top: elementStyle.top,\r\n      right: elementStyle.right,\r\n      bottom: elementStyle.bottom,\r\n      left: elementStyle.left,\r\n      width: element.style.width,\r\n      // width: element.style.width || elementStyle.width,\r\n      // width: `${ghostWidth}px`,\r\n      height: `${ghostHeight}px`,\r\n      maxHeight: `${ghostHeight}px`,\r\n      minHeight: `${ghostHeight}px`,\r\n      borderTop: elementStyle.borderTop,\r\n      borderBottom: elementStyle.borderBottom,\r\n      borderLeft: elementStyle.borderLeft,\r\n      borderRight: elementStyle.borderRight,\r\n      // borderColor: 'transparent',\r\n      cssFloat: elementStyle.cssFloat,\r\n      marginTop: elementStyle.marginTop,\r\n      marginBottom: elementStyle.marginBottom,\r\n      marginLeft: elementStyle.marginLeft,\r\n      marginRight: elementStyle.marginRight,\r\n      paddingTop: elementStyle.paddingTop,\r\n      paddingBottom: elementStyle.paddingBottom,\r\n      paddingLeft: elementStyle.paddingLeft,\r\n      paddingRight: elementStyle.paddingRight,\r\n    };\r\n\r\n    // if (this.config.orbit) {\r\n    //   styles.position = 'absolute';\r\n    //   styles.width = element.style.width || elementStyle.width;\r\n    // }\r\n\r\n    return styles;\r\n  }\r\n\r\n  /**\r\n   * Hides sticky ghost.\r\n   */\r\n  _hideStickyGhost(): void {\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n\r\n    if (!ghost) {\r\n      return;\r\n    }\r\n\r\n    this.renderer.setStyle(ghost, 'display', 'none');\r\n  }\r\n\r\n  /**\r\n   * Init sticky monitoring.\r\n   */\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      const handleRefreshSubscription = this._refresh$\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          distinctUntilChanged(),\r\n          throttleTime(0, animationFrameScheduler, { leading: true, trailing: true }),\r\n          share(),\r\n        )\r\n        .subscribe(computation => {\r\n          this._refreshSticky(computation);\r\n        });\r\n\r\n      const triggerUpdateSubscription = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this.update(fastUpdate);\r\n        });\r\n\r\n      this._monitoring = new Subscription();\r\n      this._monitoring.add(handleRefreshSubscription);\r\n      this._monitoring.add(triggerUpdateSubscription);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Inserts sticky ghost generated.\r\n   */\r\n  _insertStickyGhostGenerated(): void {\r\n    if (this._spacerGenerated) {\r\n      return;\r\n    }\r\n\r\n    const element = this.elementRef.nativeElement;\r\n\r\n    const ghost = this.renderer.createElement(element.tagName);\r\n    this.renderer.addClass(ghost, 'ngx-sticky-spacer');\r\n    // this.renderer.setStyle(ghost, 'borderStyle', 'solid');\r\n    // this.renderer.setStyle(ghost, 'borderColor', 'transparent');\r\n    this.renderer.insertBefore(element.parentElement, ghost, element);\r\n\r\n    this._spacerGenerated = ghost;\r\n  }\r\n\r\n  /**\r\n   * Log nested sticky error and returns `true` when sticky is in another sticky.\r\n   *\r\n   * @returns `true` when sticky is in another sticky\r\n   */\r\n  _preventNestedStickyError(): boolean {\r\n    if (!this.stickyParent) {\r\n      return false;\r\n    }\r\n\r\n    const nestedStickyError = new Error('Nested sticky is not support. Sticky will not work.');\r\n\r\n    const logLevel = isDevMode() ? 'error' : 'warn';\r\n    const logLevelLogger = console[logLevel];\r\n\r\n    logLevelLogger(nestedStickyError);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Refresh sticky with given computation.\r\n   *\r\n   * @param computation Sticky state computation\r\n   */\r\n  _refreshSticky(computation: NgxStickyComputation): void {\r\n    if (\r\n      // refresh sticky when state has changed\r\n      computation.state !== this._stickyElementState\r\n      // or when sticky is in container (other than window)\r\n      || this.container !== this.rootContainer\r\n    ) {\r\n      this._refreshStickyElement(computation.state, computation);\r\n    }\r\n\r\n    this._stickyComputation = computation;\r\n    this.stickyComputation.next(computation);\r\n\r\n    if (computation.state === this._stickyState) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.run(() => {\r\n      this._stickyState = computation.state;\r\n      this.stickyState.next(computation.state);\r\n\r\n      // this.changeDetectorRef.detectChanges();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refreshs sticky element style.\r\n   *\r\n   * @param state Sticky state\r\n   * @param computation Sticky state computation when state is sticked or stucked\r\n   */\r\n  _refreshStickyElement(state: NgxStickyState, computation?: NgxStickyComputation): void {\r\n    if (!this._win) {\r\n      return;\r\n    }\r\n\r\n    // hide ghost and refresh original style when state is null\r\n    if (!state) {\r\n      this._stickyElementState = null;\r\n\r\n      this._hideStickyGhost();\r\n      this._restoreStickyElementStyle();\r\n\r\n      return;\r\n    }\r\n\r\n    this._stickyElementState = state;\r\n\r\n    this._saveStickyElementStyle();\r\n    this._showStickyGhost();\r\n\r\n    const elementStyle = this._getStickyElementStyle(state, computation);\r\n\r\n    setElementStyles(this.renderer, this.elementRef.nativeElement, elementStyle);\r\n  }\r\n\r\n  /**\r\n   * Refreshs sticky ghost.\r\n   */\r\n  _refreshStickyGhost(): void {\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n    const ghostStyle = this._getStickyGhostStyle();\r\n\r\n    setElementStyles(this.renderer, ghost, ghostStyle);\r\n  }\r\n\r\n  /**\r\n   * Restore original styles of the sticky.\r\n   */\r\n  _restoreStickyElementStyle(): void {\r\n    setElementStyles(this.renderer, this.elementRef.nativeElement, this._elementOriginStyle);\r\n    this._elementOriginStyle = null;\r\n  }\r\n\r\n  /**\r\n   * Saves origin styles of the sticky.\r\n   */\r\n  _saveStickyElementStyle(): void {\r\n    if (!this._elementOriginStyle) {\r\n      this._elementOriginStyle = {\r\n        position: this.elementRef.nativeElement.style.position,\r\n        width: this.elementRef.nativeElement.style.width,\r\n        top: this.elementRef.nativeElement.style.top,\r\n        right: this.elementRef.nativeElement.style.right,\r\n        bottom: this.elementRef.nativeElement.style.bottom,\r\n        left: this.elementRef.nativeElement.style.left,\r\n        cssFloat: this.elementRef.nativeElement.style.cssFloat,\r\n        margin: this.elementRef.nativeElement.style.margin,\r\n        marginTop: this.elementRef.nativeElement.style.marginTop,\r\n        marginRight: this.elementRef.nativeElement.style.marginRight,\r\n        marginBottom: this.elementRef.nativeElement.style.marginBottom,\r\n        marginLeft: this.elementRef.nativeElement.style.marginLeft,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shows sticky ghost.\r\n   */\r\n  _showStickyGhost(): void {\r\n    if (!this.config.spacer && !this._spacerGenerated) {\r\n      this._insertStickyGhostGenerated();\r\n      this._refreshStickyGhost();\r\n\r\n      return;\r\n    } else if (this.config.spacer && this._spacerGenerated) {\r\n      this._spacerGenerated.remove();\r\n      this._spacerGenerated = null;\r\n    }\r\n\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n\r\n    if (ghost.style.display === 'none') {\r\n      this.renderer.setStyle(ghost, 'display', 'block');\r\n      this._refreshStickyGhost();\r\n    }\r\n  }\r\n}\r\n","import {\r\n  NgxStickyComputation,\r\n  NgxStickyDirection,\r\n  NgxStickyPosition,\r\n} from './sticky.types';\r\n\r\n\r\nexport function coerceStickyPosition(value: any): NgxStickyPosition {\r\n  return isStickyPositionBottom(value) ? 'bottom' : 'top';\r\n}\r\n\r\nexport function coerceStickyDirection(value: any): NgxStickyDirection {\r\n  return isStickyDirectionDown(value) ? 'down' : 'up';\r\n}\r\n\r\n\r\nexport function getStuckedPositionTop(computation: NgxStickyComputation): number {\r\n  const {\r\n    boundary,\r\n    directionDown,\r\n    height: elementHeight,\r\n    positionBottom,\r\n  } = computation.snap.stickyComputed;\r\n\r\n  return directionDown\r\n    ? boundary.top\r\n      + boundary.height\r\n      - elementHeight\r\n      - (positionBottom\r\n          ? computation.offsetStucked\r\n          : boundary.offsetBottom - elementHeight - computation.offsetStucked)\r\n    : positionBottom\r\n      ? boundary.top + boundary.offsetTop - elementHeight - computation.offsetStucked\r\n      : boundary.top + computation.offsetStucked;\r\n}\r\n\r\n\r\nexport function isStickyPositionBottom(position: NgxStickyPosition) {\r\n  return position === 'bottom';\r\n}\r\n\r\nexport function isStickyDirectionDown(direction: NgxStickyDirection) {\r\n  return direction !== 'up';\r\n}\r\n","import { CommonModule } from '@angular/common';\r\nimport { NgModule } from '@angular/core';\r\n\r\nimport { NgxInViewportDirective } from './in-viewport.directive';\r\nimport { NgxStickyBoundaryDirective } from './sticky-boundary.directive';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickySpotDirective } from './sticky-spot.directive';\r\nimport { NgxStickyDirective } from './sticky.directive';\r\n\r\n/**\r\n * Adds sticky directives and providers.\r\n *\r\n * Managing sticky elements is one of the hardest parts of building web applications.\r\n *\r\n * The NgxStickyModule allows to manage sticky elements in the best way.\r\n *\r\n * @example\r\n * NgxStickyModule can be imported multiple times: once per lazily-loaded bundle.\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [ NgxStickyModule ]\r\n * })\r\n * class MyNgModule {}\r\n * ```\r\n */\r\n@NgModule({\r\n  declarations: [\r\n    NgxInViewportDirective,\r\n    NgxStickyBoundaryDirective,\r\n    NgxStickyContainerDirective,\r\n    NgxStickyDirective,\r\n    NgxStickySpotDirective,\r\n  ],\r\n  exports: [\r\n    NgxInViewportDirective,\r\n    NgxStickyBoundaryDirective,\r\n    NgxStickyContainerDirective,\r\n    NgxStickyDirective,\r\n    NgxStickySpotDirective,\r\n  ],\r\n  imports: [ CommonModule ],\r\n})\r\nexport class NgxStickyModule { }\r\n","import { InjectionToken } from '@angular/core';\r\n\r\n\r\nexport const NGX_STICKY_WINDOW = new InjectionToken<Window>('NGX_STICKY_WINDOW', {\r\n  providedIn: 'root',\r\n  factory: () => typeof window !== 'undefined' ? window : null,\r\n});\r\n","/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\r\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nexport function coerceBooleanProperty(value: any): boolean {\r\n  return value != null && `${value}` !== 'false';\r\n}\r\n\r\n\r\n/** Coerces a data-bound value (typically a string) to a number. */\r\nexport function coerceNumberProperty(value: any): number;\r\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\r\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\r\n  return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nexport function _isNumberValue(value: any): boolean {\r\n  // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n  // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n  // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n  return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\r\n}\r\n","\r\n\r\n/**\r\n * Add entry into set.\r\n *\r\n * @param set Array list\r\n * @param entry Entry to add\r\n * @returns Entry index added\r\n */\r\nexport function addEntry<T>(set: T[], entry: T): number {\r\n  let entryIndex = set.indexOf(entry);\r\n\r\n  if (entryIndex === -1) {\r\n    entryIndex = set.length;\r\n\r\n    set[entryIndex] = entry;\r\n  }\r\n\r\n  return entryIndex;\r\n}\r\n\r\n\r\n/**\r\n * Delete entry from set.\r\n *\r\n * @param set Array list\r\n * @param entry Entry to delete\r\n * @returns Entry index deleted\r\n */\r\nexport function deleteEntry<T>(set: T[], entry: T): number {\r\n  const entryIndex = set.indexOf(entry);\r\n\r\n  if (entryIndex !== -1) {\r\n    set.splice(entryIndex, 1);\r\n  }\r\n\r\n  return entryIndex;\r\n}\r\n","import { Subject, Subscription } from 'rxjs';\r\n\r\nimport { InputCoercionFn, InputSubject, InputSubjectChange, InputSubjectNextOptions } from './input-subject';\r\n\r\n\r\nexport type ConfigInputSubjects<T> = { [K in keyof T]: InputSubject<T[K]> };\r\nexport type ConfigSubjectChanges<T> = { [K in keyof T]: InputSubjectChange<T[K]> };\r\nexport type ConfigSubjectSchema<T> = { [K in keyof T]: ConfigSubjectInputOptions<T, K> };\r\n\r\nexport interface ConfigSubjectInputOptions<T, K extends keyof T> {\r\n  defaultValue: T[K];\r\n  aliasKey?: string;\r\n  coercion?: InputCoercionFn<T[K]>;\r\n}\r\n\r\n\r\n/**\r\n * A ConfigSubject is an Observable that coerces key-values and emit when change is detected\r\n */\r\nexport class ConfigSubject<T> extends Subject<T> {\r\n  /** Emit key-values changes */\r\n  readonly changes$ = new Subject<ConfigSubjectChanges<T>>();\r\n  /** Input subjects for each config key-value */\r\n  readonly inputs: ConfigInputSubjects<T>;\r\n\r\n  _config: T;\r\n  _configChanged: boolean;\r\n  _configChanges: ConfigSubjectChanges<T>;\r\n\r\n  readonly _aliases: { [key: string]: keyof T };\r\n\r\n  readonly _pushChangesSubscription = new Subscription();\r\n\r\n  constructor(schema: ConfigSubjectSchema<T>) {\r\n    super();\r\n\r\n    this.inputs = {} as ConfigInputSubjects<T>;\r\n    this._config = {} as T;\r\n    this._configChanges = {} as ConfigSubjectChanges<T>;\r\n    this._aliases = {};\r\n\r\n    const inputKeys = Object.keys(schema) as (keyof T)[];\r\n\r\n    for (const inputKey of inputKeys) {\r\n      const inputOptions = schema[inputKey];\r\n\r\n      if (inputOptions.aliasKey) {\r\n        this._aliases[inputOptions.aliasKey] = inputKey;\r\n      }\r\n\r\n      const input = new InputSubject<T[keyof T]>(inputOptions.defaultValue, inputOptions.coercion);\r\n\r\n      this._config[inputKey] = inputOptions.defaultValue;\r\n      this.inputs[inputKey] = input;\r\n\r\n      const pushChangeSubscription = input.change$.subscribe(inputChange => {\r\n        this._configChanged = true;\r\n        this._configChanges[inputKey] = inputChange;\r\n\r\n        this._config = { ...this._config };\r\n        this._config[inputKey] = inputChange.currentValue;\r\n      });\r\n\r\n      this._pushChangesSubscription.add(pushChangeSubscription);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns current config.\r\n   */\r\n  getValue(): T {\r\n    return this._config;\r\n  }\r\n\r\n  /**\r\n   * Returns key-value.\r\n   *\r\n   * @param inputKey Input key\r\n   * @returns key-value\r\n   */\r\n  getKeyValue<K extends keyof T>(inputKey: K): T[K] {\r\n    return this._config[inputKey];\r\n  }\r\n\r\n  /**\r\n   * Emit next config.\r\n   *\r\n   * @param partialConfig Partial next config\r\n   * @param options Options to skip coercion\r\n   */\r\n  next(partialConfig?: Partial<T>, options?: InputSubjectNextOptions): void {\r\n    const inputKeys = Object.keys(partialConfig);\r\n\r\n    for (const key of inputKeys) {\r\n      const inputKey = (this._aliases[key] || key) as keyof T;\r\n\r\n      if (inputKey in this.inputs) {\r\n        const inputValue = partialConfig[key] as T[keyof T];\r\n        const inputSubject = this.inputs[inputKey];\r\n\r\n        inputSubject.next(inputValue, options);\r\n      }\r\n    }\r\n\r\n    if (this._configChanged) {\r\n      const changes = { ...this._configChanges };\r\n\r\n      this._configChanged = false;\r\n      this._configChanges = {} as ConfigSubjectChanges<T>;\r\n\r\n      this.changes$.next(changes);\r\n\r\n      super.next(this._config);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit next key-value.\r\n   *\r\n   * @param inputKey Input key\r\n   * @param value key-value\r\n   * @param options Options to skip coercion\r\n   */\r\n  nextKeyValue<K extends keyof T>(inputKey: K, value: T[K], options?: InputSubjectNextOptions): void {\r\n    this.next({ [inputKey]: value } as {} as Partial<T>, options);\r\n  }\r\n\r\n  /**\r\n   * Apply simple changes as like ngOnChange(changes: SimpleChanges) input.\r\n   *\r\n   * @param changes Simple changes\r\n   */\r\n  nextChanges(changes: { [key: string]: { currentValue: any } }) {\r\n    const changeKeys = Object.keys(changes);\r\n    const config: Partial<T> = {};\r\n\r\n    for (const inputKey of changeKeys) {\r\n      config[inputKey] = changes[inputKey].currentValue;\r\n    }\r\n\r\n    this.next(config);\r\n  }\r\n}\r\n","import { Renderer2 } from '@angular/core';\r\n\r\n\r\n/**\r\n * Returns getter for document height.\r\n *\r\n * @param win Window reference\r\n * @returns Getter for document height.\r\n */\r\nexport function getDocumentHeightFactory(win: Window): () => number {\r\n  if (!win) {\r\n    return () => 0;\r\n  }\r\n\r\n  const documentHeightGetters = [\r\n    () => win.document.body.scrollHeight,\r\n    () => win.document.documentElement.scrollHeight,\r\n    () => win.document.body.offsetHeight,\r\n    () => win.document.documentElement.offsetHeight,\r\n    () => win.document.body.clientHeight,\r\n    () => win.document.documentElement.clientHeight,\r\n  ];\r\n\r\n  let documentHeightGetter = documentHeightGetters[0];\r\n  let documentHeight = 0;\r\n\r\n  for (const _documentHeightGetter of documentHeightGetters) {\r\n    const _documentHeight = _documentHeightGetter();\r\n\r\n    if (_documentHeight > documentHeight) {\r\n      documentHeightGetter = _documentHeightGetter;\r\n      documentHeight = _documentHeight;\r\n    }\r\n  }\r\n\r\n  return documentHeightGetter;\r\n}\r\n\r\n\r\n/**\r\n * Returns getter for document width.\r\n *\r\n * @param win Window reference\r\n * @returns Getter for document width.\r\n */\r\nexport function getDocumentWidthFactory(win: Window): () => number {\r\n  if (!win) {\r\n    return () => 0;\r\n  }\r\n\r\n  const documentWidthGetters = [\r\n    () => win.document.body.scrollWidth,\r\n    () => win.document.documentElement.scrollWidth,\r\n    () => win.document.body.offsetWidth,\r\n    () => win.document.documentElement.offsetWidth,\r\n    () => win.document.body.clientWidth,\r\n    () => win.document.documentElement.clientWidth,\r\n  ];\r\n\r\n  let documentWidthGetter = documentWidthGetters[0];\r\n  let documentWidth = 0;\r\n\r\n  for (const _documentWidthGetter of documentWidthGetters) {\r\n    const _documentWidth = _documentWidthGetter();\r\n\r\n    if (_documentWidth > documentWidth) {\r\n      documentWidthGetter = _documentWidthGetter;\r\n      documentWidth = _documentWidth;\r\n    }\r\n  }\r\n\r\n  return documentWidthGetter;\r\n}\r\n\r\n\r\n/**\r\n * Returns element absolute rect.\r\n *\r\n * @param element Element\r\n * @returns Element absolute rect\r\n */\r\nexport function getElementAbsoluteRect(element: HTMLElement) {\r\n  const rect = {\r\n    height: element.offsetHeight,\r\n    width: element.offsetWidth,\r\n    left: 0,\r\n    top: 0,\r\n  };\r\n\r\n  let currentElement = element;\r\n\r\n  do {\r\n    rect.top += currentElement.offsetTop || 0;\r\n    rect.left += currentElement.offsetLeft || 0;\r\n\r\n    currentElement = currentElement.offsetParent as HTMLElement;\r\n  } while (currentElement);\r\n\r\n  return rect;\r\n}\r\n\r\n\r\n/**\r\n * Returns element relative rect.\r\n *\r\n * @param win Window reference\r\n * @param element Element\r\n * @returns Element relative rect.\r\n */\r\nexport function getElementRelativeRect(win: Window, element: HTMLElement) {\r\n  const rect = {\r\n    height: element.offsetHeight,\r\n    width: element.offsetWidth,\r\n    left: 0,\r\n    top: 0,\r\n  };\r\n\r\n  let currentElement = element;\r\n  let currentElementStyle: CSSStyleDeclaration;\r\n\r\n  do {\r\n    currentElementStyle = currentElement !== element ? win.getComputedStyle(currentElement) : {} as CSSStyleDeclaration;\r\n\r\n    if (currentElementStyle.position === 'relative') {\r\n      break;\r\n    }\r\n\r\n    if (currentElementStyle.position !== 'absolute') {\r\n      rect.top += currentElement.offsetTop || 0;\r\n      rect.left += currentElement.offsetLeft || 0;\r\n    }\r\n\r\n    currentElement = currentElement.offsetParent as HTMLElement;\r\n  } while (currentElement);\r\n\r\n  return rect;\r\n}\r\n\r\n\r\n/**\r\n * Get window viewport height.\r\n *\r\n * @param win Window reference\r\n * @returns Window viewport height\r\n */\r\nexport function getWindowViewportHeight(win: Window): number {\r\n  return win && win.innerHeight || 0;\r\n}\r\n\r\n\r\n/**\r\n * Get window scroll left position.\r\n *\r\n * @param win Window reference\r\n * @returns Window scroll left position\r\n */\r\nexport function getWindowViewportLeft(win: Window): number {\r\n  if (!win) {\r\n    return 0;\r\n  }\r\n\r\n  // The top-left-corner of the viewport is determined by the scroll position of the document\r\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n  // `document.documentElement` works consistently, where the `top` and `left` values will\r\n  // equal negative the scroll position.\r\n  const documentRect = win.document.documentElement.getBoundingClientRect();\r\n\r\n  return -documentRect.left\r\n    || win.document.body.scrollLeft\r\n    || win.scrollX\r\n    || win.document.documentElement.scrollLeft\r\n    || 0;\r\n}\r\n\r\n\r\n/**\r\n * Get window scroll top position.\r\n *\r\n * @param win Window reference\r\n * @returns Window scroll top position\r\n */\r\nexport function getWindowViewportTop(win: Window): number {\r\n  if (!win) {\r\n    return 0;\r\n  }\r\n\r\n  // The top-left-corner of the viewport is determined by the scroll position of the document\r\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n  // `document.documentElement` works consistently, where the `top` and `left` values will\r\n  // equal negative the scroll position.\r\n  const documentRect = win.document.documentElement.getBoundingClientRect();\r\n\r\n  return -documentRect.top\r\n    || win.document.body.scrollTop\r\n    || win.scrollY\r\n    || win.document.documentElement.scrollTop\r\n    || 0;\r\n}\r\n\r\n\r\n/**\r\n * Returns `true` when element is scrollable.\r\n *\r\n * @param win Window reference\r\n * @param element Element\r\n * @returns `true` when element is scrollable\r\n */\r\nexport function isElementScrollableY(win: Window, element: HTMLElement): boolean {\r\n  return element.offsetHeight < element.scrollHeight && win.getComputedStyle(element).overflowY === 'auto';\r\n}\r\n\r\n\r\n/**\r\n * Set styles on a given element.\r\n *\r\n * @param renderer Renderer2 instance\r\n * @param element Element\r\n * @param styles Styles\r\n */\r\nexport function setElementStyles(\r\n  renderer: Renderer2,\r\n  element: HTMLElement,\r\n  styles: any,\r\n): void {\r\n  if (!element || !styles) {\r\n    return;\r\n  }\r\n\r\n  const propKeys = Object.keys(styles);\r\n\r\n  for (const prop of propKeys) {\r\n    const value = styles[prop];\r\n\r\n    if (value) {\r\n      renderer.setStyle(element, prop, value);\r\n    } else {\r\n      renderer.removeStyle(element, prop);\r\n    }\r\n  }\r\n}\r\n\r\n","import { Observable, fromEvent, merge, of } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\n\r\n\r\n/**\r\n * Create observable which emit image events.\r\n *\r\n * @param element Element\r\n * @returns Observable on image events\r\n */\r\nexport function fromImageEvents(element: HTMLElement): Observable<{ event: Event; target: HTMLImageElement }> {\r\n  if (!element) {\r\n    return of();\r\n  }\r\n\r\n  const images$: Observable<{ event: Event; target: HTMLImageElement }>[] = [];\r\n\r\n  const addImage = (target: HTMLImageElement) => images$.push(\r\n    fromEvent(target, 'load').pipe(map(event => ({ event, target }))),\r\n    fromEvent(target, 'error').pipe(map(event => ({ event, target }))),\r\n  );\r\n\r\n  // if (element instanceof HTMLImageElement) {\r\n  if (element.tagName === 'IMG' || element.tagName === 'img') {\r\n    addImage(element as HTMLImageElement);\r\n  } else {\r\n    element.querySelectorAll('img').forEach(addImage);\r\n  }\r\n\r\n  return merge(...images$);\r\n}\r\n","import { BehaviorSubject, Observable, of } from 'rxjs';\r\n\r\n/**\r\n * Create observable which emit media query events.\r\n *\r\n * @param win Window reference\r\n * @param query Media query\r\n * @returns Observable on media query events\r\n */\r\nexport function fromMediaQuery(win: Window, query: string): Observable<MediaQueryListEvent> {\r\n  if (!win || !win.matchMedia) {\r\n    return of();\r\n  }\r\n\r\n  const mql = win.matchMedia(query);\r\n\r\n  const initEvent = {\r\n    matches: mql.matches,\r\n    media: query,\r\n  };\r\n\r\n  const initMqlEvent = typeof MediaQueryListEvent !== 'undefined'\r\n    ? new MediaQueryListEvent('change', initEvent)\r\n    : { type: 'change', ...initEvent} as MediaQueryListEvent;\r\n\r\n  const mql$ = new BehaviorSubject<MediaQueryListEvent>(initMqlEvent);\r\n\r\n  const onQueryChange = (mqlEvent: MediaQueryListEvent) => mql$.next(mqlEvent);\r\n  const complete = mql$.complete;\r\n\r\n  mql$.complete = function() {\r\n    complete.call(mql$);\r\n    mql.removeListener(onQueryChange);\r\n  };\r\n\r\n  mql.addListener(onQueryChange);\r\n\r\n  return mql$;\r\n}\r\n","export * from './coercion';\r\nexport * from './collections';\r\nexport * from './config-subject';\r\nexport * from './dom';\r\nexport * from './from-image-events';\r\nexport * from './from-media-query';\r\nexport * from './input-subject';\r\nexport * from './intersection';\r\n","import { Subject } from 'rxjs';\r\n\r\n\r\nexport type InputCoercionFn<T> = (value: T) => T;\r\n\r\nexport interface InputSubjectNextOptions {\r\n  skipCoercion?: boolean;\r\n}\r\n\r\nexport interface InputSubjectChange<T> {\r\n  previousValue: T;\r\n  currentValue: T;\r\n  firstChange: boolean;\r\n}\r\n\r\n\r\n/**\r\n * An InputSubject is an Observable that coerces values and emit when change is detected.\r\n */\r\nexport class InputSubject<T> extends Subject<T> {\r\n  /** Emit value changes */\r\n  readonly change$ = new Subject<InputSubjectChange<T>>();\r\n\r\n  _firstChange = true;\r\n  _value: T;\r\n  _valueSetted: T;\r\n\r\n  constructor(\r\n    readonly defaultValue: T,\r\n    readonly coercion?: InputCoercionFn<T>,\r\n  ) {\r\n    super();\r\n\r\n    this._value = defaultValue;\r\n  }\r\n\r\n  /**\r\n   * Returns current value.\r\n   */\r\n  getValue(): T {\r\n    return this._value;\r\n  }\r\n\r\n  /**\r\n   * Emit next value.\r\n   *\r\n   * @param value Next value\r\n   * @param options Options to skip coercion\r\n   */\r\n  next(value?: T, options?: InputSubjectNextOptions): void {\r\n    if (!options || !options.skipCoercion) {\r\n      if (value === this._valueSetted) {\r\n        return;\r\n      }\r\n\r\n      this._valueSetted = value;\r\n\r\n      if (this.coercion) {\r\n        value = this.coercion(value);\r\n      }\r\n    }\r\n\r\n    if (value !== this._value) {\r\n      const firstChange = this._firstChange;\r\n      const previousValue = this._value;\r\n\r\n      this._firstChange = false;\r\n      this._value = value;\r\n\r\n      this.change$.next({\r\n        previousValue,\r\n        currentValue: value,\r\n        firstChange,\r\n      });\r\n\r\n      super.next(value);\r\n    }\r\n  }\r\n}\r\n","\r\n\r\n/** Coerces a data-bound value (typically a string) to intersection thresholds. */\r\nexport function coerceIntersectionThresholds(thresholds: any) {\r\n  if (typeof thresholds === 'number') {\r\n    return [ thresholds ];\r\n  }\r\n\r\n  if (typeof thresholds === 'string') {\r\n    return (thresholds as string)\r\n      .split(',')\r\n      .map(x => (parseFloat(x) || 0))\r\n      .sort();\r\n  }\r\n\r\n  if (!thresholds) {\r\n    return [ 0, 1 ];\r\n  }\r\n\r\n  if (!Array.isArray(thresholds)) {\r\n    thresholds = [ thresholds ];\r\n  }\r\n\r\n  return [ ...thresholds ].sort();\r\n}\r\n\r\n\r\n/**\r\n * Returns threshold crossed for a given ratio change.\r\n *\r\n * @param thresholds Thresholds\r\n * @param oldRatio Old ratio\r\n * @param newRatio New ratio\r\n * @returns Threshold crossed or `undefined`\r\n */\r\nexport function getCrossedThreshold(thresholds: number[], oldRatio: number, newRatio: number): number {\r\n  let crossedThreshold: number;\r\n\r\n  for (const threshold of thresholds) {\r\n    if (\r\n      // threshold is perfect-crossed by old ratio\r\n      threshold === oldRatio\r\n      // or threshold is perfect-crossed by new ratio\r\n      || threshold === newRatio\r\n      // or threshold is crossed by new ratio and old ratio (there are on the opposite sides)\r\n      || threshold < oldRatio !== threshold < newRatio\r\n    ) {\r\n      crossedThreshold = threshold;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return crossedThreshold;\r\n}\r\n","/*\r\n * Public API Surface of @enten/ngx-sticky\r\n */\r\n\r\nexport * from './lib/in-viewport.directive';\r\nexport * from './lib/sticky-base-boundary.controller';\r\nexport * from './lib/sticky-base-container.controller';\r\nexport * from './lib/sticky-base-container.directive';\r\nexport * from './lib/sticky-base.controller';\r\nexport * from './lib/sticky-boundary.directive';\r\nexport * from './lib/sticky-container.directive';\r\nexport * from './lib/sticky-engine';\r\nexport * from './lib/sticky-root-container.controller';\r\nexport * from './lib/sticky-spot.directive';\r\nexport * from './lib/sticky.directive';\r\nexport * from './lib/sticky.helpers';\r\nexport * from './lib/sticky.module';\r\nexport * from './lib/sticky.tokens';\r\nexport * from './lib/sticky.types';\r\nexport * from './lib/utils';\r\n","import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\n\r\nconst routes: Routes = [];\r\n\r\n@NgModule({\r\n  imports: [ RouterModule.forRoot(routes) ],\r\n  exports: [ RouterModule ],\r\n})\r\nexport class AppRoutingModule { }\r\n","import { ChangeDetectorRef, Component, Inject, OnDestroy, OnInit } from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\n\r\nimport {\r\n  NGX_STICKY_WINDOW,\r\n  NgxStickyDirection,\r\n  NgxStickyPosition,\r\n  fromMediaQuery,\r\n} from '../../projects/ngx-sticky/src/public-api';\r\n\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: [ './app.component.scss' ],\r\n})\r\nexport class AppComponent implements OnDestroy, OnInit  {\r\n  apiBoundaryStickyDisabled = false;\r\n  apiBoundaryStickyOrbit = false;\r\n  apiBoundaryStickyDirection: NgxStickyDirection = 'down';\r\n  apiBoundaryStickyPosition: NgxStickyPosition = 'top';\r\n\r\n  apiContainerStickyDisabled = false;\r\n  apiContainerStickyOrbit = false;\r\n  apiContainerStickyDirection: NgxStickyDirection = 'down';\r\n  apiContainerStickyOffsetTop = 0;\r\n  apiContainerStickyOffsetBottom = 0;\r\n  apiContainerStickyPosition: NgxStickyPosition = 'top';\r\n\r\n  apiInViewportStickyDisabled = false;\r\n  apiInViewportStickyOrbit = false;\r\n  apiInViewportStickyDirection: NgxStickyDirection = 'down';\r\n  apiInViewportStickyPosition: NgxStickyPosition = 'top';\r\n\r\n  _isSmallScreen: boolean;\r\n  _smallBreakpointSubscription: Subscription;\r\n\r\n  constructor(\r\n    readonly changeDetectorRef: ChangeDetectorRef,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly win: Window,\r\n  ) { }\r\n\r\n  ngOnInit(): void {\r\n    const smallBreakpoint$ = fromMediaQuery(this.win, '(min-width: 640px)');\r\n\r\n    this._smallBreakpointSubscription = smallBreakpoint$.subscribe(mqlEvent => {\r\n      this._isSmallScreen = !mqlEvent.matches;\r\n    });\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    if (this._smallBreakpointSubscription) {\r\n      this._smallBreakpointSubscription.unsubscribe();\r\n      this._smallBreakpointSubscription = null;\r\n    }\r\n  }\r\n}\r\n","<nav ngx-sticky class=\"navigation\">\r\n  <section class=\"container\">\r\n    <a href=\"https://github.com/enten/ngx-sticky\">\r\n      <h1>ngx-sticky</h1>\r\n    </a>\r\n  </section>\r\n</nav>\r\n\r\n<header class=\"header\">\r\n  <section class=\"features container text\">\r\n    <h2>Features</h2>\r\n    <ul>\r\n      <li>Stick all the things!</li>\r\n      <li>Super smooth!</li>\r\n      <li>Tested in real world projects</li>\r\n      <li>Support for <strong>Angular Universal</strong></li>\r\n      <li>Prevents page-jumping when switching to sticky mode</li>\r\n      <li>No jQuery or other dependencies - <strong>pure Angular</strong> solution</li>\r\n      <li>Support for boundaries to make elements stop.</li>\r\n    </ul>\r\n  </section>\r\n  <section class=\"installation container text\">\r\n    <h2>Installation</h2>\r\n    <p>with npm:</p>\r\n    <pre data-header=\"shell\" class=\"code\"><code>npm install @enten/ngx-sticky</code></pre>\r\n    <p>with yarn:</p>\r\n    <pre data-header=\"shell\" class=\"code\"><code>yarn add @enten/ngx-sticky</code></pre>\r\n    <p>Now import the <code>NgxStickyModule</code> in the corresponding Module</p>\r\n    <pre data-header=\"ts\" class=\"code\"><code><span class=\"ts-keyword\">import</span> <span class=\"ts-sign\">{{ '{' }}</span> <span class=\"ts-user-declaration\">NgxStickyModule</span> <span class=\"ts-sign\">{{ '}' }}</span> <span class=\"ts-keyword\">from</span> <span class=\"ts-sign\">'</span><span class=\"ts-string\">@enten/ngx-sticky</span><span class=\"ts-sign\">';</span>\r\n\r\n<span class=\"ts-decorator\">@NgModule</span><span class=\"ts-sign\">({{ '{' }}</span>\r\n  imports<span class=\"ts-sign\">: [</span>\r\n    <span class=\"ts-user-declaration\">NgxStickyModule</span><span class=\"ts-sign\">,</span> \r\n  <span class=\"ts-sign\">],</span> \r\n  declarations<span class=\"ts-sign\">: [],</span>\r\n  providers<span class=\"ts-sign\">: [],</span>\r\n<span class=\"ts-sign\">{{ '}' }})</span>\r\n<span class=\"ts-keyword\">export</span> <span class=\"ts-keyword\">class</span> <span class=\"ts-user-declaration\">SomeModule</span> <span class=\"ts-sign\">{{ '{ }' }}</span></code></pre>\r\n  </section>\r\n  <section class=\"usage container text\">\r\n    <h2>Usage</h2>\r\n    <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n  </section>\r\n  <section class=\"more container text\">\r\n    <h2>More</h2>\r\n    <div>\r\n      For more information see: <a href=\"https://github.com/enten/ngx-sticky\">https://github.com/enten/ngx-sticky</a>.\r\n    </div>\r\n  </section>\r\n</header>\r\n\r\n<section class=\"examples\">\r\n  <div class=\"container\">\r\n    <h2>Examples</h2>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">stickyDisabled</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [value]=\"exampleSticky1.disabled\" (change)=\"exampleSticky1.config$.nextKeyValue('disabled', $event.target.checked)\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/p&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <p ngx-sticky #exampleSticky1=\"ngxSticky\">\r\n            I am sticky!\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky inside boundary</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-attr\">stickyDisabled</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [value]=\"exampleStickyOutsideBoundary.disabled\" (change)=\"exampleStickyOutsideBoundary.config$.nextKeyValue('disabled', $event.target.checked)\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/p&gt;</span>\r\n\r\n<span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\r\n    Sticky inside boundary\r\n  <span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <p #exampleStickyOutsideBoundary=\"ngxSticky\" ngx-sticky>I am sticky!</p>\r\n          <div ngx-sticky-boundary style=\"margin: 5rem auto; height: 30rem; width: 80%;\">\r\n            <p ngx-sticky>Sticky inside boundary</p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky boundary unstacked</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span>\r\n  <span class=\"html-attr\">ngx-sticky-boundary</span>\r\n  <span class=\"html-attr\">stickyUnstacked</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [checked]=\"exampleBoundaryUnstacked.config.unstacked\" (change)=\"exampleBoundaryUnstacked.config$.nextKeyValue('unstacked', $event.target.checked)\"><span class=\"html-sign\">&quot;</span>\r\n<span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div class=\"preview\">\r\n          <div #exampleBoundaryUnstacked=\"ngxStickyBoundary\" ngx-sticky-boundary stickyUnstacked style=\"margin: 5rem auto; width: 80%;\">\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 1</p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 2</p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 3</p>\r\n            <div style=\"height: 5rem\"></div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky position bottom</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Sticky bottom direction up<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">down</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Sticky bottom direction down<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary offsetTop=\"0\" offsetBottom=\"200\" class=\"preview\">\r\n          <div style=\"height: 800px;\"></div>\r\n          <p ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">\r\n            Sticky bottom direction up\r\n          </p>\r\n          <p ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"down\">\r\n            Sticky bottom direction down\r\n          </p>\r\n          <div style=\"height: 800px;\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky container</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-container</span>\r\n  <span class=\"html-attr\">style</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">height: 400px; overflow: auto;</span><span class=\"html-sign\">&quot;</span>\r\n&gt;\r\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">top</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">down</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Header<span class=\"html-tag\">&lt;/header&gt;</span>\r\n  <span class=\"html-tag\">&lt;section</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;/section&gt;</span>\r\n  <span class=\"html-tag\">&lt;footer</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Footer<span class=\"html-tag\">&lt;/div&gt;</span>\r\n<span class=\"html-tag\">&lt;/footer&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-container class=\"preview\" style=\"position: relative; overflow: auto; height: 40rem\">\r\n          <header ngx-sticky>Header</header>\r\n          <div style=\"height: 12rem\"></div>\r\n          <section ngx-sticky-boundary style=\"position: relative;\">\r\n            <!-- <p ngx-sticky style=\"position: absolute; top: 50px; right: 50px; width: 50px; height: 50px; padding: 0; background: lightsteelblue;\">\r\n              Sticky\r\n            </p> -->\r\n            <div style=\"height: 10rem;\"></div>\r\n            <p ngx-sticky>Sticky 1</p>\r\n            <div style=\"height: 5rem;\"></div>\r\n            <p ngx-sticky>Sticky 2</p>\r\n            <div style=\"height: 5rem;\"></div>\r\n            <p ngx-sticky stickyPosition=\"bottom\">Sticky 3</p>\r\n            <div style=\"height: 10rem;\"></div>\r\n          </section>\r\n          <div style=\"height: 36rem\"></div>\r\n          <footer ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">Footer</footer>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example sticky-classes\">\r\n      <h3>Sticky classes</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">container</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">header</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>Header<span class=\"html-tag\">&lt;/header&gt;</span>\r\n  <span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">#headerSticky</span>\r\n    <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyClasses</span>\r\n    <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">header-sticky</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>\r\n    {{ '{{' }} headerSticky.className {{ '\\}\\}' }}\r\n  <span class=\"html-tag\">&lt;/div&gt;</span>\r\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span>\r\n\r\n<span class=\"html-tag\">&lt;style&gt;</span>\r\n.container {{ '{' }}\r\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">relative</span>;\r\n{{ '\\}' }}\r\n.header {{ '{' }}\r\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">relative</span>;\r\n  <span class=\"css-prop\">z-index</span>: <span class=\"css-user-value\">2</span>;\r\n{{ '\\}' }}\r\n.header-sticky {{ '{' }}\r\n  <span class=\"css-prop\">display</span>: <span class=\"css-value\">none</span>;\r\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">absolute</span>;\r\n  <span class=\"css-prop\">transform</span>: <span class=\"css-user-value\">translateY(-100%)</span>;\r\n  <span class=\"css-prop\">transition</span>: <span class=\"css-user-value\">transform 0.3s</span>;\r\n  <span class=\"css-prop\">width</span>: <span class=\"css-user-value\">100%</span>;\r\n  <span class=\"css-prop\">z-index</span>: <span class=\"css-user-value\">1</span>;\r\n{{ '\\}' }}\r\n.header-sticky:not(.ngx-sticky--disabled) {{ '{' }}\r\n  <span class=\"css-prop\">display</span>: <span class=\"css-value\">block</span>;\r\n{{ '\\}' }}\r\n.header-sticky:not(.ngx-sticky--normal) {{ '{' }}\r\n  <span class=\"css-prop\">transform</span>: <span class=\"css-user-value\">translateY(0%)</span>;\r\n{{ '\\}' }}\r\n<span class=\"html-tag\">&lt;/style&gt;</span>\r\n</code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <header style=\"padding: 2rem 1rem\">Header</header>\r\n          <div #exampleStickyClasses=\"ngxSticky\" ngx-sticky stickyClasses stickyDisabled=\"false\" class=\"header-sticky\">.ngx-sticky--{{ exampleStickyClasses.state }}</div>\r\n          <p></p>\r\n          <p></p>\r\n          <p></p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky with spot</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">[stickySpot]</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">spot</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n    Sticky with spot\r\n  <span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">[style.height.px]</span><span class=\"html-sign\">=&quot;</span><input #stickyWithSpotBlankHeight type=\"number\" value=\"1500\" class=\"html-attr-value\" style=\"width: 5rem;\" (change)=\"changeDetectorRef.detectChanges(); exampleStickyWithSpot.update()\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;/div&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">#spot</span><span class=\"html-tag\">&gt;</span>Spot<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <p #exampleStickyWithSpot=\"ngxSticky\" ngx-sticky [stickySpot]=\"spot\">Sticky with spot</p>\r\n          <div [style.height.px]=\"stickyWithSpotBlankHeight.value\"></div>\r\n          <div #spot style=\"padding: 2em 1em; background: lightblue;\">\r\n            Spot<br>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n</section>\r\n\r\n<section class=\"api\">\r\n  <div class=\"container\">\r\n    <h2>API</h2>\r\n\r\n    <div>\r\n      <h3>NgxStickyDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\" ngx-sticky-boundary>\r\n          <div ngx-sticky [stickyDisabled]=\"_isSmallScreen\">\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiSticky.disabled\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('disabled', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiSticky.config.position\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('position', $event.target.value)\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiSticky.config.direction\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('direction', $event.target.value)\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiSticky.config.orbit\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('orbit', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                outputs\r\n              </div>\r\n              <div>\r\n                <label>stickyState</label>\r\n                {{ apiSticky.state }}\r\n              </div>\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>enableSticky</label>\r\n                <button (click)=\"apiSticky.enableSticky()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>disableSticky</label>\r\n                <button (click)=\"apiSticky.disableSticky()\">call</button>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>update</label>\r\n                <button (click)=\"apiSticky.update()\">call</button>\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <div style=\"height: 15rem;\"></div>\r\n          <p #apiSticky=\"ngxSticky\" ngx-sticky>\r\n            I am sticky!\r\n          </p>\r\n          <div style=\"height: 15rem;\"></div>\r\n        </div>\r\n      </div>\r\n  \r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span *ngIf=\"apiSticky.disabled\" class=\"html-attr\"> stickyDisabled</span><!--<span *ngIf=\"apiSticky.config.orbit\" class=\"html-attr\"> stickyOrbit</span>--><ng-container *ngIf=\"apiSticky.config.position === 'bottom'\"><span class=\"html-attr\"> stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span></ng-container><ng-container *ngIf=\"apiSticky.config.direction === 'up'\"><span class=\"html-attr\"> stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span></ng-container><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/p&gt;</span></code></pre>\r\n    </div>\r\n\r\n    <div>\r\n      <h3>NgxStickyBoundaryDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\" ngx-sticky-boundary>\r\n          <div ngx-sticky [stickyDisabled]=\"_isSmallScreen\">\r\n            <div class=\"controls-header\">\r\n              ngx-sticky-boundary\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>stickyUnstacked</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiBoundary.config.unstacked\"\r\n                  (change)=\"apiBoundary.config$.nextKeyValue('unstacked', $event.target.checked)\"\r\n                >\r\n              </div>\r\n            </div>\r\n            <!--\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>updateStickies</label>\r\n                <button (click)=\"apiBoundary.updateStickies()\">call</button>\r\n              </div>\r\n            </div>\r\n            -->\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiBoundaryStickyDisabled\"\r\n                  (change)=\"apiBoundaryStickyDisabled = !apiBoundaryStickyDisabled\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiBoundaryStickyPosition\"\r\n                  (change)=\"apiBoundaryStickyPosition = $event.target.value\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiBoundaryStickyDirection\"\r\n                  (change)=\"apiBoundaryStickyDirection = $event.target.value\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"stickyOrbit\"\r\n                  (change)=\"stickyOrbit = !stickyOrbit\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div class=\"preview\">\r\n          <div style=\"height: 5rem;\"></div>\r\n          <div #apiBoundary=\"ngxStickyBoundary\" ngx-sticky-boundary>\r\n            <div style=\"height: 10rem;\"></div>\r\n            <p ngx-sticky\r\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\r\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\r\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\r\n            >\r\n              Sticky 1\r\n            </p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky\r\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\r\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\r\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\r\n            >\r\n              Sticky 2\r\n            </p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky\r\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\r\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\r\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\r\n            >\r\n              Sticky 3\r\n            </p>\r\n            <div style=\"height: 10rem;\"></div>\r\n          </div>\r\n          <div style=\"height: 5rem;\"></div>\r\n        </div>\r\n      </div>\r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span *ngIf=\"apiBoundary.config.unstacked\" class=\"html-attr\"> stickyUnstacked</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n    </div>\r\n\r\n    <div>\r\n      <h3>NgxStickyContainerDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\">\r\n          <div>\r\n            <div class=\"controls-header\">\r\n              ngx-sticky-container\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiContainer.disabled\"\r\n                  (change)=\"apiContainer.config$.nextKeyValue('disabled', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyOffsetTop</label>\r\n                <input type=\"number\"\r\n                  [value]=\"apiContainerStickyOffsetTop\"\r\n                  (change)=\"apiContainerStickyOffsetTop = +$event.target.value\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyOffsetBottom</label>\r\n                <input type=\"number\"\r\n                  [value]=\"apiContainerStickyOffsetBottom\"\r\n                  (change)=\"apiContainerStickyOffsetBottom = +$event.target.value\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyUnstacked</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiContainer.config.unstacked\"\r\n                  (change)=\"apiContainer.config$.nextKeyValue('unstacked', $event.target.checked)\"\r\n                >\r\n              </div>\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>enableStickies</label>\r\n                <button (click)=\"apiContainer.enableStickies()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>disableStickies</label>\r\n                <button (click)=\"apiContainer.disableStickies()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>scrollToTop</label>\r\n                <button (click)=\"apiContainer.scrollToTop('#apiContainerScrollTarget')\">call</button>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>updateStickies</label>\r\n                <button (click)=\"apiContainer.updateStickies()\">call</button>\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiContainerStickyDisabled\"\r\n                  (change)=\"apiContainerStickyDisabled = !apiContainerStickyDisabled\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiContainerStickyPosition\"\r\n                  (change)=\"apiContainerStickyPosition = $event.target.value\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiContainerStickyDirection\"\r\n                  (change)=\"apiContainerStickyDirection = $event.target.value\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"stickyOrbit\"\r\n                  (change)=\"stickyOrbit = !stickyOrbit\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div #apiContainer=\"ngxStickyContainer\" ngx-sticky-container\r\n          [stickyOffsetTop]=\"apiContainerStickyOffsetTop\"\r\n          [stickyOffsetBottom]=\"apiContainerStickyOffsetBottom\"\r\n          class=\"preview\"\r\n          style=\"position: relative; height: 40rem; overflow: auto;\"\r\n        >\r\n          <header ngx-sticky>\r\n            Header\r\n          </header>\r\n          <div style=\"height: 30rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\r\n            [stickyPosition]=\"apiContainerStickyPosition\"\r\n            [stickyDirection]=\"apiContainerStickyDirection\"\r\n          >\r\n            Sticky 1\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\r\n            [stickyPosition]=\"apiContainerStickyPosition\"\r\n            [stickyDirection]=\"apiContainerStickyDirection\"\r\n          >\r\n            Sticky 2\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\r\n            [stickyPosition]=\"apiContainerStickyPosition\"\r\n            [stickyDirection]=\"apiContainerStickyDirection\"\r\n          >\r\n            Sticky 3\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p id=\"apiContainerScrollTarget\" style=\"background: lightblue; opacity: 1;\">Scroll target</p>\r\n          <div style=\"height: 40rem;\"></div>\r\n          <footer ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">\r\n            Footer\r\n          </footer>\r\n        </div>\r\n      </div>\r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-container</span><span *ngIf=\"apiContainer.disabled\" class=\"html-attr\"> stickyDisabled</span><span *ngIf=\"apiContainer.config.unstacked\" class=\"html-attr\"> stickyUnstacked</span><ng-container *ngIf=\"apiContainerStickyOffsetTop\" ><span class=\"html-attr\"> stickyOffsetTop</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiContainerStickyOffsetTop }}</span><span class=\"html-sign\">&quot;</span></ng-container><ng-container *ngIf=\"apiContainerStickyOffsetBottom\"><span class=\"html-attr\"> stickyOffsetBottom</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiContainerStickyOffsetBottom }}</span><span class=\"html-sign\">&quot;</span></ng-container><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\r\n    Header\r\n  <span class=\"html-tag\">&lt;/header&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;footer</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span> <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n    Footer\r\n  <span class=\"html-tag\">&lt;/footer&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n    </div>\r\n\r\n    <div>\r\n      <h3>NgxInViewportDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\">\r\n          <div>\r\n            <div class=\"controls-header\">\r\n              ngx-in-viewport\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>intersectionDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiInViewport.disabled\"\r\n                  (change)=\"apiInViewport.config$.nextKeyValue('disabled', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>intersectionThresholds</label>\r\n                <input type=\"text\"\r\n                  [value]=\"apiInViewport.config.thresholds.join(',')\"\r\n                  (change)=\"apiInViewport.config$.nextKeyValue('thresholds', $event.target.value)\"\r\n                >\r\n              </div>\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>enableIntersection</label>\r\n                <button (click)=\"apiInViewport.enableIntersection()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>disableIntersection</label>\r\n                <button (click)=\"apiInViewport.disableIntersection()\">call</button>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>update</label>\r\n                <button (click)=\"apiInViewport.update()\">call</button>\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                outputs\r\n              </div>\r\n              <div>\r\n                <label>intersectionState</label>\r\n                {{ apiInViewport.state || 'null' }}\r\n              </div>\r\n              <div>\r\n                <label>intersectionThreshold</label>\r\n                {{ apiInViewport._intersectionThreshold }}\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>intersectionComputation</label>\r\n                <pre class=\"code\" style=\"margin: 0\"><code>{{ getIntersectionComputationAsText() }}</code></pre>\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiInViewportStickyDisabled\"\r\n                  (change)=\"apiInViewportStickyDisabled = !apiInViewportStickyDisabled\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiInViewportStickyPosition\"\r\n                  (change)=\"apiInViewportStickyPosition = $event.target.value\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiInViewportStickyDirection\"\r\n                  (change)=\"apiInViewportStickyDirection = $event.target.value\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiInViewportStickyOrbit\"\r\n                  (change)=\"apiInViewportStickyOrbit = !apiInViewportStickyOrbit\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div #container=\"ngxStickyContainer\" ngx-sticky-container class=\"preview\" style=\"position: relative; height: 40rem; overflow: auto;\">\r\n          <header ngx-sticky>\r\n            Header\r\n          </header>\r\n          <div style=\"height: 30rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\r\n            [stickyPosition]=\"apiInViewportStickyPosition\"\r\n            [stickyDirection]=\"apiInViewportStickyDirection\"\r\n          >\r\n            Sticky 1\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\r\n            [stickyPosition]=\"apiInViewportStickyPosition\"\r\n            [stickyDirection]=\"apiInViewportStickyDirection\"\r\n          >\r\n            Sticky 2\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p #apiInViewport=\"ngxInViewport\" ngx-in-viewport style=\"opacity: 1; padding: 8rem 1rem; background: lightblue; text-align: center\">\r\n            In viewport element\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\r\n            [stickyPosition]=\"apiInViewportStickyPosition\"\r\n            [stickyDirection]=\"apiInViewportStickyDirection\"\r\n          >\r\n            Sticky 3\r\n          </p>\r\n          <div style=\"height: 40rem;\"></div>\r\n          <footer ngx-sticky\r\n            stickyPosition=\"bottom\"\r\n            stickyDirection=\"up\"\r\n            style=\"margin-bottom: 0;\"\r\n          >\r\n            Footer\r\n          </footer>\r\n        </div>\r\n      </div>\r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-in-viewport</span><span *ngIf=\"apiInViewport.disabled\" class=\"html-attr\"> intersectionDisabled</span><span class=\"html-attr\"> intersectionThresholds</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiInViewport.config.thresholds.join(',') }}</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  in viewport element\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n    </div>\r\n  </div>\r\n</section>\r\n\r\n<footer class=\"footer\">\r\n  <p class=\"container\">made with  by <a href=\"http://enten.fr\">enten</a></p>\r\n</footer>\r\n  \r\n  ","import { NgModule } from '@angular/core';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\n\r\nimport { NgxStickyModule } from '../../projects/ngx-sticky/src/public-api';\r\n\r\nimport { AppRoutingModule } from './app-routing.module';\r\nimport { AppComponent } from './app.component';\r\n\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    AppRoutingModule,\r\n    NgxStickyModule,\r\n  ],\r\n  providers: [],\r\n  bootstrap: [ AppComponent ],\r\n})\r\nexport class AppModule { }\r\n","export const environment = {\r\n  production: true,\r\n};\r\n","import { enableProdMode } from '@angular/core';\r\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n\r\nimport { AppModule } from './app/app.module';\r\nimport { environment } from './environments/environment';\r\n\r\nif (environment.production) {\r\n  enableProdMode();\r\n}\r\n\r\nplatformBrowserDynamic().bootstrapModule(AppModule)\r\n  .catch(err => console.error(err));\r\n"]}