{"version":3,"mappings":"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","names":["a","t","C","e","y","c","n","m","r","u","i","exports","disabled","aliasKey","defaultValue","coercion","coercion_1","thresholds","intersection_1","g","constructor","rootContainer","stickyContainer","elementRef","ngZone","_win","this","core_1","config_subject_1","rxjs_1","_container","container","registerIntersection","config$","getValue","config","_intersectionState","ngOnChanges","changes","nextChanges","ngAfterViewInit","_initMonitoring","ngOnDestroy","unregisterIntersection","_destroyed$","isStopped","next","complete","_destroyMonitoring","beforeRefresh","fastUpdate","_intersection","disableIntersection","nextKeyValue","skipCoercion","enableIntersection","getIntersection","_computeIntersection","refresh","computation","_refresh$","update","updateStickies","elementRect","dom_1","nativeElement","height","top","_createMonitoringObservable","pipe","operators_1","_monitoring","unsubscribe","runOutsideAngular","handleRefreshSubscription","leading","trailing","subscribe","_refreshIntersection","triggerUpdateSubscription","add","_intersectionComputation","intersectionComputation","state","run","intersectionState","oldEntry","_intersectionCrossed","newEntry","oldRatio","ratio","newRatio","crossedThreshold","snap","intersection","isNaN","_intersectionThreshold","intersectionThreshold","emit","NgxInViewportDirective","i0","sticky_container_directive_1","sticky_tokens_1","selectors","disableAllStickies","disableStickies","containers","enableAllStickies","enableStickies","getStickedOffset","position","viewportTop","getContainer","viewportHeight","getViewportHeight","stickies","stickyController","_step3","push","getSticky","stickyEngine","fixViewportTop","userOffsetTop","viewportTopOffsetless","viewportTopFixed","containerParent","registerContainer","containerController","collections_1","registerBoundary","boundaryController","boundaries","intersectionController","intersectionIndex","intersections","_intersectionSnaps","_intersectionComputations","registerSticky","stickyIndex","_stickySnaps","_stickyComputations","updateAllStickies","length","getViewportTop","stickyComputation","stickySnap","_stickyController","_step6","snapSticky","determineStickyState","intersectionSnap","_step7","snapIntersection","determineIntersectionState","unregisterContainer","unregisterBoundary","boundary","unregisterSticky","sticky","offsetTop","offsetBottom","unstacked","super","_getDocumentHeight","_getDocumentWidth","destroyed$","createScrollPlan","target","scrollPlan","targetContainer","targetContainerScrollPlan","scrollToFn","element","scrollTo","bind","containsElement","elementAsNumber","parseFloat","querySelector","document","elementTop","scrollToOptions","left","getViewportLeft","tagName","contains","_step8","containerScrollPlan","targetLine","targetTopFixed","_computeContainer","scrollToTop","scrollStep","_step9","_updateStickies$","containerRect","scrollHeight","width","scrollWidth","_createMonitoringInputsObservable","_createMonitoringScrollObservable","_createMonitoringWindowObservable","passive","_updateStickies","sticky_base_container_controller_1","NgxStickyBaseContainerDirective","inputs","d","ngOnInit","_boundary","getBoundary","_computeBoundary","boundaryStyle","getComputedStyle","paddingTop","paddingBottom","sticky_base_boundary_controller_1","NgxStickyBoundaryDirective","stickyContainerParent","offsetHeight","scrollLeft","scrollTop","sticky_base_container_directive_1","NgxStickyContainerDirective","computeStickyBoundary","directionDown","spot","boundaryHeight","_ref","boundaryTop","boundaryLeft","boundaryWidth","spotPoint","computeStickyStickedLine","positionBottom","stickedTop","stickedHeight","computeStickySortPoint","enter","exit","stateKey","join","maxHeightVisible","Math","min","offsetSticked","intersecting","S","_stickyComputedState","offsetStucked","stickyComputed","_stickyComputed","_step10","boundaryOffset","_i$sticked","sticked","_stickedTop","_stickedHeight","sticky_helpers_1","maxStickyUnstackedHeight","stickedOffset","_sticky","_step11","_elementHeight","exitSticky","direction","boundariesMap","sortPoint","offsetSpacer","stickiesComputed","stickyComputedBoundaryRight","_stickyIndex","_directionDown","_positionBottom","_stickyComputedBoundaryRight","p","boundaryKey","l","f","sort","b","NgxStickyEngine","factory","fac","NgxStickyRootContainerController","_stickySpotHeight","set","value","utils_1","NgxStickySpotDirective","s","classes","spacer","spotHeight","E","stickyBoundary","stickyParent","renderer","cssClassSticky","cssClassStickySticked","cssClassStickyStucked","cssClassStickyDisabled","_stickyState","_preventNestedStickyError","disableSticky","enableSticky","_computeSticky","_refreshStickyElement","spotRect","from_image_events_1","_getStickyElementStyle","win","ghost","_spacerGenerated","ghostParent","offsetParent","ghostParentIsRootElement","body","documentElement","ghostRelativeRect","ghostStyle","elementWidth","boxSizing","borderLeft","borderRight","paddingLeft","paddingRight","elementLeft","ghostRect","offsetLeft","right","bottom","float","margin","_f$snap","ghostParentRect","_getStickyGhostStyle","elementStyle","ghostHeight","borderTopWidth","borderBottomWidth","style","maxHeight","minHeight","borderTop","borderBottom","cssFloat","marginTop","marginBottom","marginLeft","marginRight","_hideStickyGhost","setStyle","_refreshSticky","_insertStickyGhostGenerated","createElement","addClass","insertBefore","parentElement","nestedStickyError","Error","logLevel","logLevelLogger","console","_stickyElementState","_stickyComputation","stickyState","_restoreStickyElementStyle","_saveStickyElementStyle","_showStickyGhost","_refreshStickyGhost","_elementOriginStyle","remove","display","sticky_base_controller_1","NgxStickyDirective","sticky_boundary_directive_1","isStickyPositionBottom","isStickyDirectionDown","_n$snap$stickyCompute","elementHeight","NgxStickyModule","common_1","providedIn","window","Number","fallbackValue","arguments","_isNumberValue","entry","entryIndex","indexOf","splice","schema","_config","_configChanges","_aliases","inputKeys","Object","keys","inputKey","inputOptions","input","input_subject_1","pushChangeSubscription","change$","inputChange","_configChanged","currentValue","_pushChangesSubscription","_i5","_loop","getKeyValue","partialConfig","options","_i6","key","changes$","_i7","documentHeightGetters","clientHeight","documentHeightGetter","documentHeight","_i8","_documentHeightGetter","_documentHeight","documentWidthGetters","offsetWidth","clientWidth","documentWidthGetter","documentWidth","_i9","_documentWidthGetter","_documentWidth","rect","currentElement","currentElementStyle","innerHeight","documentRect","getBoundingClientRect","scrollX","scrollY","overflowY","styles","_i10","prop","removeStyle","images$","addImage","event","querySelectorAll","forEach","query","matchMedia","mql","initEvent","matches","media","initMqlEvent","MediaQueryListEvent","type","mql$","onQueryChange","mqlEvent","call","removeListener","addListener","tslib_1","_value","_valueSetted","firstChange","_firstChange","previousValue","split","map","x","Array","isArray","_toConsumableArray","threshold","_step12","AppRoutingModule","router_1","forRoot","changeDetectorRef","smallBreakpoint$","public_api_1","_smallBreakpointSubscription","_isSmallScreen","AppComponent","_r0","$event","_r1","_r2","ctx","_r5","_r7","_r11","_r13","reference","_r19","AppModule","bootstrap","app_component_1","imports","platform_browser_1","app_routing_module_1","production","environment_1","__NgCli_bootstrap_1","bootstrapModule","app_module_1","err","error"],"sources":["webpack:///$_lazy_route_resources|lazy|groupOptions:%20%7B%7D|namespace%20object","webpack:///projects/ngx-sticky/src/lib/in-viewport.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base-boundary.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base-container.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base-container.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-base.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-boundary.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-container.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky-engine.ts","webpack:///projects/ngx-sticky/src/lib/sticky-root-container.controller.ts","webpack:///projects/ngx-sticky/src/lib/sticky-spot.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky.directive.ts","webpack:///projects/ngx-sticky/src/lib/sticky.helpers.ts","webpack:///projects/ngx-sticky/src/lib/sticky.module.ts","webpack:///projects/ngx-sticky/src/lib/sticky.tokens.ts","webpack:///projects/ngx-sticky/src/lib/utils/coercion.ts","webpack:///projects/ngx-sticky/src/lib/utils/collections.ts","webpack:///projects/ngx-sticky/src/lib/utils/config-subject.ts","webpack:///projects/ngx-sticky/src/lib/utils/dom.ts","webpack:///projects/ngx-sticky/src/lib/utils/from-image-events.ts","webpack:///projects/ngx-sticky/src/lib/utils/from-media-query.ts","webpack:///projects/ngx-sticky/src/lib/utils/index.ts","webpack:///projects/ngx-sticky/src/lib/utils/input-subject.ts","webpack:///projects/ngx-sticky/src/lib/utils/intersection.ts","webpack:///projects/ngx-sticky/src/public-api.ts","webpack:///src/app/app-routing.module.ts","webpack:///src/app/app.component.ts","webpack:///src/app/app.component.html","webpack:///src/app/app.module.ts","webpack:///src/environments/environment.prod.ts","webpack:///src/main.ts"],"sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 8255;\nmodule.exports = webpackEmptyAsyncContext;","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnChanges,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  SimpleChanges,\r\n  forwardRef,\r\n} from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\r\nimport { distinctUntilChanged, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport {\r\n  NgxIntersection,\r\n  NgxIntersectionComputation,\r\n  NgxIntersectionController,\r\n  NgxIntersectionState,\r\n  NgxStickyContainerController,\r\n} from './sticky.types';\r\nimport { coerceBooleanProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport { getElementAbsoluteRect } from './utils/dom';\r\nimport { coerceIntersectionThresholds, getCrossedThreshold } from './utils/intersection';\r\n\r\n\r\nexport interface NgxIntersectionConfig {\r\n  disabled: boolean;\r\n  thresholds: number[];\r\n}\r\n\r\n\r\nexport const NGX_BASE_INTERSECTION_CONFIG_SCHEMA: ConfigSubjectSchema<NgxIntersectionConfig> = {\r\n  disabled: {\r\n    aliasKey: 'intersectionDisabled',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  thresholds: {\r\n    aliasKey: 'intersectionThresholds',\r\n    defaultValue: [ 0, 1 ],\r\n    coercion: coerceIntersectionThresholds,\r\n  },\r\n};\r\n\r\n\r\n@Directive({\r\n  selector: '[ngxInViewport], [ngx-in-viewport], ngx-in-viewport',\r\n  exportAs: 'ngxInViewport',\r\n})\r\nexport class NgxInViewportDirective implements NgxIntersectionController, AfterViewInit, OnChanges, OnDestroy {\r\n  /**\r\n   * Disable intersection.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  intersectionDisabled: boolean;\r\n\r\n  /**\r\n   * Intersection thresholds.\r\n   *\r\n   * Defaults to `[ 0, 1 ]`.\r\n   */\r\n  @Input()\r\n  intersectionThresholds: number[];\r\n\r\n  /**\r\n   * Emit intersection.\r\n   */\r\n  @Output()\r\n  readonly intersection = new EventEmitter<NgxIntersectionComputation>();\r\n\r\n  /**\r\n   * Emit intersection computation.\r\n   */\r\n  @Output()\r\n  readonly intersectionComputation = new EventEmitter<NgxIntersectionComputation>();\r\n\r\n  /**\r\n   * Emit intersection state.\r\n   */\r\n  @Output()\r\n  readonly intersectionState = new EventEmitter<NgxIntersectionState>();\r\n\r\n  /**\r\n   * Emit intersection threshold.\r\n   */\r\n  @Output()\r\n  readonly intersectionThreshold = new EventEmitter<number>();\r\n\r\n  get container(): NgxStickyContainerController {\r\n    return this._container;\r\n  }\r\n\r\n  get config(): NgxIntersectionConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.config.disabled;\r\n  }\r\n\r\n  /**\r\n   * State of the intersection.\r\n   */\r\n  get state(): NgxIntersectionState {\r\n    return this._intersectionState;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject<NgxIntersectionConfig>(NGX_BASE_INTERSECTION_CONFIG_SCHEMA);\r\n\r\n  /** Intersection container controller */\r\n  readonly _container: NgxStickyBaseContainerDirective;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  readonly _destroyed$ = new Subject<void>();\r\n\r\n  /** Intersection which reflect last call of _computeIntersection() */\r\n  _intersection: NgxIntersection;\r\n\r\n  /** Intersection computation which reflect last call of _refreshIntersection()  */\r\n  _intersectionComputation: NgxIntersectionComputation;\r\n\r\n  /** Intersection computation with last threshold crossed */\r\n  _intersectionCrossed: NgxIntersectionComputation;\r\n\r\n  /** Last inetersection state crossed */\r\n  _intersectionState: NgxIntersectionState;\r\n\r\n  /** Last inetersection threshold crossed */\r\n  _intersectionThreshold: number;\r\n\r\n  /** Monitoring subscription which trigger update stickies and handle refresh */\r\n  _monitoring: Subscription;\r\n\r\n  /** Emits when refresh() is called */\r\n  readonly _refresh$ = new Subject<NgxIntersectionComputation>();\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainer: NgxStickyContainerDirective,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    // use root container when sticky isn't in container\r\n    this._container = stickyContainer || rootContainer;\r\n\r\n    // register in parent container for first update calls\r\n    this.container.registerIntersection(this);\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    this._initMonitoring();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.container.unregisterIntersection(this);\r\n\r\n    if (!this._destroyed$.isStopped) {\r\n      this._destroyed$.next();\r\n      this._destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._intersection = null;\r\n    }\r\n  }\r\n\r\n  disableIntersection(): void {\r\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\r\n  }\r\n\r\n  enableIntersection(): void {\r\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\r\n  }\r\n\r\n  getIntersection(): NgxIntersection {\r\n    if (!this._intersection) {\r\n      this._intersection = this._computeIntersection();\r\n    }\r\n\r\n    return this._intersection;\r\n  }\r\n\r\n  refresh(computation: NgxIntersectionComputation): void {\r\n    this._refresh$.next(computation);\r\n  }\r\n\r\n  update(fastUpdate?: boolean): void {\r\n    this.container.updateStickies(fastUpdate);\r\n  }\r\n\r\n  _computeIntersection(): NgxIntersection {\r\n    const config = this.config$.getValue();\r\n\r\n    const elementRect = getElementAbsoluteRect(this.elementRef.nativeElement);\r\n\r\n    return {\r\n      disabled: config.disabled,\r\n      height: elementRect.height,\r\n      top: elementRect.top,\r\n      thresholds: config.thresholds,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create intersection monitoring observable.\r\n   */\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    return merge(\r\n      this.config$,\r\n      animationFrameScheduler,\r\n    ).pipe(\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy intersection monitoring subscription.\r\n   */\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Init intersection monitoring.\r\n   */\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      const handleRefreshSubscription = this._refresh$\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          distinctUntilChanged(),\r\n          throttleTime(0, animationFrameScheduler, { leading: true, trailing: true }),\r\n          share(),\r\n        )\r\n        .subscribe(computation => {\r\n          this._refreshIntersection(computation);\r\n        });\r\n\r\n      const triggerUpdateSubscription = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this.update(fastUpdate);\r\n        });\r\n\r\n      this._monitoring = new Subscription();\r\n      this._monitoring.add(handleRefreshSubscription);\r\n      this._monitoring.add(triggerUpdateSubscription);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refresh intersection with given computation.\r\n   *\r\n   * @param computation Intersection state computation\r\n   */\r\n  _refreshIntersection(computation: NgxIntersectionComputation): void {\r\n    this._intersectionComputation = computation;\r\n    this.intersectionComputation.next(computation);\r\n\r\n    if (computation.state !== this._intersectionState) {\r\n      this.ngZone.run(() => {\r\n        this._intersectionState = computation.state;\r\n        this.intersectionState.next(computation.state);\r\n      });\r\n    }\r\n\r\n    const oldEntry = this._intersectionCrossed;\r\n    const newEntry = computation;\r\n\r\n    const oldRatio = oldEntry ? oldEntry.ratio : 0;\r\n    const newRatio = newEntry.ratio;\r\n\r\n    // ignore when ratios are unchanged\r\n    if (oldEntry && oldRatio === newRatio) {\r\n      return;\r\n    }\r\n\r\n    const crossedThreshold = getCrossedThreshold(computation.snap.intersection.thresholds, oldRatio, newRatio);\r\n\r\n    // ignore when no treshold is crossed\r\n    if (isNaN(crossedThreshold)) {\r\n      return;\r\n    }\r\n\r\n    this._intersectionCrossed = newEntry;\r\n\r\n    this.ngZone.run(() => {\r\n      this._intersectionThreshold = crossedThreshold;\r\n      this.intersectionThreshold.next(crossedThreshold);\r\n\r\n      this.intersection.emit(newEntry);\r\n    });\r\n  }\r\n}\r\n","import {\r\n  NgxStickyBoundary,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyContainerController,\r\n} from './sticky.types';\r\n\r\n\r\n/**\r\n * Abstract sticky boundary controller.\r\n */\r\nexport abstract class NgxStickyBaseBoundaryController implements NgxStickyBoundaryController {\r\n  abstract readonly container: NgxStickyContainerController;\r\n\r\n  abstract beforeRefresh(fastUpdate?: boolean): void;\r\n  abstract getBoundary(): NgxStickyBoundary;\r\n\r\n  updateStickies(fastUpdate?: boolean) {\r\n    this.container.updateStickies(fastUpdate);\r\n  }\r\n}\r\n","import { NgxStickyEngine } from './sticky-engine';\r\nimport {\r\n  NgxIntersectionComputation,\r\n  NgxIntersectionController,\r\n  NgxIntersectionSnap,\r\n  NgxScrollPlan,\r\n  NgxSticky,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyComputation,\r\n  NgxStickyContainer,\r\n  NgxStickyContainerController,\r\n  NgxStickyController,\r\n  NgxStickyPosition,\r\n  NgxStickySnap,\r\n} from './sticky.types';\r\nimport { addEntry, deleteEntry } from './utils/collections';\r\n\r\n\r\n/**\r\n * Abstract sticky container controller.\r\n */\r\nexport abstract class NgxStickyBaseContainerController implements NgxStickyContainerController {\r\n  abstract readonly containerParent?: NgxStickyContainerController;\r\n  abstract readonly stickyEngine: NgxStickyEngine;\r\n\r\n  abstract disabled: boolean;\r\n\r\n  readonly boundaries: NgxStickyBoundaryController[] = [];\r\n  readonly containers: NgxStickyContainerController[] = [];\r\n  readonly intersections: NgxIntersectionController[] = [];\r\n  readonly stickies: NgxStickyController[] = [];\r\n\r\n  readonly _stickyComputations: Record<number, NgxStickyComputation> = {};\r\n  readonly _stickySnaps: Record<number, NgxStickySnap> = {};\r\n  _stickySnapContainerHeight: number;\r\n\r\n  readonly _intersectionComputations: Record<number, NgxIntersectionComputation> = {};\r\n  readonly _intersectionSnaps: Record<number, NgxIntersectionSnap> = {};\r\n\r\n  abstract beforeRefresh(fastUpdate?: boolean): void;\r\n  abstract createScrollPlan(element: number | string | HTMLElement, userOffsetTop?: number): NgxScrollPlan;\r\n  abstract disableStickies(): void;\r\n  abstract enableStickies(): void;\r\n  abstract getContainer(): NgxStickyContainer;\r\n  abstract getViewportHeight(): number;\r\n  abstract getViewportLeft(): number;\r\n  abstract getViewportTop(): number;\r\n  abstract scrollToTop(target: number | string | HTMLElement, userOffsetTop?: number): void;\r\n\r\n  abstract _computeContainer(): NgxStickyContainer;\r\n\r\n  disableAllStickies(): void {\r\n    this.disableStickies();\r\n\r\n    for (const container of this.containers) {\r\n      container.disableStickies();\r\n    }\r\n  }\r\n\r\n  enableAllStickies(): void {\r\n    this.enableStickies();\r\n\r\n    for (const container of this.containers) {\r\n      container.enableStickies();\r\n    }\r\n  }\r\n\r\n  getStickedOffset(position: NgxStickyPosition, viewportTop: number): number {\r\n    const container = this.getContainer();\r\n    const viewportHeight = this.getViewportHeight();\r\n    const stickies: NgxSticky[] = [];\r\n\r\n    for (const stickyController of this.stickies) {\r\n      stickies.push(stickyController.getSticky());\r\n    }\r\n\r\n    return this.stickyEngine.getStickedOffset(container, stickies, position, viewportHeight, viewportTop);\r\n  }\r\n\r\n  fixViewportTop(viewportTop: number, userOffsetTop?: number): number {\r\n    // const container = this.getContainer();\r\n    const viewportTopOffsetless = viewportTop - (userOffsetTop || 0);\r\n    const stickedOffsetTop = this.getStickedOffset('top', viewportTopOffsetless);\r\n\r\n    let viewportTopFixed = viewportTopOffsetless /* - container.offsetTop*/ - stickedOffsetTop;\r\n\r\n    if (this.containerParent) {\r\n      viewportTopFixed -= this.getContainer().top;\r\n    }\r\n\r\n    return viewportTopFixed;\r\n  }\r\n\r\n  registerContainer(containerController: NgxStickyContainerController): void {\r\n    addEntry(this.containers, containerController);\r\n  }\r\n\r\n  registerBoundary(boundaryController: NgxStickyBoundaryController): void {\r\n    addEntry(this.boundaries, boundaryController);\r\n  }\r\n\r\n  registerIntersection(intersectionController: NgxIntersectionController): void {\r\n    const intersectionIndex = addEntry(this.intersections, intersectionController);\r\n\r\n    if (intersectionIndex !== -1) {\r\n      this._intersectionSnaps[intersectionIndex] = null;\r\n      this._intersectionComputations[intersectionIndex] = null;\r\n    }\r\n  }\r\n\r\n  registerSticky(stickyController: NgxStickyController): void {\r\n    const stickyIndex = addEntry(this.stickies, stickyController);\r\n\r\n    if (stickyIndex !== -1) {\r\n      this._stickySnaps[stickyIndex] = null;\r\n      this._stickyComputations[stickyIndex] = null;\r\n    }\r\n  }\r\n\r\n  updateAllStickies(fastUpdate?: boolean): void {\r\n    this.updateStickies(fastUpdate);\r\n\r\n    for (const containerController of this.containers) {\r\n      containerController.updateAllStickies(fastUpdate);\r\n    }\r\n  }\r\n\r\n  updateStickies(fastUpdate?: boolean): void {\r\n    // // avoid update when there is no stickies\r\n    // if (!this.stickies.length) {\r\n    //   return;\r\n    // }\r\n\r\n    // // force full update when container size change\r\n    // if (this.getContainerHeight() !== this._stickySnapContainerHeight) {\r\n    //   fastUpdate = false;\r\n    // }\r\n\r\n    if (!fastUpdate) {\r\n      this.beforeRefresh(fastUpdate);\r\n\r\n      for (const boundaryController of this.boundaries) {\r\n        boundaryController.beforeRefresh(fastUpdate);\r\n      }\r\n\r\n      for (let stickyIndex = 0; stickyIndex < this.stickies.length; ++stickyIndex) {\r\n        this._stickyComputations[stickyIndex] = null;\r\n        this._stickySnaps[stickyIndex] = null;\r\n\r\n        this.stickies[stickyIndex].beforeRefresh(fastUpdate);\r\n      }\r\n\r\n      for (let intersectionIndex = 0; intersectionIndex < this.intersections.length; ++intersectionIndex) {\r\n        this._intersectionComputations[intersectionIndex] = null;\r\n        this._intersectionSnaps[intersectionIndex] = null;\r\n\r\n        this.intersections[intersectionIndex].beforeRefresh(fastUpdate);\r\n      }\r\n    }\r\n\r\n    //   // legacy code\r\n    //   const viewportHeight = this.getViewportHeight() - this.stickyOffsetTop - this.stickyOffsetBottom;\r\n    //   const viewportTop = this.getViewportTop() + this.getContainer().top + this.stickyOffsetTop;\r\n\r\n    const container = this.getContainer();\r\n    const viewportHeight = this.getViewportHeight();\r\n    // compute absolute viewport top\r\n    const viewportTop = this.getViewportTop() + this.getContainer().top;\r\n    let stickies: NgxSticky[];\r\n\r\n    // refresh stickies\r\n    for (let stickyIndex = 0; stickyIndex < this.stickies.length; ++stickyIndex) {\r\n      const stickyController = this.stickies[stickyIndex];\r\n      let stickyComputation = this._stickyComputations[stickyIndex];\r\n\r\n      if (!stickyComputation || stickyComputation.viewportTop !== viewportTop) {\r\n        let stickySnap = this._stickySnaps[stickyIndex];\r\n\r\n        if (!stickySnap) {\r\n          if (!stickies) {\r\n            stickies = [];\r\n            for (const _stickyController of this.stickies) {\r\n              stickies.push(_stickyController.getSticky());\r\n            }\r\n          }\r\n\r\n          stickySnap = this.stickyEngine.snapSticky(container, stickies, stickies[stickyIndex], viewportHeight);\r\n\r\n          this._stickySnaps[stickyIndex] = stickySnap;\r\n        }\r\n\r\n        stickyComputation = this.stickyEngine.determineStickyState(stickySnap, viewportTop);\r\n\r\n        this._stickyComputations[stickyIndex] = stickyComputation;\r\n      }\r\n\r\n      stickyController.refresh(stickyComputation);\r\n    }\r\n\r\n    // refresh intersections\r\n    for (let intersectionIndex = 0; intersectionIndex < this.intersections.length; ++intersectionIndex) {\r\n      const intersectionController = this.intersections[intersectionIndex];\r\n      let intersectionComputation = this._intersectionComputations[intersectionIndex];\r\n\r\n      if (!intersectionComputation || intersectionComputation.viewportTop !== viewportTop) {\r\n        let intersectionSnap = this._intersectionSnaps[intersectionIndex];\r\n\r\n        if (!intersectionSnap) {\r\n          if (!stickies) {\r\n            stickies = [];\r\n            for (const _stickyController of this.stickies) {\r\n              stickies.push(_stickyController.getSticky());\r\n            }\r\n          }\r\n\r\n          const intersection = intersectionController.getIntersection();\r\n\r\n          intersectionSnap = this.stickyEngine.snapIntersection(container, stickies, intersection, viewportHeight);\r\n\r\n          this._intersectionSnaps[intersectionIndex] = intersectionSnap;\r\n        }\r\n\r\n        intersectionComputation = this.stickyEngine.determineIntersectionState(intersectionSnap, viewportTop);\r\n\r\n        this._intersectionComputations[intersectionIndex] = intersectionComputation;\r\n      }\r\n\r\n      intersectionController.refresh(intersectionComputation);\r\n    }\r\n  }\r\n\r\n  unregisterContainer(container: NgxStickyContainerController): void {\r\n    deleteEntry(this.containers, container);\r\n  }\r\n\r\n  unregisterBoundary(boundary: NgxStickyBoundaryController): void {\r\n    deleteEntry(this.boundaries, boundary);\r\n  }\r\n\r\n  unregisterIntersection(intersectionController: NgxIntersectionController): void {\r\n    const intersectionIndex = deleteEntry(this.intersections, intersectionController);\r\n\r\n    if (intersectionIndex !== -1) {\r\n      this._intersectionSnaps[intersectionIndex] = null;\r\n      this._intersectionComputations[intersectionIndex] = null;\r\n    }\r\n  }\r\n\r\n  unregisterSticky(sticky: NgxStickyController): void {\r\n    const stickyIndex = deleteEntry(this.stickies, sticky);\r\n\r\n    if (stickyIndex !== -1) {\r\n      this._stickySnaps[stickyIndex] = null;\r\n      this._stickyComputations[stickyIndex] = null;\r\n    }\r\n  }\r\n}\r\n","import { Directive, Input, NgZone, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, fromEvent, merge, of } from 'rxjs';\r\nimport { debounceTime, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseContainerController } from './sticky-base-container.controller';\r\nimport { NgxStickyEngine } from './sticky-engine';\r\nimport { NgxScrollPlan, NgxStickyContainer, NgxStickyContainerController, NgxStickyController } from './sticky.types';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport {\r\n  getDocumentHeightFactory,\r\n  getDocumentWidthFactory,\r\n  getElementAbsoluteRect,\r\n  getWindowViewportHeight,\r\n  getWindowViewportLeft,\r\n  getWindowViewportTop,\r\n  isElementScrollableY,\r\n} from './utils/dom';\r\n\r\n\r\nexport interface NgxStickyContainerConfig {\r\n  disabled: boolean;\r\n  offsetTop: number;\r\n  offsetBottom: number;\r\n  unstacked: boolean;\r\n}\r\n\r\n\r\nexport const NGX_STICKY_BASE_CONTAINER_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyContainerConfig> = {\r\n  disabled: {\r\n    aliasKey: 'stickyDisabled',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  offsetTop: {\r\n    aliasKey: 'stickyOffsetTop',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n  offsetBottom: {\r\n    aliasKey: 'stickyOffsetBottom',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n  unstacked: {\r\n    aliasKey: 'stickyUnstacked',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n};\r\n\r\n\r\n/**\r\n * Abstract sticky container directive.\r\n */\r\n@Directive()\r\nexport abstract class NgxStickyBaseContainerDirective extends NgxStickyBaseContainerController implements OnChanges, OnDestroy {\r\n  /**\r\n   * Returns HTMLElement of the container or `null` in case of root container.\r\n   */\r\n  abstract readonly element: HTMLElement;\r\n\r\n  /**\r\n   * Disable sticky. container.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyDisabled: boolean;\r\n\r\n  /**\r\n   * Defines offset bottom inside the sticky container.\r\n   */\r\n  @Input()\r\n  stickyOffsetBottom: (element: HTMLElement) => number;\r\n\r\n  /**\r\n   * Defines offset top inside the sticky container.\r\n   */\r\n  @Input()\r\n  stickyOffsetTop: (element: HTMLElement) => number;\r\n\r\n  /**\r\n   * Enable/disable sticky stack inside container.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyUnstacked: boolean;\r\n\r\n  get config(): NgxStickyContainerConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.config.disabled;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject(NGX_STICKY_BASE_CONTAINER_CONFIG_SCHEMA);\r\n\r\n  /** Container which reflect last call of _computeContainer() */\r\n  _container: NgxStickyContainer;\r\n\r\n  /** Emits when the service is destroyed. */\r\n  readonly destroyed$ = new Subject<void>();\r\n\r\n  /** Monitoring subscription which trigger update stickies */\r\n  _monitoring: Subscription;\r\n\r\n  /** Emits when updateStickies() is called */\r\n  _updateStickies$ = new Subject<boolean>();\r\n\r\n  /** Getter for document height */\r\n  readonly _getDocumentHeight: () => number;\r\n  /** Getter for document width */\r\n  readonly _getDocumentWidth: () => number;\r\n\r\n  constructor(\r\n    readonly containerParent: NgxStickyContainerController,\r\n    readonly stickyEngine: NgxStickyEngine,\r\n    readonly ngZone: NgZone,\r\n    readonly _win: Window,\r\n  ) {\r\n    super();\r\n\r\n    if (this.containerParent) {\r\n      this.containerParent.registerContainer(this);\r\n    }\r\n\r\n    this._getDocumentHeight = getDocumentHeightFactory(this._win);\r\n    this._getDocumentWidth = getDocumentWidthFactory(this._win);\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    if (this.containerParent) {\r\n      this.containerParent.unregisterContainer(this);\r\n    }\r\n\r\n    if (!this.destroyed$.isStopped) {\r\n      this.destroyed$.next();\r\n      this.destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._container = null;\r\n    }\r\n  }\r\n\r\n  createScrollPlan(target: number | string | HTMLElement, userOffsetTop?: number): NgxScrollPlan {\r\n    const scrollPlan: NgxScrollPlan = [];\r\n\r\n    if (!this._win) {\r\n      return scrollPlan;\r\n    }\r\n\r\n    const scrollToFn = this.element\r\n      ? this.element.scrollTo.bind(this.element)\r\n      : this._win.scrollTo.bind(this._win);\r\n\r\n    let containsElement = false;\r\n\r\n    if (typeof target === 'string') {\r\n      const elementAsNumber = parseFloat(target as string);\r\n\r\n      if (!isNaN(elementAsNumber)) {\r\n        target = elementAsNumber;\r\n      } else {\r\n        if (this.element) {\r\n          target = this.element.querySelector<HTMLElement>(target);\r\n        } else {\r\n          target = this._win.document.querySelector<HTMLElement>(target);\r\n        }\r\n\r\n        if (target) {\r\n          containsElement = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof target === 'number' && !isNaN(target)) {\r\n      const elementTop = this.fixViewportTop(target, userOffsetTop);\r\n\r\n      scrollPlan.push({\r\n        scrollToOptions: { left: this.getViewportLeft(), top: elementTop },\r\n        scrollToFn,\r\n      });\r\n\r\n      return scrollPlan;\r\n    }\r\n\r\n    // if (!target || !(target instanceof HTMLElement)) {\r\n    if (!target || !((target as HTMLElement).tagName)) {\r\n      return scrollPlan;\r\n    }\r\n\r\n    containsElement = containsElement || !this.element || this.element.contains(target as HTMLElement);\r\n\r\n    if (!containsElement) {\r\n      return scrollPlan;\r\n    }\r\n\r\n    let targetContainer: NgxStickyBaseContainerDirective;\r\n    let targetContainerScrollPlan: NgxScrollPlan;\r\n\r\n    for (const containerController of (this.containers as NgxStickyBaseContainerDirective[])) {\r\n      const containerScrollPlan = containerController.createScrollPlan(target, userOffsetTop);\r\n\r\n      if (containerScrollPlan.length) {\r\n        targetContainerScrollPlan = containerScrollPlan;\r\n        targetContainer = containerController as NgxStickyBaseContainerDirective;\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    const containerScrollable = !this.element || isElementScrollableY(this._win, this.element);\r\n\r\n    if (containerScrollable) {\r\n      const targetLine = targetContainer\r\n        ? targetContainer.getContainer()\r\n        : getElementAbsoluteRect(target as HTMLElement);\r\n      const targetTopFixed = this.fixViewportTop(targetLine.top, userOffsetTop);\r\n\r\n      scrollPlan.push({\r\n        scrollToFn,\r\n        scrollToOptions: { left: this.getViewportLeft(), top: targetTopFixed },\r\n      });\r\n    }\r\n\r\n    if (targetContainerScrollPlan) {\r\n      scrollPlan.push(...targetContainerScrollPlan);\r\n    }\r\n\r\n    return scrollPlan;\r\n  }\r\n\r\n  disableStickies(): void {\r\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\r\n  }\r\n\r\n  enableStickies(): void {\r\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\r\n  }\r\n\r\n  getContainer(): NgxStickyContainer {\r\n    if (!this._container) {\r\n      this._container = this._computeContainer();\r\n    }\r\n\r\n    return this._container;\r\n  }\r\n\r\n  getViewportHeight(): number {\r\n    return getWindowViewportHeight(this._win);\r\n  }\r\n\r\n  getViewportLeft(): number {\r\n    return getWindowViewportLeft(this._win);\r\n  }\r\n\r\n  getViewportTop(): number {\r\n    return getWindowViewportTop(this._win);\r\n  }\r\n\r\n  registerSticky(sticky: NgxStickyController): void {\r\n    super.registerSticky(sticky);\r\n\r\n    if (this.stickies.length) {\r\n      this._initMonitoring();\r\n    }\r\n  }\r\n\r\n  unregisterSticky(sticky: NgxStickyController): void {\r\n    super.unregisterSticky(sticky);\r\n\r\n    if (!this.stickies.length) {\r\n      this._destroyMonitoring();\r\n    }\r\n  }\r\n\r\n  scrollToTop(target: number | string | HTMLElement, userOffsetTop?: number): void {\r\n    const scrollPlan = this.createScrollPlan(target, userOffsetTop);\r\n\r\n    for (const scrollStep of scrollPlan) {\r\n      scrollStep.scrollToFn(scrollStep.scrollToOptions);\r\n    }\r\n  }\r\n\r\n  updateStickies(fastUpdate?: boolean): void {\r\n    // intercept update stickies to throttle calls\r\n    this._updateStickies$.next(fastUpdate);\r\n  }\r\n\r\n  _computeContainer(): NgxStickyContainer {\r\n    const config = this.config$.getValue();\r\n\r\n    const containerRect = this.element ? getElementAbsoluteRect(this.element) : null;\r\n\r\n    return {\r\n      disabled: this.disabled,\r\n      height: containerRect ? this.element.scrollHeight : this._getDocumentHeight(),\r\n      left: containerRect ? containerRect.left : 0,\r\n      offsetBottom: config.offsetBottom,\r\n      offsetTop: config.offsetTop,\r\n      top: containerRect ? containerRect.top : 0,\r\n      unstacked: config.unstacked,\r\n      width: containerRect ? this.element.scrollWidth : this._getDocumentWidth(),\r\n    };\r\n  }\r\n\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    if (!this._win) {\r\n      return of();\r\n    }\r\n\r\n    return merge(\r\n      this._createMonitoringInputsObservable(),\r\n      this._createMonitoringScrollObservable(),\r\n      this._createMonitoringWindowObservable(),\r\n      this._updateStickies$,\r\n      animationFrameScheduler,\r\n    )/*.pipe(throttleTime(0, animationFrameScheduler))*/;\r\n  }\r\n\r\n  _createMonitoringInputsObservable(): Observable<boolean> {\r\n    return this.config$.pipe(\r\n      debounceTime(0),\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  _createMonitoringScrollObservable(): Observable<boolean> {\r\n    return fromEvent(this.element || this._win, 'scroll', { passive: true })\r\n      .pipe(\r\n        throttleTime(0, animationFrameScheduler),\r\n        mapTo(true),\r\n      );\r\n  }\r\n\r\n  _createMonitoringWindowObservable(): Observable<boolean> {\r\n    return merge(\r\n      fromEvent(this._win, 'load', { passive: true }),\r\n      fromEvent(this._win, 'orientationchange', { passive: true }),\r\n      fromEvent(this._win, 'resize', { passive: true }),\r\n    ).pipe(\r\n      debounceTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this._monitoring = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this.destroyed$),\r\n          // throttleTime(0, animationFrameScheduler),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this._updateStickies(fastUpdate);\r\n        });\r\n\r\n      // fromMediaQuery(this._win, 'print').subscribe(mqlEvent => {\r\n      //   if (mqlEvent.matches) {\r\n      //     this.disableStickies();\r\n      //   } else {\r\n      //     this.enableStickies();\r\n      //   }\r\n      // });\r\n    });\r\n  }\r\n\r\n  _updateStickies(fastUpdate?: boolean): void {\r\n    super.updateStickies(fastUpdate);\r\n  }\r\n}\r\n","import {\r\n  NgxSticky,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyComputation,\r\n  NgxStickyContainerController,\r\n  NgxStickyController,\r\n  NgxStickyState,\r\n} from './sticky.types';\r\n\r\n\r\n/**\r\n * Abstract sticky controller.\r\n */\r\nexport abstract class NgxStickyBaseController implements NgxStickyController {\r\n  abstract readonly boundary?: NgxStickyBoundaryController;\r\n  abstract readonly container: NgxStickyContainerController;\r\n  abstract readonly disabled: boolean;\r\n  abstract readonly state: NgxStickyState;\r\n\r\n  abstract beforeRefresh(fastUpdate?: boolean): void;\r\n  abstract disableSticky(): void;\r\n  abstract enableSticky(): void;\r\n  abstract getSticky(): NgxSticky;\r\n  abstract refresh(computation: NgxStickyComputation): void;\r\n\r\n  update(fastUpdate?: boolean): void {\r\n    // all stickies need to be updated when one of them changed\r\n    this.container.updateStickies(fastUpdate);\r\n  }\r\n}\r\n","import {\r\n  Directive,\r\n  ElementRef,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnChanges,\r\n  OnDestroy,\r\n  OnInit,\r\n  Optional,\r\n  SimpleChanges,\r\n  forwardRef,\r\n} from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\r\nimport { mapTo, share, takeUntil } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseBoundaryController } from './sticky-base-boundary.controller';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport { NgxStickyBoundary, NgxStickyContainerController } from './sticky.types';\r\nimport { coerceBooleanProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport { getElementAbsoluteRect } from './utils/dom';\r\n\r\n\r\nexport interface NgxStickyBoundaryConfig {\r\n  unstacked: boolean;\r\n}\r\n\r\n\r\nexport const NGX_STICKY_BASE_BOUNDARY_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyBoundaryConfig> = {\r\n  unstacked: {\r\n    aliasKey: 'stickyUnstacked',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n};\r\n\r\n\r\n/**\r\n * Defines a sticky boundary.\r\n */\r\n@Directive({\r\n  selector: '[ngxStickyBoundary], [ngx-sticky-boundary], ngx-sticky-boundary',\r\n  exportAs: 'ngxStickyBoundary',\r\n})\r\nexport class NgxStickyBoundaryDirective extends NgxStickyBaseBoundaryController implements OnChanges, OnDestroy, OnInit {\r\n  /**\r\n   * Enable/disable sticky stack inside boudary.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyUnstacked: boolean;\r\n\r\n  get config(): NgxStickyBoundaryConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get container(): NgxStickyContainerController {\r\n    return this._container;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject(NGX_STICKY_BASE_BOUNDARY_CONFIG_SCHEMA);\r\n\r\n  /** Boundary line which reflect last call of _computeBoundary() */\r\n  _boundary: NgxStickyBoundary;\r\n\r\n  /** Boundary container controller */\r\n  readonly _container: NgxStickyContainerController;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  readonly _destroyed$ = new Subject<void>();\r\n\r\n  /** Monitoring subscription which trigger update stickies */\r\n  _monitoring: Subscription;\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainer: NgxStickyContainerController,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    super();\r\n\r\n    // use root container when boundary isn't in container\r\n    this._container = stickyContainer || rootContainer;\r\n\r\n    // register boundary in container for first update calls\r\n    this.container.registerBoundary(this);\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    this._initMonitoring();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.container.unregisterBoundary(this);\r\n\r\n    if (!this._destroyed$.isStopped) {\r\n      this._destroyed$.next();\r\n      this._destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._boundary = null;\r\n    }\r\n  }\r\n\r\n  getBoundary(): NgxStickyBoundary {\r\n    if (!this._boundary) {\r\n      this._boundary = this._computeBoundary();\r\n    }\r\n\r\n    return this._boundary;\r\n  }\r\n\r\n  _computeBoundary(): NgxStickyBoundary {\r\n    const boundary: NgxStickyBoundary = getElementAbsoluteRect(this.elementRef.nativeElement);\r\n\r\n    if (this._win) {\r\n      const boundaryStyle = this._win.getComputedStyle(this.elementRef.nativeElement);\r\n      const paddingTop = parseFloat(boundaryStyle.paddingTop) || 0;\r\n      const paddingBottom = parseFloat(boundaryStyle.paddingBottom) || 0;\r\n\r\n      // substract paddings from computed boundary line\r\n      boundary.top += paddingTop;\r\n      boundary.height -= paddingTop + paddingBottom;\r\n    }\r\n\r\n    boundary.unstacked = this.config.unstacked;\r\n\r\n    return boundary;\r\n  }\r\n\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    return merge(\r\n      this.config$,\r\n      animationFrameScheduler,\r\n    ).pipe(\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this._monitoring = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this.updateStickies(fastUpdate);\r\n        });\r\n    });\r\n  }\r\n}\r\n","import { Directive, ElementRef, Inject, NgZone, Optional, SkipSelf, forwardRef } from '@angular/core';\r\n\r\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\r\nimport { NgxStickyEngine } from './sticky-engine';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport { NgxStickyContainerController } from './sticky.types';\r\n\r\n\r\n/**\r\n * Defines a sticky container.\r\n */\r\n@Directive({\r\n  selector: '[ngxStickyContainer], [ngx-sticky-container], ngx-sticky-container',\r\n  exportAs: 'ngxStickyContainer',\r\n})\r\nexport class NgxStickyContainerDirective extends NgxStickyBaseContainerDirective {\r\n  /**\r\n   * Returns HTMLElement of the container.\r\n   */\r\n  get element(): HTMLElement {\r\n    return this.elementRef.nativeElement;\r\n  }\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @SkipSelf() @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainerParent: NgxStickyContainerController,\r\n    readonly stickyEngine: NgxStickyEngine,\r\n    readonly ngZone: NgZone,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    // use root container when boundary isn't in container\r\n    super(stickyContainerParent || rootContainer, stickyEngine, ngZone, _win);\r\n  }\r\n\r\n  getViewportHeight(): number {\r\n    return this.element.offsetHeight;\r\n  }\r\n\r\n  getViewportLeft(): number {\r\n    return this.element.scrollLeft;\r\n  }\r\n\r\n  getViewportTop(): number {\r\n    return this.element.scrollTop;\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\nimport { isStickyDirectionDown, isStickyPositionBottom } from './sticky.helpers';\r\nimport {\r\n  NgxIntersection,\r\n  NgxIntersectionComputation,\r\n  NgxIntersectionSnap,\r\n  NgxSticky,\r\n  NgxStickyBoundary,\r\n  NgxStickyBoundaryComputed,\r\n  NgxStickyComputation,\r\n  NgxStickyComputed,\r\n  NgxStickyContainer,\r\n  NgxStickyLine,\r\n  NgxStickyPosition,\r\n  NgxStickySnap,\r\n  NgxStickyState,\r\n} from './sticky.types';\r\n\r\n\r\nexport const NGX_STICKY_ENGINE_INTERCEPTION_STATE_MAP = {\r\n  'sticked,normal': 'enter',\r\n  'stucked,normal': 'entered',\r\n  'sticked,sticked': 'entered',\r\n  'stucked,sticked': 'exit',\r\n  'stucked,stucked': 'exited',\r\n};\r\n\r\n\r\n/**\r\n * Defines a sticky engine. Implemented in universal way.\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class NgxStickyEngine {\r\n  /**\r\n   * Compute sticky boundary.\r\n   *\r\n   * @param container Container\r\n   * @param boundary Sticky boundary\r\n   * @param sticky Sticky line\r\n   * @param directionDown Direction down\r\n   * @param spot Spot line\r\n   * @param viewportHeight Viewport height\r\n   * @returns Boundary instance\r\n   */\r\n  computeStickyBoundary(\r\n    container: NgxStickyContainer,\r\n    boundary: NgxStickyBoundary | null,\r\n    sticky: NgxStickyLine,\r\n    directionDown: boolean,\r\n    spot: NgxStickyLine | null,\r\n    viewportHeight: number,\r\n  ): NgxStickyBoundaryComputed {\r\n    let {\r\n      height: boundaryHeight,\r\n      top: boundaryTop,\r\n      left: boundaryLeft,\r\n      width: boundaryWidth,\r\n    } = boundary || container;\r\n\r\n    boundaryHeight = boundaryHeight || 0;\r\n    boundaryTop = boundaryTop || 0;\r\n    boundaryWidth = boundaryWidth || 0;\r\n    boundaryLeft = boundaryLeft || 0;\r\n\r\n    if (spot && spot.height) {\r\n      const beforeSpot = sticky.top < spot.top;\r\n\r\n      if (beforeSpot) {\r\n        // when sticky direction is bottom and is before its spot\r\n        if (directionDown) {\r\n          const spotPoint = spot.top - viewportHeight;\r\n\r\n          // disable sticky when is in same viewport height as its spot\r\n          if (spotPoint < sticky.top) {\r\n            boundaryHeight = 0;\r\n            boundaryTop = 0;\r\n          // adjust sticky boundary height according to its spot when spot point is in base boundary\r\n          } else if (spotPoint < boundaryTop + boundaryHeight) {\r\n            boundaryHeight = spotPoint - boundaryTop + sticky.height;\r\n          }\r\n        }\r\n      } else {\r\n        // when sticky direction is top and is after its spot\r\n        if (!directionDown) {\r\n          const spotPoint = spot.top + spot.height + viewportHeight;\r\n\r\n          // disable sticky when is in same viewport height as its spot\r\n          if (spotPoint > sticky.top) {\r\n            boundaryHeight = 0;\r\n            boundaryTop = 0;\r\n            // adjust sticky boundary top according to its spot when spot point is in base boundary\r\n          } else if (spotPoint > boundaryTop && spotPoint < boundaryTop + boundaryHeight) {\r\n            boundaryHeight -= spotPoint - boundaryTop;\r\n            boundaryTop = spotPoint;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      height: boundaryHeight,\r\n      top: boundaryTop,\r\n      width: boundaryWidth,\r\n      left: boundaryLeft,\r\n      unstacked: boundary && boundary.unstacked || container.unstacked || false,\r\n      offsetBottom: 0,\r\n      offsetTop: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Compute sticky sticked line.\r\n   *\r\n   * @param boundary Sticky boundary line\r\n   * @param sticky Sticky line\r\n   * @param positionBottom Position bottom\r\n   * @param directionDown Direction down\r\n   * @param viewportHeight Viewport height\r\n   * @returns Sticked line\r\n   */\r\n  computeStickyStickedLine(\r\n    boundary: NgxStickyLine,\r\n    sticky: NgxStickyLine,\r\n    positionBottom: boolean,\r\n    directionDown: boolean,\r\n    viewportHeight: number,\r\n  ): NgxStickyLine {\r\n    let stickedTop: number;\r\n    let stickedHeight: number;\r\n\r\n    if (positionBottom) {\r\n      if (directionDown) {\r\n        stickedTop = sticky.top + sticky.height - viewportHeight;\r\n        stickedHeight = boundary.height + boundary.top - stickedTop - viewportHeight;\r\n      } else {\r\n        stickedTop = boundary.top - viewportHeight;\r\n        stickedHeight = sticky.top - stickedTop - viewportHeight;\r\n      }\r\n    } else {\r\n      if (directionDown) {\r\n        stickedTop = sticky.top;\r\n        stickedHeight = boundary.height + boundary.top - stickedTop;\r\n      } else {\r\n        stickedTop = boundary.top;\r\n        stickedHeight = sticky.top - stickedTop;\r\n      }\r\n    }\r\n\r\n    return { top: stickedTop, height: stickedHeight };\r\n  }\r\n\r\n  /**\r\n   * Compute sticky sort point.\r\n   *\r\n   * @param sticky Sticky line\r\n   * @param positionBottom Position bottom\r\n   * @param directionDown Direction down\r\n   * @param viewportHeight Viewport height\r\n   * @returns Sticky sort point\r\n   */\r\n  computeStickySortPoint(\r\n    sticky: NgxStickyLine,\r\n    positionBottom: boolean,\r\n    directionDown: boolean,\r\n    viewportHeight: number,\r\n  ): number {\r\n    let sortPoint: number;\r\n\r\n    if (positionBottom) {\r\n      sortPoint = directionDown\r\n        ? -sticky.top - sticky.height + viewportHeight\r\n        : sticky.top + sticky.height - viewportHeight;\r\n    } else {\r\n      sortPoint = directionDown\r\n        ? -sticky.top\r\n        : sticky.top;\r\n    }\r\n\r\n    return sortPoint;\r\n  }\r\n\r\n  /**\r\n   * Determines intersection state.\r\n   *\r\n   * @param snap Intersection snap\r\n   * @param viewportTop Viewport/scroll top position\r\n   * @returns Intersection computation\r\n   */\r\n  determineIntersectionState(snap: NgxIntersectionSnap, viewportTop: number): NgxIntersectionComputation {\r\n    const enter = this.determineStickyState(snap.enter, viewportTop);\r\n    const exit = this.determineStickyState(snap.exit, viewportTop);\r\n\r\n    // Intersection state can be easily determined from enter sticky and exit sticky states:\r\n    // - enter: when enter sticky (on bottom) is _sticked_ and exit sticky (on top) is _normal_ ;\r\n    // - entered: when enter (on bottom) and exit (on top) stickies are _sticked_ ;\r\n    // - entered: when enter sticky (on bottom) is _stucked_ and exit sticky (on top) is _normal_ ;\r\n    // - exit: when enter sticky (on bottom) is _stucked_ and exit sticky (on top) is _sticked_ ;\r\n    // - exited: when enter (on bottom) and exit (on top) stickies are _stucked_.\r\n    const stateKey = [ enter.state, exit.state ].join(',');\r\n    const state = NGX_STICKY_ENGINE_INTERCEPTION_STATE_MAP[stateKey] || null;\r\n\r\n    const viewportOffsetless = snap.viewportHeight - enter.offsetSticked - exit.offsetSticked;\r\n    const maxHeightVisible = Math.min(snap.intersection.height, viewportOffsetless);\r\n    let height = 0;\r\n    let intersecting = false;\r\n\r\n    if (state === 'entered') {\r\n      height = maxHeightVisible;\r\n      intersecting = true;\r\n    } else if (state === 'enter') {\r\n      height = viewportTop + snap.viewportHeight - snap.intersection.top - enter.offsetSticked;\r\n      intersecting = true;\r\n    } else if (state === 'exit') {\r\n      height = snap.intersection.top + snap.intersection.height - viewportTop - exit.offsetSticked;\r\n      intersecting = true;\r\n    }\r\n\r\n    const computation: NgxIntersectionComputation = {\r\n      enter,\r\n      exit,\r\n      snap,\r\n      height,\r\n      intersecting,\r\n      ratio: Math.min(1, height / maxHeightVisible),\r\n      state,\r\n      viewportTop,\r\n    };\r\n\r\n    return computation;\r\n  }\r\n\r\n  /**\r\n   * Determines sticky state.\r\n   *\r\n   * @param snap Sticky snap\r\n   * @param viewportTop Viewport/scroll top position\r\n   * @returns Sticky computation\r\n   */\r\n  determineStickyState(snap: NgxStickySnap, viewportTop: number): NgxStickyComputation {\r\n    const computation: NgxStickyComputation = {\r\n      offsetSticked: 0,\r\n      offsetStucked: 0,\r\n      state: 'normal',\r\n      snap,\r\n      viewportTop,\r\n    };\r\n\r\n    // cancel computation when stickyComputed is outside its boundary\r\n    if (snap.stickyComputed.disabled) {\r\n      return computation;\r\n    }\r\n\r\n    // last value stored in _stickyComputedState will be related to stickyComputed\r\n    let _stickyComputedState: NgxStickyState;\r\n\r\n    // compute state for each sibling and stickyComputed in last\r\n    for (const _stickyComputed of snap.stickies) {\r\n      const boundaryOffset = _stickyComputed.directionDown\r\n        ? _stickyComputed.boundary.offsetBottom\r\n        : _stickyComputed.boundary.offsetTop;\r\n      let {\r\n        top: _stickedTop,\r\n        height: _stickedHeight,\r\n      } = _stickyComputed.sticked;\r\n\r\n      // adjust _stickyComputed sticked line with previous sibling\r\n      if (_stickyComputed.positionBottom) {\r\n        if (_stickyComputed.directionDown) {\r\n          _stickedTop += computation.offsetSticked + computation.offsetStucked;\r\n          _stickedHeight -= computation.offsetStucked;\r\n        } else {\r\n          _stickedTop += boundaryOffset;\r\n          _stickedTop += computation.offsetSticked;\r\n          _stickedHeight -= boundaryOffset - computation.offsetStucked;\r\n          _stickedHeight += _stickyComputed.height;\r\n        }\r\n      } else {\r\n        if (_stickyComputed.directionDown) {\r\n          _stickedTop -= computation.offsetSticked + computation.offsetStucked;\r\n          _stickedHeight += computation.offsetStucked;\r\n          _stickedHeight -= boundaryOffset;\r\n        } else {\r\n          _stickedTop -= computation.offsetSticked;\r\n          _stickedHeight -= computation.offsetStucked;\r\n        }\r\n      }\r\n\r\n      // set default state to \"normal\"\r\n      _stickyComputedState = 'normal';\r\n\r\n      // determine _stickyComputed state with its sticked line adjusted\r\n      // if (viewportTop > _stickedTop) {\r\n      if (viewportTop >= _stickedTop) {\r\n        _stickyComputedState = 'sticked';\r\n\r\n        if (viewportTop > _stickedTop + _stickedHeight) {\r\n          _stickyComputedState = _stickyComputed.directionDown ? 'stucked' : 'normal';\r\n        }\r\n      } else if (!_stickyComputed.directionDown) {\r\n        _stickyComputedState = 'stucked';\r\n      }\r\n\r\n      // cumulate sibling height to the right offset\r\n      if (\r\n        // when _stickyComputed isn't stickyComputed\r\n        _stickyComputed !== snap.stickyComputed\r\n        // and state determined is \"sticked\" or \"stucked\"\r\n        && _stickyComputedState !== 'normal'\r\n        // and _stickyComputed is stacked\r\n        && !_stickyComputed.boundary.unstacked\r\n      ) {\r\n        if (\r\n          _stickyComputed.boundary.top === snap.stickyComputed.boundary.top\r\n            && _stickyComputed.boundary.height === snap.stickyComputed.boundary.height\r\n        ) {\r\n          computation.offsetStucked += _stickyComputed.height;\r\n        } else if (_stickyComputedState === 'sticked') {\r\n          computation.offsetSticked += _stickyComputed.height;\r\n        }\r\n      }\r\n      // (computation as any)._state = _stickyComputedState;\r\n    }\r\n\r\n    computation.state = _stickyComputedState;\r\n\r\n    return computation;\r\n  }\r\n\r\n  /**\r\n   * Returns scroll top offset height used by stickies for a given viewport position.\r\n   *\r\n   * @param container Container\r\n   * @param stickies Stickies\r\n   * @param position Position `\"top\"` or `\"bottom\"`\r\n   * @param viewportHeight Viewport height\r\n   * @param offsetTop Viewport top\r\n   * @returns Top offset height used by stickies.\r\n   */\r\n  getStickedOffset(\r\n    container: NgxStickyContainer,\r\n    stickies: NgxSticky[],\r\n    position: NgxStickyPosition,\r\n    viewportHeight: number,\r\n    viewportTop: number,\r\n  ): number {\r\n    const positionBottom = isStickyPositionBottom(position);\r\n    let maxStickyUnstackedHeight = 0;\r\n    let stickedOffset = 0;\r\n\r\n    for (const _sticky of stickies) {\r\n      // skip sticky when is position bottom\r\n      if (isStickyPositionBottom(_sticky.position) !== positionBottom) {\r\n        continue;\r\n      }\r\n\r\n      const snap = this.snapSticky(container, stickies, _sticky, viewportHeight);\r\n\r\n      // skip sticky when is disabled\r\n      if (snap.sticky.disabled) {\r\n        continue;\r\n      }\r\n\r\n      const computation = this.determineStickyState(snap, viewportTop);\r\n\r\n      // add sticky height to offset top when state is sticked\r\n      if (computation.state === 'sticked') {\r\n        const _elementHeight = snap.stickyComputed.height;\r\n\r\n        // substract height when sticy is stacked\r\n        if (!snap.stickyComputed.boundary.unstacked) {\r\n          stickedOffset += _elementHeight;\r\n        // or update the biggest sticky unstacked\r\n        } else if (_elementHeight > maxStickyUnstackedHeight) {\r\n          maxStickyUnstackedHeight = _elementHeight;\r\n        }\r\n      }\r\n    }\r\n\r\n    stickedOffset += maxStickyUnstackedHeight;\r\n\r\n    if (positionBottom) {\r\n      stickedOffset += container.offsetBottom || 0;\r\n    } else {\r\n      stickedOffset += container.offsetTop || 0;\r\n    }\r\n\r\n    return stickedOffset;\r\n  }\r\n\r\n  /**\r\n   * Create intersection snap.\r\n   *\r\n   * @param container Container\r\n   * @param stickies Stickies\r\n   * @param intersection Intersection\r\n   * @param viewportHeight Viewport height\r\n   * @returns Intersection snap\r\n   */\r\n  snapIntersection(\r\n    container: NgxStickyContainer,\r\n    stickies: NgxSticky[],\r\n    intersection: NgxIntersection,\r\n    viewportHeight: number,\r\n  ): NgxIntersectionSnap {\r\n    const disabled = intersection.disabled;\r\n\r\n    // enter sticky is sticked on bottom\r\n    const enterSticky: NgxSticky = {\r\n      boundary: {\r\n        top: intersection.top - 1,\r\n        height: intersection.height,\r\n        left: container.left,\r\n        width: container.width,\r\n      },\r\n      disabled,\r\n      top: intersection.top - 1,\r\n      height: 1,\r\n      position: 'bottom',\r\n      direction: 'down',\r\n    };\r\n\r\n    // exit sticky is sticked on top\r\n    const exitSticky: NgxSticky = {\r\n      boundary: {\r\n        top: intersection.top,\r\n        height: intersection.height - 1,\r\n        left: container.left,\r\n        width: container.width,\r\n      },\r\n      disabled,\r\n      top: intersection.top,\r\n      height: 1,\r\n      position: 'top',\r\n      direction: 'down',\r\n    };\r\n\r\n    return {\r\n      container,\r\n      enter: this.snapSticky(container, stickies, enterSticky, viewportHeight),\r\n      exit: this.snapSticky(container, stickies, exitSticky, viewportHeight),\r\n      intersection: {\r\n        disabled,\r\n        height: intersection.height,\r\n        thresholds: intersection.thresholds ? [ ...intersection.thresholds ] : [ 0, 1 ],\r\n        top: intersection.top,\r\n      },\r\n      viewportHeight,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create sticky snap.\r\n   *\r\n   * @param container Container\r\n   * @param stickies Stickies\r\n   * @param sticky Sticky\r\n   * @param viewportHeight Viewport height\r\n   * @returns Sticky snap\r\n   */\r\n  snapSticky(\r\n    container: NgxStickyContainer,\r\n    stickies: NgxSticky[],\r\n    sticky: NgxSticky,\r\n    viewportHeight: number,\r\n  ): NgxStickySnap {\r\n    const boundariesMap: Record<string, NgxStickyBoundaryComputed> = {};\r\n\r\n    const directionDown = isStickyDirectionDown(sticky.direction);\r\n    const positionBottom = isStickyPositionBottom(sticky.position);\r\n\r\n    const stickyComputed: NgxStickyComputed = {\r\n      boundary: this.computeStickyBoundary(\r\n        container,\r\n        sticky.boundary,\r\n        sticky,\r\n        directionDown,\r\n        sticky.spot,\r\n        viewportHeight,\r\n      ),\r\n      directionDown,\r\n      disabled: false,\r\n      height: sticky.height,\r\n      positionBottom,\r\n      sortPoint: this.computeStickySortPoint(sticky, positionBottom, directionDown, viewportHeight),\r\n      sticked: null,\r\n      top: sticky.top,\r\n    };\r\n\r\n    if (\r\n      container.disabled\r\n      || sticky.disabled\r\n      || !sticky.height\r\n      || sticky.top < stickyComputed.boundary.top\r\n      || sticky.top > stickyComputed.boundary.top + stickyComputed.boundary.height\r\n    ) {\r\n      stickyComputed.disabled = true;\r\n      stickyComputed.sticked = { height: 0, top: 0 };\r\n    } else {\r\n      stickyComputed.sticked = this.computeStickyStickedLine(\r\n        stickyComputed.boundary,\r\n        sticky,\r\n        positionBottom,\r\n        directionDown,\r\n        viewportHeight,\r\n      );\r\n    }\r\n\r\n    const stickiesComputed: NgxStickyComputed[] = [];\r\n    let offsetSpacer: NgxSticky;\r\n\r\n    if (sticky.disabled) {\r\n      return {\r\n        boundaries: boundariesMap,\r\n        container,\r\n        stickies: stickiesComputed,\r\n        sticky,\r\n        stickyComputed,\r\n        viewportHeight,\r\n      };\r\n    }\r\n\r\n    // insert fake sticky which represent container offset top\r\n    if (container.offsetTop && !stickyComputed.positionBottom) {\r\n      offsetSpacer = {\r\n        boundary: container,\r\n        direction: 'down',\r\n        height: container.offsetTop,\r\n        position: 'top',\r\n        disabled: false,\r\n        top: container.top,\r\n      };\r\n\r\n      stickies = [ offsetSpacer, ...stickies ];\r\n    }\r\n\r\n    // insert fake sticky which represent container offset bottom\r\n    if (container.offsetBottom && stickyComputed.positionBottom) {\r\n      offsetSpacer = {\r\n        boundary: container,\r\n        direction: 'up',\r\n        height: container.offsetBottom,\r\n        position: 'bottom',\r\n        disabled: false,\r\n        top: container.top + container.height - container.offsetBottom,\r\n      };\r\n\r\n      stickies = [ offsetSpacer, ...stickies ];\r\n    }\r\n\r\n    // remove 1px to fix round sizes (offsetLeft and offsetWidth)\r\n    const stickyComputedBoundaryRight = stickyComputed.boundary.left + stickyComputed.boundary.width - 1;\r\n\r\n    for (let _stickyIndex = 0; _stickyIndex < stickies.length; ++_stickyIndex) {\r\n      const _sticky = stickies[_stickyIndex];\r\n      let _directionDown: boolean;\r\n      let _positionBottom: boolean;\r\n      let _stickyComputed: NgxStickyComputed;\r\n      let _stickyComputedBoundaryRight: number;\r\n\r\n      if (_sticky === sticky) {\r\n        _directionDown = stickyComputed.directionDown;\r\n        _positionBottom = stickyComputed.positionBottom;\r\n        _stickyComputed = stickyComputed;\r\n        _stickyComputedBoundaryRight = stickyComputedBoundaryRight;\r\n      } else {\r\n        _directionDown = isStickyDirectionDown(_sticky.direction);\r\n        _positionBottom = isStickyPositionBottom(_sticky.position);\r\n\r\n        _stickyComputed = {\r\n          boundary: this.computeStickyBoundary(\r\n            container,\r\n            _sticky.boundary,\r\n            _sticky,\r\n            _directionDown,\r\n            _sticky.spot,\r\n            viewportHeight,\r\n          ),\r\n          disabled: false,\r\n          directionDown: _directionDown,\r\n          height: _sticky.height,\r\n          positionBottom: _positionBottom,\r\n          sortPoint: this.computeStickySortPoint(_sticky, _positionBottom, _directionDown, viewportHeight),\r\n          sticked: null,\r\n          top: _sticky.top,\r\n        };\r\n\r\n        // remove 1px to fix round sizes (offsetLeft and offsetWidth)\r\n        _stickyComputedBoundaryRight = _stickyComputed.boundary.left + _stickyComputed.boundary.width - 1;\r\n\r\n        if (\r\n          _sticky.disabled\r\n          || !_sticky.height\r\n          // skip sticky which isn't in its boundary\r\n          || _sticky.top < _stickyComputed.boundary.top\r\n          || _sticky.top > _stickyComputed.boundary.top + _stickyComputed.boundary.height\r\n          // skip sticky sibling when its boundary isn't align horizontaly\r\n          || stickyComputedBoundaryRight <= _stickyComputed.boundary.left\r\n          || stickyComputed.boundary.left >= _stickyComputedBoundaryRight\r\n        ) {\r\n          _stickyComputed.disabled = true;\r\n          _stickyComputed.sticked = { height: 0, top: 0 };\r\n        } else {\r\n          _stickyComputed.sticked = this.computeStickyStickedLine(\r\n            _stickyComputed.boundary,\r\n            _sticky,\r\n            _positionBottom,\r\n            _directionDown,\r\n            viewportHeight,\r\n          );\r\n        }\r\n      }\r\n\r\n      // compute boundary unique key\r\n      const boundaryKey = [ _stickyComputed.boundary.top, _stickyComputed.boundary.height ].join(',');\r\n\r\n      // ensure stickies computed to use same boundary instance\r\n      if (boundariesMap[boundaryKey]) {\r\n        _stickyComputed.boundary = boundariesMap[boundaryKey];\r\n      } else {\r\n        boundariesMap[boundaryKey] = _stickyComputed.boundary;\r\n      }\r\n\r\n      // skip sticky sibling when is disabled\r\n      if (_stickyComputed.disabled) {\r\n        continue;\r\n      }\r\n\r\n      // set sticky sibling height as max boundary offset when it unstacked\r\n      if (_stickyComputed.boundary.unstacked) {\r\n        if (_directionDown) {\r\n          if (_sticky.height > _stickyComputed.boundary.offsetBottom) {\r\n            _stickyComputed.boundary.offsetBottom = _sticky.height;\r\n          }\r\n        } else {\r\n          if (_sticky.height > _stickyComputed.boundary.offsetTop) {\r\n            _stickyComputed.boundary.offsetTop = _sticky.height;\r\n          }\r\n        }\r\n      // add sticky sibling height to right boundary offset when it stacked\r\n      } else {\r\n        if (_directionDown) {\r\n          _stickyComputed.boundary.offsetBottom += _sticky.height;\r\n        } else {\r\n          _stickyComputed.boundary.offsetTop += _sticky.height;\r\n        }\r\n      }\r\n\r\n      // pushforce offset spacer as sticky siblings\r\n      if (_sticky === offsetSpacer) {\r\n        stickiesComputed.push(_stickyComputed);\r\n\r\n        continue;\r\n      }\r\n\r\n      // collect stickyComputed siblings\r\n      if (\r\n        // when _stickyComputed isn't stickyComputed\r\n        _stickyComputed !== stickyComputed\r\n        // and its position equals to stickyComputed position\r\n        && _stickyComputed.positionBottom === stickyComputed.positionBottom\r\n        // and its sticked line intersects top of stickyComputed sticked line\r\n        && stickyComputed.sticked.top >= _stickyComputed.sticked.top\r\n        && stickyComputed.sticked.top <= _stickyComputed.sticked.top + _stickyComputed.sticked.height\r\n        // and its top is before stickyComputed top according to its own position\r\n        && (\r\n          _stickyComputed.directionDown\r\n            ? _stickyComputed.top < stickyComputed.top\r\n            : _stickyComputed.top > stickyComputed.top\r\n        )\r\n      ) {\r\n        stickiesComputed.push(_stickyComputed);\r\n      }\r\n    }\r\n\r\n    // sort stickyComputed siblings according to their respective sortPoint and boundary top\r\n    stickiesComputed.sort((a, b) => {\r\n      return a.positionBottom === stickyComputed.positionBottom\r\n        ? a.sortPoint < b.sortPoint && a.boundary.top >= b.boundary.top ? 1 : -1\r\n        : -1;\r\n    });\r\n\r\n    // add stickyComputed in last position\r\n    stickiesComputed.push(stickyComputed);\r\n\r\n    return {\r\n      container,\r\n      boundaries: boundariesMap,\r\n      stickies: stickiesComputed,\r\n      sticky,\r\n      stickyComputed,\r\n      viewportHeight,\r\n    };\r\n  }\r\n}\r\n","import { Inject, Injectable, NgZone } from '@angular/core';\r\n\r\nimport { NgxStickyBaseContainerDirective } from './sticky-base-container.directive';\r\nimport { NgxStickyEngine } from './sticky-engine';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport { NgxStickyContainerController } from './sticky.types';\r\n\r\n\r\n/**\r\n * Defines the sticky root container which is used to manage sticky without container.\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class NgxStickyRootContainerController extends NgxStickyBaseContainerDirective {\r\n  // root container never has parent container\r\n  readonly containerParent: NgxStickyContainerController = null;\r\n  // root container never has element\r\n  readonly element: HTMLElement = null;\r\n\r\n  constructor(\r\n    readonly stickyEngine: NgxStickyEngine,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    super(null, stickyEngine, ngZone, _win);\r\n  }\r\n}\r\n","import { Directive, HostBinding, Input } from '@angular/core';\r\n\r\nimport { coerceNumberProperty } from './utils';\r\n\r\n@Directive({\r\n  selector: '[ngxStickySpot], [ngx-sticky-spot], ngx-sticky-spot',\r\n  exportAs: 'ngxStickySpot',\r\n})\r\nexport class NgxStickySpotDirective {\r\n  @HostBinding('class.ngx-sticky-spot')\r\n  readonly cssClassStickySpot = true;\r\n\r\n  @HostBinding('style.position')\r\n  readonly cssStylePosition = 'absolute';\r\n\r\n  @HostBinding('style.height.px')\r\n  @Input()\r\n  get stickySpotHeight(): number { return this._stickySpotHeight; }\r\n  set stickySpotHeight(value: number) { this._stickySpotHeight = coerceNumberProperty(value); }\r\n\r\n  private _stickySpotHeight = 1;\r\n}\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  HostBinding,\r\n  Inject,\r\n  Input,\r\n  NgZone,\r\n  OnChanges,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  Renderer2,\r\n  SimpleChanges,\r\n  SkipSelf,\r\n  forwardRef,\r\n  isDevMode,\r\n} from '@angular/core';\r\nimport { Observable, Subject, Subscription, animationFrameScheduler, merge } from 'rxjs';\r\nimport { distinctUntilChanged, mapTo, share, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nimport { NgxStickyBaseController } from './sticky-base.controller';\r\nimport { NgxStickyBoundaryDirective } from './sticky-boundary.directive';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickyRootContainerController } from './sticky-root-container.controller';\r\nimport { coerceStickyDirection, coerceStickyPosition, getStuckedPositionTop } from './sticky.helpers';\r\nimport { NGX_STICKY_WINDOW } from './sticky.tokens';\r\nimport {\r\n  NgxSticky,\r\n  NgxStickyBoundaryController,\r\n  NgxStickyComputation,\r\n  NgxStickyContainerController,\r\n  NgxStickyController,\r\n  NgxStickyDirection,\r\n  NgxStickyPosition,\r\n  NgxStickyState,\r\n} from './sticky.types';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from './utils/coercion';\r\nimport { ConfigSubject, ConfigSubjectSchema } from './utils/config-subject';\r\nimport { getElementAbsoluteRect, getElementRelativeRect, setElementStyles } from './utils/dom';\r\nimport { fromImageEvents } from './utils/from-image-events';\r\n\r\n\r\n/**\r\n * Interface for a sticky style.\r\n */\r\nexport interface NgxStickyElementStyle {\r\n  // [prop: string]: string;\r\n  width: string;\r\n  position: string;\r\n  top: string;\r\n  right: string;\r\n  bottom: string;\r\n  left: string;\r\n  cssFloat: string;\r\n  margin: string;\r\n  marginTop: string;\r\n  marginRight: string;\r\n  marginBottom: string;\r\n  marginLeft: string;\r\n}\r\n\r\n/**\r\n * Interface for a sticky ghost style.\r\n */\r\nexport interface NgxStickyGhostStyle {\r\n  // [prop: string]: string;\r\n  width: string;\r\n  position: string;\r\n  top: string;\r\n  right: string;\r\n  bottom: string;\r\n  left: string;\r\n  cssFloat: string;\r\n  marginTop: string;\r\n  marginRight: string;\r\n  marginBottom: string;\r\n  marginLeft: string;\r\n\r\n  height: string;\r\n  maxHeight: string;\r\n  minHeight: string;\r\n  boxSizing: string;\r\n  borderTop: string;\r\n  borderBottom: string;\r\n  borderLeft: string;\r\n  borderRight: string;\r\n  paddingTop: string;\r\n  paddingBottom: string;\r\n  paddingLeft: string;\r\n  paddingRight: string;\r\n}\r\n\r\n\r\nexport interface NgxStickyConfig {\r\n  classes: boolean;\r\n  disabled: boolean;\r\n  direction: NgxStickyDirection;\r\n  height: number;\r\n  // orbit: boolean;\r\n  position: NgxStickyPosition;\r\n  spacer: HTMLElement | null;\r\n  spot: HTMLElement | null;\r\n  spotHeight: number;\r\n}\r\n\r\n\r\nexport const NGX_STICKY_BASE_CONFIG_SCHEMA: ConfigSubjectSchema<NgxStickyConfig> = {\r\n  classes: {\r\n    aliasKey: 'stickyClasses',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  disabled: {\r\n    aliasKey: 'stickyDisabled',\r\n    defaultValue: false,\r\n    coercion: coerceBooleanProperty,\r\n  },\r\n  direction: {\r\n    aliasKey: 'stickyDirection',\r\n    defaultValue: 'down',\r\n    coercion: coerceStickyDirection,\r\n  },\r\n  height: {\r\n    aliasKey: 'stickyHeight',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n  // orbit: {\r\n  //   aliasKey: 'stickyOrbit',\r\n  //   defaultValue: false,\r\n  //   coercion: coerceBooleanProperty,\r\n  // },\r\n  position: {\r\n    aliasKey: 'stickyPosition',\r\n    defaultValue: 'top',\r\n    coercion: coerceStickyPosition,\r\n  },\r\n  spacer: {\r\n    aliasKey: 'stickySpacer',\r\n    defaultValue: null,\r\n  },\r\n  spot: {\r\n    aliasKey: 'stickySpot',\r\n    defaultValue: null,\r\n  },\r\n  spotHeight: {\r\n    aliasKey: 'stickySpotHeight',\r\n    defaultValue: 0,\r\n    coercion: coerceNumberProperty,\r\n  },\r\n};\r\n\r\n\r\n/**\r\n * Defines a sticky.\r\n */\r\n@Directive({\r\n  selector: '[ngxSticky], [ngx-sticky], ngx-sticky',\r\n  exportAs: 'ngxSticky',\r\n})\r\nexport class NgxStickyDirective extends NgxStickyBaseController implements AfterViewInit, OnChanges, OnDestroy {\r\n  /**\r\n   * Binding sticky classes.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyClasses: boolean;\r\n\r\n  /**\r\n   * Direction of the sticky; one of 'up' or 'down'.\r\n   *\r\n   * Defaults to `'down'`.\r\n   */\r\n  @Input()\r\n  stickyDirection: NgxStickyDirection;\r\n\r\n  /**\r\n   * Disable sticky.\r\n   *\r\n   * Defaults to `false`.\r\n   */\r\n  @Input()\r\n  stickyDisabled: boolean;\r\n\r\n  /**\r\n   * Force element height when calculate sticky element height.\r\n   */\r\n  @Input()\r\n  stickyHeight: number;\r\n\r\n  // /**\r\n  //  * Indicate sticky element is an orbit.\r\n  //  *\r\n  //  * An orbit is a sticky element which isn't visible until\r\n  //  * it's sticked.\r\n  //  *\r\n  //  * Generally an orbit spot on another element to be sticked.\r\n  //  *\r\n  //  * Defaults to `false`.\r\n  //  */\r\n  // @Input()\r\n  // stickyOrbit: boolean;\r\n\r\n  /**\r\n   * Position of the sticky; one of 'top' or 'bottom'.\r\n   *\r\n   * Defaults to `'top'`.\r\n   */\r\n  @Input()\r\n  stickyPosition: NgxStickyPosition;\r\n\r\n  /**\r\n   * Sticky spacer.\r\n   *\r\n   * Defaults to `null`.\r\n   */\r\n  @Input()\r\n  stickySpacer: HTMLElement | null;\r\n\r\n  /**\r\n   * Reference to an element used to determine sticky state.\r\n   *\r\n   * The sticky directive will stick element only when spot\r\n   * isn't visible.\r\n   *\r\n   * Defaults to `null`.\r\n   */\r\n  @Input()\r\n  stickySpot: HTMLElement | null;\r\n\r\n  /**\r\n   * Force spot height when calculate sticky spot height.\r\n   */\r\n  @Input()\r\n  stickySpotHeight: number;\r\n\r\n  /**\r\n   * Emit sticky computation.\r\n   */\r\n  @Output()\r\n  readonly stickyComputation = new EventEmitter<NgxStickyComputation>();\r\n\r\n  /**\r\n   * Emit sticky state.\r\n   */\r\n  @Output()\r\n  readonly stickyState = new EventEmitter<NgxStickyState>();\r\n\r\n  @HostBinding('attr.data-sticky-state')\r\n  get attrDataStickyState() { return !this.stickyParent ? this.state : null; }\r\n\r\n  @HostBinding('class.ngx-sticky')\r\n  get cssClassSticky() { return !this.stickyParent && this.config.classes; }\r\n\r\n  @HostBinding('class.ngx-sticky--normal')\r\n  get cssClassStickyNormal() { return this.cssClassSticky && this.state === 'normal'; }\r\n\r\n  @HostBinding('class.ngx-sticky--sticked')\r\n  get cssClassStickySticked() { return this.cssClassSticky && this.state === 'sticked'; }\r\n\r\n  @HostBinding('class.ngx-sticky--stucked')\r\n  get cssClassStickyStucked() { return this.cssClassSticky && this.state === 'stucked'; }\r\n\r\n  @HostBinding('class.ngx-sticky--disabled')\r\n  get cssClassStickyDisabled() { return this.cssClassSticky && this.disabled; }\r\n\r\n  // @HostBinding('class.ngx-sticky--spot')\r\n  // get cssClassStickySpot() { return this.cssClassSticky && !!this.config.spot; }\r\n\r\n  // @HostBinding('class.ngx-sticky--position-top')\r\n  // get cssClassStickyPositionTop() { return this.cssClassSticky && !isStickyPositionBottom(this.config.position); }\r\n\r\n  // @HostBinding('class.ngx-sticky--position-bottom')\r\n  // get cssClassStickyPositionBottom() { return this.cssClassSticky && isStickyPositionBottom(this.config.position); }\r\n\r\n  // @HostBinding('class.ngx-sticky--direction-up')\r\n  // get cssClassStickyDirectionUp() { return this.cssClassSticky && !isStickyDirectionDown(this.config.direction); }\r\n\r\n  // @HostBinding('class.ngx-sticky--direction-down')\r\n  // get cssClassStickydirectionDown() { return this.cssClassSticky && isStickyDirectionDown(this.config.direction); }\r\n\r\n  get boundary(): NgxStickyBoundaryController {\r\n    return this._boundary;\r\n  }\r\n\r\n  get container(): NgxStickyContainerController {\r\n    return this._container;\r\n  }\r\n\r\n  get config(): NgxStickyConfig {\r\n    return this.config$.getValue();\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.config.disabled;\r\n  }\r\n\r\n  /**\r\n   * State of the sticky.\r\n   */\r\n  get state(): NgxStickyState {\r\n    return this._stickyState;\r\n  }\r\n\r\n  /** Inputs config */\r\n  readonly config$ = new ConfigSubject<NgxStickyConfig>(NGX_STICKY_BASE_CONFIG_SCHEMA);\r\n\r\n  /** Sticky container controller */\r\n  readonly _container: NgxStickyContainerController;\r\n\r\n  /** Sticky boundary controller */\r\n  readonly _boundary?: NgxStickyBoundaryController;\r\n\r\n  /** Emits when the component is destroyed. */\r\n  readonly _destroyed$ = new Subject<void>();\r\n\r\n  /** Sticky element style original */\r\n  _elementOriginStyle: NgxStickyElementStyle;\r\n\r\n  /** Monitoring subscription which trigger update stickies and handle refresh */\r\n  _monitoring: Subscription;\r\n\r\n  /** Sticky spacer generated */\r\n  _spacerGenerated: HTMLElement;\r\n\r\n  /** Sticky which reflect last call of _computeSticky() */\r\n  _sticky: NgxSticky;\r\n\r\n  /** Emits when refresh() is called */\r\n  readonly _refresh$ = new Subject<NgxStickyComputation>();\r\n\r\n  /** Sticky computation which reflect last call of _refreshSticky()  */\r\n  _stickyComputation: NgxStickyComputation;\r\n\r\n  /** Sticky element state which reflect last call of _refreshStickyElement() */\r\n  _stickyElementState: NgxStickyState = null;\r\n\r\n  /** Sticky element state which reflect last sticky state output */\r\n  _stickyState: NgxStickyState = null;\r\n\r\n  constructor(\r\n    readonly rootContainer: NgxStickyRootContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyContainerDirective))\r\n    readonly stickyContainer: NgxStickyContainerController,\r\n    @Optional() @Inject(forwardRef(() => NgxStickyBoundaryDirective))\r\n    readonly stickyBoundary: NgxStickyBoundaryController,\r\n    @SkipSelf() @Optional() @Inject(forwardRef(() => NgxStickyDirective))\r\n    readonly stickyParent: NgxStickyController,\r\n    readonly elementRef: ElementRef<HTMLElement>,\r\n    readonly renderer: Renderer2,\r\n    // readonly changeDetectorRef: ChangeDetectorRef,\r\n    readonly ngZone: NgZone,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly _win: Window,\r\n  ) {\r\n    super();\r\n\r\n    // use root container when sticky isn't in container\r\n    this._container = stickyContainer || rootContainer;\r\n\r\n    // ensure sticky boundary is in same container\r\n    this._boundary = stickyBoundary && stickyBoundary.container === this._container ? stickyBoundary : null;\r\n\r\n    // register sticky in container only if isn't in another sticky\r\n    if (!this.stickyParent) {\r\n      // register in parent container for first update calls\r\n      this.container.registerSticky(this);\r\n    }\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    this.config$.nextChanges(changes);\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    // avoid sticky initialization when sticky has a parent\r\n    if (this._preventNestedStickyError()) {\r\n      return;\r\n    }\r\n\r\n    this._initMonitoring();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.container.unregisterSticky(this);\r\n\r\n    if (!this._destroyed$.isStopped) {\r\n      this._destroyed$.next();\r\n      this._destroyed$.complete();\r\n    }\r\n\r\n    this._destroyMonitoring();\r\n  }\r\n\r\n  beforeRefresh(fastUpdate?: boolean): void {\r\n    if (!fastUpdate) {\r\n      this._sticky = null;\r\n    }\r\n  }\r\n\r\n  disableSticky(): void {\r\n    this.config$.nextKeyValue('disabled', true, { skipCoercion: true });\r\n  }\r\n\r\n  enableSticky(): void {\r\n    this.config$.nextKeyValue('disabled', false, { skipCoercion: true });\r\n  }\r\n\r\n  getSticky(): NgxSticky {\r\n    if (!this._sticky) {\r\n      this._sticky = this._computeSticky();\r\n    }\r\n\r\n    return this._sticky;\r\n  }\r\n\r\n  refresh(computation: NgxStickyComputation): void {\r\n    this._refresh$.next(computation);\r\n  }\r\n\r\n  _computeSticky(): NgxSticky {\r\n    // IMPORTANT: refresh sticky element to its normal state is required to compute repainted element height.\r\n    this._refreshStickyElement(null);\r\n    this._refreshStickyElement('normal');\r\n\r\n    const config = this.config$.getValue();\r\n\r\n    // element and spot rects which reflects last screen repaint\r\n    const elementRect = getElementAbsoluteRect(this.elementRef.nativeElement);\r\n    const spotRect = config.spot ? getElementAbsoluteRect(config.spot) : null;\r\n\r\n    if (config.height) {\r\n      elementRect.height = config.height;\r\n    }\r\n\r\n    if (spotRect && config.spotHeight) {\r\n      spotRect.height = config.spotHeight;\r\n    }\r\n\r\n    return {\r\n      disabled: config.disabled,\r\n      boundary: this.boundary ? this.boundary.getBoundary() : null,\r\n      direction: config.direction,\r\n      height: elementRect.height,\r\n      position: config.position,\r\n      top: elementRect.top,\r\n      spot: spotRect,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create sticky monitoring observable.\r\n   */\r\n  _createMonitoringObservable(): Observable<boolean> {\r\n    return merge(\r\n      this.config$,\r\n      fromImageEvents(this.elementRef.nativeElement),\r\n      fromImageEvents(this.config.spot),\r\n      animationFrameScheduler,\r\n    ).pipe(\r\n      // throttleTime(0, animationFrameScheduler),\r\n      mapTo(false),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy sticky monitoring subscription.\r\n   */\r\n  _destroyMonitoring(): void {\r\n    if (this._monitoring) {\r\n      this._monitoring.unsubscribe();\r\n      this._monitoring = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns styles of the given state.\r\n   *\r\n   * `computation` is required when `state` is `\"sticked\"` or `\"stucked\"`.\r\n   *\r\n   * @param state Sticky state\r\n   * @param computation Sticky state computation\r\n   * @returns Styles of the sticky state\r\n   */\r\n  _getStickyElementStyle(state: NgxStickyState, computation?: NgxStickyComputation): Partial<NgxStickyElementStyle> {\r\n    const win = this._win;\r\n\r\n    if (!win || !state) {\r\n      return null;\r\n    }\r\n\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n    const ghostParent = ghost.offsetParent as HTMLElement;\r\n    const ghostParentIsRootElement = ghostParent === win.document.body || ghostParent === win.document.documentElement;\r\n\r\n    // when state is normal (computation isn't needed)\r\n    if (state === 'normal') {\r\n      const ghostRelativeRect = getElementRelativeRect(win, ghost);\r\n      const ghostStyle = win.getComputedStyle(ghost);\r\n      const ghostBorderBox = ghostStyle.boxSizing === 'border-box';\r\n\r\n      let elementWidth = ghostRelativeRect.width;\r\n\r\n      if (!ghostBorderBox) {\r\n        elementWidth +=\r\n          - ((parseFloat(ghostStyle.borderLeft) || 0) + (parseFloat(ghostStyle.borderRight) || 0))\r\n          - ((parseFloat(ghostStyle.paddingLeft) || 0) + (parseFloat(ghostStyle.paddingRight) || 0));\r\n      }\r\n\r\n      let elementTop = ghostRelativeRect.top;\r\n      let elementLeft = ghostRelativeRect.left;\r\n\r\n      if (ghostParentIsRootElement) {\r\n        if (this.container !== this.rootContainer) {\r\n          const ghostRect = getElementAbsoluteRect(ghost);\r\n          const viewportTop = this.container.getViewportTop();\r\n\r\n          elementTop = ghostRect.top - viewportTop;\r\n        }\r\n\r\n        elementTop += win.document.documentElement.offsetTop;\r\n        elementLeft += win.document.documentElement.offsetLeft;\r\n      }\r\n\r\n      const styles = {\r\n        position: 'absolute',\r\n        width: `${elementWidth}px`,\r\n        top: `${elementTop}px`,\r\n        right: '',\r\n        bottom: '',\r\n        left: `${elementLeft}px`,\r\n        float: '',\r\n        margin: '0px',\r\n      };\r\n\r\n      return styles;\r\n    }\r\n\r\n    const { container, stickyComputed, viewportHeight } = computation.snap;\r\n\r\n    // when state is sticked\r\n    if (state === 'sticked') {\r\n      const positionBottom = stickyComputed.positionBottom;\r\n\r\n      let elementTop: number;\r\n      let elementLeft: number;\r\n\r\n      if (this.container !== this.rootContainer) {\r\n        const ghostRelativeRect = getElementRelativeRect(win, ghost);\r\n\r\n        elementLeft = ghostRelativeRect.left;\r\n\r\n        if (ghostParentIsRootElement) {\r\n          elementTop = container.top;\r\n\r\n          elementTop += win.document.documentElement.offsetTop;\r\n          elementLeft += win.document.documentElement.offsetLeft;\r\n        } else {\r\n          const ghostParentRect = getElementAbsoluteRect(ghostParent);\r\n\r\n          elementTop = computation.viewportTop - ghostParentRect.top;\r\n        }\r\n\r\n        if (positionBottom) {\r\n          elementTop += viewportHeight - stickyComputed.height - computation.offsetSticked - computation.offsetStucked;\r\n        } else {\r\n          elementTop += computation.offsetSticked + computation.offsetStucked;\r\n        }\r\n\r\n        return {\r\n          position: 'absolute',\r\n          top: `${elementTop}px`,\r\n          bottom: '',\r\n          left: `${elementLeft}px`,\r\n        };\r\n      } else {\r\n        const ghostRect = getElementAbsoluteRect(ghost);\r\n\r\n        elementTop = computation.offsetSticked + computation.offsetStucked;\r\n        elementLeft = ghostRect.left + win.document.documentElement.offsetLeft;\r\n\r\n        return {\r\n          position: 'fixed',\r\n          top: !positionBottom ? `${elementTop}px` : '',\r\n          bottom: positionBottom ? `${elementTop}px` : '',\r\n          left: `${elementLeft}px`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // when state is stucked\r\n    if (state === 'stucked') {\r\n      const ghostRect = getElementAbsoluteRect(ghost);\r\n\r\n      let elementTop: number;\r\n      let elementLeft: number;\r\n\r\n      elementTop = getStuckedPositionTop(computation);\r\n\r\n      elementLeft = ghostRect.left;\r\n\r\n      if (ghostParentIsRootElement) {\r\n        if (this.container !== this.rootContainer) {\r\n          // we can't use computation.viewportTop because it's absolute viewport top\r\n          const relativeViewportTop = this.container.getViewportTop();\r\n\r\n          elementTop -= relativeViewportTop;\r\n        }\r\n\r\n        elementTop += win.document.documentElement.offsetTop;\r\n        elementLeft += win.document.documentElement.offsetLeft;\r\n      } else {\r\n        const ghostParentRect = getElementAbsoluteRect(ghostParent);\r\n\r\n        elementTop -= ghostParentRect.top;\r\n        elementLeft -= ghostParentRect.left;\r\n      }\r\n\r\n      return {\r\n        position: 'absolute',\r\n        top: `${elementTop}px`,\r\n        bottom: '',\r\n        left: `${elementLeft}px`,\r\n      };\r\n    }\r\n\r\n    // throw new Error(`Invalid state: ${state}`);\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns sticky ghost style.\r\n   *\r\n   * @returns Styles of the sticky ghost\r\n   */\r\n  _getStickyGhostStyle(): NgxStickyGhostStyle {\r\n    const stickySpacer = this.config.spacer || this._spacerGenerated;\r\n\r\n    if (!this._win || !stickySpacer) {\r\n      return null;\r\n    }\r\n\r\n    const element = this.elementRef.nativeElement;\r\n    const elementStyle = this._win.getComputedStyle(element);\r\n    const elementnBorderBox = elementStyle.boxSizing === 'border-box';\r\n\r\n    let ghostHeight = element.offsetHeight;\r\n    // const ghostWidth = elementStyle.width;\r\n\r\n    // substract borders and paddings when element isn't border-boxed\r\n    if (!elementnBorderBox) {\r\n      ghostHeight +=\r\n        // substract vertical borders\r\n        - (parseFloat(elementStyle.borderTopWidth) || 0)\r\n        - (parseFloat(elementStyle.borderBottomWidth) || 0)\r\n        // substract vertical paddings\r\n        - (parseFloat(elementStyle.paddingTop) || 0)\r\n        - (parseFloat(elementStyle.paddingBottom) || 0);\r\n    }\r\n\r\n    const styles: NgxStickyGhostStyle = {\r\n      boxSizing: elementStyle.boxSizing,\r\n      position: elementStyle.position,\r\n      top: elementStyle.top,\r\n      right: elementStyle.right,\r\n      bottom: elementStyle.bottom,\r\n      left: elementStyle.left,\r\n      width: element.style.width,\r\n      // width: element.style.width || elementStyle.width,\r\n      // width: `${ghostWidth}px`,\r\n      height: `${ghostHeight}px`,\r\n      maxHeight: `${ghostHeight}px`,\r\n      minHeight: `${ghostHeight}px`,\r\n      borderTop: elementStyle.borderTop,\r\n      borderBottom: elementStyle.borderBottom,\r\n      borderLeft: elementStyle.borderLeft,\r\n      borderRight: elementStyle.borderRight,\r\n      // borderColor: 'transparent',\r\n      cssFloat: elementStyle.cssFloat,\r\n      marginTop: elementStyle.marginTop,\r\n      marginBottom: elementStyle.marginBottom,\r\n      marginLeft: elementStyle.marginLeft,\r\n      marginRight: elementStyle.marginRight,\r\n      paddingTop: elementStyle.paddingTop,\r\n      paddingBottom: elementStyle.paddingBottom,\r\n      paddingLeft: elementStyle.paddingLeft,\r\n      paddingRight: elementStyle.paddingRight,\r\n    };\r\n\r\n    // if (this.config.orbit) {\r\n    //   styles.position = 'absolute';\r\n    //   styles.width = element.style.width || elementStyle.width;\r\n    // }\r\n\r\n    return styles;\r\n  }\r\n\r\n  /**\r\n   * Hides sticky ghost.\r\n   */\r\n  _hideStickyGhost(): void {\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n\r\n    if (!ghost) {\r\n      return;\r\n    }\r\n\r\n    this.renderer.setStyle(ghost, 'display', 'none');\r\n  }\r\n\r\n  /**\r\n   * Init sticky monitoring.\r\n   */\r\n  _initMonitoring(): void {\r\n    if (!this._win || this._monitoring) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      const handleRefreshSubscription = this._refresh$\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          distinctUntilChanged(),\r\n          throttleTime(0, animationFrameScheduler, { leading: true, trailing: true }),\r\n          share(),\r\n        )\r\n        .subscribe(computation => {\r\n          this._refreshSticky(computation);\r\n        });\r\n\r\n      const triggerUpdateSubscription = this._createMonitoringObservable()\r\n        .pipe(\r\n          takeUntil(this._destroyed$),\r\n          share(),\r\n        )\r\n        .subscribe(fastUpdate => {\r\n          this.update(fastUpdate);\r\n        });\r\n\r\n      this._monitoring = new Subscription();\r\n      this._monitoring.add(handleRefreshSubscription);\r\n      this._monitoring.add(triggerUpdateSubscription);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Inserts sticky ghost generated.\r\n   */\r\n  _insertStickyGhostGenerated(): void {\r\n    if (this._spacerGenerated) {\r\n      return;\r\n    }\r\n\r\n    const element = this.elementRef.nativeElement;\r\n\r\n    const ghost = this.renderer.createElement(element.tagName);\r\n    this.renderer.addClass(ghost, 'ngx-sticky-spacer');\r\n    // this.renderer.setStyle(ghost, 'borderStyle', 'solid');\r\n    // this.renderer.setStyle(ghost, 'borderColor', 'transparent');\r\n    this.renderer.insertBefore(element.parentElement, ghost, element);\r\n\r\n    this._spacerGenerated = ghost;\r\n  }\r\n\r\n  /**\r\n   * Log nested sticky error and returns `true` when sticky is in another sticky.\r\n   *\r\n   * @returns `true` when sticky is in another sticky\r\n   */\r\n  _preventNestedStickyError(): boolean {\r\n    if (!this.stickyParent) {\r\n      return false;\r\n    }\r\n\r\n    const nestedStickyError = new Error('Nested sticky is not support. Sticky will not work.');\r\n\r\n    const logLevel = isDevMode() ? 'error' : 'warn';\r\n    const logLevelLogger = console[logLevel];\r\n\r\n    logLevelLogger(nestedStickyError);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Refresh sticky with given computation.\r\n   *\r\n   * @param computation Sticky state computation\r\n   */\r\n  _refreshSticky(computation: NgxStickyComputation): void {\r\n    if (\r\n      // refresh sticky when state has changed\r\n      computation.state !== this._stickyElementState\r\n      // or when sticky is in container (other than window)\r\n      || this.container !== this.rootContainer\r\n    ) {\r\n      this._refreshStickyElement(computation.state, computation);\r\n    }\r\n\r\n    this._stickyComputation = computation;\r\n    this.stickyComputation.next(computation);\r\n\r\n    if (computation.state === this._stickyState) {\r\n      return;\r\n    }\r\n\r\n    this.ngZone.run(() => {\r\n      this._stickyState = computation.state;\r\n      this.stickyState.next(computation.state);\r\n\r\n      // this.changeDetectorRef.detectChanges();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refreshs sticky element style.\r\n   *\r\n   * @param state Sticky state\r\n   * @param computation Sticky state computation when state is sticked or stucked\r\n   */\r\n  _refreshStickyElement(state: NgxStickyState, computation?: NgxStickyComputation): void {\r\n    if (!this._win) {\r\n      return;\r\n    }\r\n\r\n    // hide ghost and refresh original style when state is null\r\n    if (!state) {\r\n      this._stickyElementState = null;\r\n\r\n      this._hideStickyGhost();\r\n      this._restoreStickyElementStyle();\r\n\r\n      return;\r\n    }\r\n\r\n    this._stickyElementState = state;\r\n\r\n    this._saveStickyElementStyle();\r\n    this._showStickyGhost();\r\n\r\n    const elementStyle = this._getStickyElementStyle(state, computation);\r\n\r\n    setElementStyles(this.renderer, this.elementRef.nativeElement, elementStyle);\r\n  }\r\n\r\n  /**\r\n   * Refreshs sticky ghost.\r\n   */\r\n  _refreshStickyGhost(): void {\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n    const ghostStyle = this._getStickyGhostStyle();\r\n\r\n    setElementStyles(this.renderer, ghost, ghostStyle);\r\n  }\r\n\r\n  /**\r\n   * Restore original styles of the sticky.\r\n   */\r\n  _restoreStickyElementStyle(): void {\r\n    setElementStyles(this.renderer, this.elementRef.nativeElement, this._elementOriginStyle);\r\n    this._elementOriginStyle = null;\r\n  }\r\n\r\n  /**\r\n   * Saves origin styles of the sticky.\r\n   */\r\n  _saveStickyElementStyle(): void {\r\n    if (!this._elementOriginStyle) {\r\n      this._elementOriginStyle = {\r\n        position: this.elementRef.nativeElement.style.position,\r\n        width: this.elementRef.nativeElement.style.width,\r\n        top: this.elementRef.nativeElement.style.top,\r\n        right: this.elementRef.nativeElement.style.right,\r\n        bottom: this.elementRef.nativeElement.style.bottom,\r\n        left: this.elementRef.nativeElement.style.left,\r\n        cssFloat: this.elementRef.nativeElement.style.cssFloat,\r\n        margin: this.elementRef.nativeElement.style.margin,\r\n        marginTop: this.elementRef.nativeElement.style.marginTop,\r\n        marginRight: this.elementRef.nativeElement.style.marginRight,\r\n        marginBottom: this.elementRef.nativeElement.style.marginBottom,\r\n        marginLeft: this.elementRef.nativeElement.style.marginLeft,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shows sticky ghost.\r\n   */\r\n  _showStickyGhost(): void {\r\n    if (!this.config.spacer && !this._spacerGenerated) {\r\n      this._insertStickyGhostGenerated();\r\n      this._refreshStickyGhost();\r\n\r\n      return;\r\n    } else if (this.config.spacer && this._spacerGenerated) {\r\n      this._spacerGenerated.remove();\r\n      this._spacerGenerated = null;\r\n    }\r\n\r\n    const ghost = this.config.spacer || this._spacerGenerated;\r\n\r\n    if (ghost.style.display === 'none') {\r\n      this.renderer.setStyle(ghost, 'display', 'block');\r\n      this._refreshStickyGhost();\r\n    }\r\n  }\r\n}\r\n","import {\r\n  NgxStickyComputation,\r\n  NgxStickyDirection,\r\n  NgxStickyPosition,\r\n} from './sticky.types';\r\n\r\n\r\nexport function coerceStickyPosition(value: any): NgxStickyPosition {\r\n  return isStickyPositionBottom(value) ? 'bottom' : 'top';\r\n}\r\n\r\nexport function coerceStickyDirection(value: any): NgxStickyDirection {\r\n  return isStickyDirectionDown(value) ? 'down' : 'up';\r\n}\r\n\r\n\r\nexport function getStuckedPositionTop(computation: NgxStickyComputation): number {\r\n  const {\r\n    boundary,\r\n    directionDown,\r\n    height: elementHeight,\r\n    positionBottom,\r\n  } = computation.snap.stickyComputed;\r\n\r\n  return directionDown\r\n    ? boundary.top\r\n      + boundary.height\r\n      - elementHeight\r\n      - (positionBottom\r\n          ? computation.offsetStucked\r\n          : boundary.offsetBottom - elementHeight - computation.offsetStucked)\r\n    : positionBottom\r\n      ? boundary.top + boundary.offsetTop - elementHeight - computation.offsetStucked\r\n      : boundary.top + computation.offsetStucked;\r\n}\r\n\r\n\r\nexport function isStickyPositionBottom(position: NgxStickyPosition) {\r\n  return position === 'bottom';\r\n}\r\n\r\nexport function isStickyDirectionDown(direction: NgxStickyDirection) {\r\n  return direction !== 'up';\r\n}\r\n","import { CommonModule } from '@angular/common';\r\nimport { NgModule } from '@angular/core';\r\n\r\nimport { NgxInViewportDirective } from './in-viewport.directive';\r\nimport { NgxStickyBoundaryDirective } from './sticky-boundary.directive';\r\nimport { NgxStickyContainerDirective } from './sticky-container.directive';\r\nimport { NgxStickySpotDirective } from './sticky-spot.directive';\r\nimport { NgxStickyDirective } from './sticky.directive';\r\n\r\n/**\r\n * Adds sticky directives and providers.\r\n *\r\n * Managing sticky elements is one of the hardest parts of building web applications.\r\n *\r\n * The NgxStickyModule allows to manage sticky elements in the best way.\r\n *\r\n * @example\r\n * NgxStickyModule can be imported multiple times: once per lazily-loaded bundle.\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [ NgxStickyModule ]\r\n * })\r\n * class MyNgModule {}\r\n * ```\r\n */\r\n@NgModule({\r\n  declarations: [\r\n    NgxInViewportDirective,\r\n    NgxStickyBoundaryDirective,\r\n    NgxStickyContainerDirective,\r\n    NgxStickyDirective,\r\n    NgxStickySpotDirective,\r\n  ],\r\n  exports: [\r\n    NgxInViewportDirective,\r\n    NgxStickyBoundaryDirective,\r\n    NgxStickyContainerDirective,\r\n    NgxStickyDirective,\r\n    NgxStickySpotDirective,\r\n  ],\r\n  imports: [ CommonModule ],\r\n})\r\nexport class NgxStickyModule { }\r\n","import { InjectionToken } from '@angular/core';\r\n\r\n\r\nexport const NGX_STICKY_WINDOW = new InjectionToken<Window>('NGX_STICKY_WINDOW', {\r\n  providedIn: 'root',\r\n  factory: () => typeof window !== 'undefined' ? window : null,\r\n});\r\n","/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\r\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nexport function coerceBooleanProperty(value: any): boolean {\r\n  return value != null && `${value}` !== 'false';\r\n}\r\n\r\n\r\n/** Coerces a data-bound value (typically a string) to a number. */\r\nexport function coerceNumberProperty(value: any): number;\r\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\r\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\r\n  return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nexport function _isNumberValue(value: any): boolean {\r\n  // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n  // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n  // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n  return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\r\n}\r\n","\r\n\r\n/**\r\n * Add entry into set.\r\n *\r\n * @param set Array list\r\n * @param entry Entry to add\r\n * @returns Entry index added\r\n */\r\nexport function addEntry<T>(set: T[], entry: T): number {\r\n  let entryIndex = set.indexOf(entry);\r\n\r\n  if (entryIndex === -1) {\r\n    entryIndex = set.length;\r\n\r\n    set[entryIndex] = entry;\r\n  }\r\n\r\n  return entryIndex;\r\n}\r\n\r\n\r\n/**\r\n * Delete entry from set.\r\n *\r\n * @param set Array list\r\n * @param entry Entry to delete\r\n * @returns Entry index deleted\r\n */\r\nexport function deleteEntry<T>(set: T[], entry: T): number {\r\n  const entryIndex = set.indexOf(entry);\r\n\r\n  if (entryIndex !== -1) {\r\n    set.splice(entryIndex, 1);\r\n  }\r\n\r\n  return entryIndex;\r\n}\r\n","import { Subject, Subscription } from 'rxjs';\r\n\r\nimport { InputCoercionFn, InputSubject, InputSubjectChange, InputSubjectNextOptions } from './input-subject';\r\n\r\n\r\nexport type ConfigInputSubjects<T> = { [K in keyof T]: InputSubject<T[K]> };\r\nexport type ConfigSubjectChanges<T> = { [K in keyof T]: InputSubjectChange<T[K]> };\r\nexport type ConfigSubjectSchema<T> = { [K in keyof T]: ConfigSubjectInputOptions<T, K> };\r\n\r\nexport interface ConfigSubjectInputOptions<T, K extends keyof T> {\r\n  defaultValue: T[K];\r\n  aliasKey?: string;\r\n  coercion?: InputCoercionFn<T[K]>;\r\n}\r\n\r\n\r\n/**\r\n * A ConfigSubject is an Observable that coerces key-values and emit when change is detected\r\n */\r\nexport class ConfigSubject<T> extends Subject<T> {\r\n  /** Emit key-values changes */\r\n  readonly changes$ = new Subject<ConfigSubjectChanges<T>>();\r\n  /** Input subjects for each config key-value */\r\n  readonly inputs: ConfigInputSubjects<T>;\r\n\r\n  _config: T;\r\n  _configChanged: boolean;\r\n  _configChanges: ConfigSubjectChanges<T>;\r\n\r\n  readonly _aliases: { [key: string]: keyof T };\r\n\r\n  readonly _pushChangesSubscription = new Subscription();\r\n\r\n  constructor(schema: ConfigSubjectSchema<T>) {\r\n    super();\r\n\r\n    this.inputs = {} as ConfigInputSubjects<T>;\r\n    this._config = {} as T;\r\n    this._configChanges = {} as ConfigSubjectChanges<T>;\r\n    this._aliases = {};\r\n\r\n    const inputKeys = Object.keys(schema) as (keyof T)[];\r\n\r\n    for (const inputKey of inputKeys) {\r\n      const inputOptions = schema[inputKey];\r\n\r\n      if (inputOptions.aliasKey) {\r\n        this._aliases[inputOptions.aliasKey] = inputKey;\r\n      }\r\n\r\n      const input = new InputSubject<T[keyof T]>(inputOptions.defaultValue, inputOptions.coercion);\r\n\r\n      this._config[inputKey] = inputOptions.defaultValue;\r\n      this.inputs[inputKey] = input;\r\n\r\n      const pushChangeSubscription = input.change$.subscribe(inputChange => {\r\n        this._configChanged = true;\r\n        this._configChanges[inputKey] = inputChange;\r\n\r\n        this._config = { ...this._config };\r\n        this._config[inputKey] = inputChange.currentValue;\r\n      });\r\n\r\n      this._pushChangesSubscription.add(pushChangeSubscription);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns current config.\r\n   */\r\n  getValue(): T {\r\n    return this._config;\r\n  }\r\n\r\n  /**\r\n   * Returns key-value.\r\n   *\r\n   * @param inputKey Input key\r\n   * @returns key-value\r\n   */\r\n  getKeyValue<K extends keyof T>(inputKey: K): T[K] {\r\n    return this._config[inputKey];\r\n  }\r\n\r\n  /**\r\n   * Emit next config.\r\n   *\r\n   * @param partialConfig Partial next config\r\n   * @param options Options to skip coercion\r\n   */\r\n  next(partialConfig?: Partial<T>, options?: InputSubjectNextOptions): void {\r\n    const inputKeys = Object.keys(partialConfig);\r\n\r\n    for (const key of inputKeys) {\r\n      const inputKey = (this._aliases[key] || key) as keyof T;\r\n\r\n      if (inputKey in this.inputs) {\r\n        const inputValue = partialConfig[key] as T[keyof T];\r\n        const inputSubject = this.inputs[inputKey];\r\n\r\n        inputSubject.next(inputValue, options);\r\n      }\r\n    }\r\n\r\n    if (this._configChanged) {\r\n      const changes = { ...this._configChanges };\r\n\r\n      this._configChanged = false;\r\n      this._configChanges = {} as ConfigSubjectChanges<T>;\r\n\r\n      this.changes$.next(changes);\r\n\r\n      super.next(this._config);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit next key-value.\r\n   *\r\n   * @param inputKey Input key\r\n   * @param value key-value\r\n   * @param options Options to skip coercion\r\n   */\r\n  nextKeyValue<K extends keyof T>(inputKey: K, value: T[K], options?: InputSubjectNextOptions): void {\r\n    this.next({ [inputKey]: value } as {} as Partial<T>, options);\r\n  }\r\n\r\n  /**\r\n   * Apply simple changes as like ngOnChange(changes: SimpleChanges) input.\r\n   *\r\n   * @param changes Simple changes\r\n   */\r\n  nextChanges(changes: { [key: string]: { currentValue: any } }) {\r\n    const changeKeys = Object.keys(changes);\r\n    const config: Partial<T> = {};\r\n\r\n    for (const inputKey of changeKeys) {\r\n      config[inputKey] = changes[inputKey].currentValue;\r\n    }\r\n\r\n    this.next(config);\r\n  }\r\n}\r\n","import { Renderer2 } from '@angular/core';\r\n\r\n\r\n/**\r\n * Returns getter for document height.\r\n *\r\n * @param win Window reference\r\n * @returns Getter for document height.\r\n */\r\nexport function getDocumentHeightFactory(win: Window): () => number {\r\n  if (!win) {\r\n    return () => 0;\r\n  }\r\n\r\n  const documentHeightGetters = [\r\n    () => win.document.body.scrollHeight,\r\n    () => win.document.documentElement.scrollHeight,\r\n    () => win.document.body.offsetHeight,\r\n    () => win.document.documentElement.offsetHeight,\r\n    () => win.document.body.clientHeight,\r\n    () => win.document.documentElement.clientHeight,\r\n  ];\r\n\r\n  let documentHeightGetter = documentHeightGetters[0];\r\n  let documentHeight = 0;\r\n\r\n  for (const _documentHeightGetter of documentHeightGetters) {\r\n    const _documentHeight = _documentHeightGetter();\r\n\r\n    if (_documentHeight > documentHeight) {\r\n      documentHeightGetter = _documentHeightGetter;\r\n      documentHeight = _documentHeight;\r\n    }\r\n  }\r\n\r\n  return documentHeightGetter;\r\n}\r\n\r\n\r\n/**\r\n * Returns getter for document width.\r\n *\r\n * @param win Window reference\r\n * @returns Getter for document width.\r\n */\r\nexport function getDocumentWidthFactory(win: Window): () => number {\r\n  if (!win) {\r\n    return () => 0;\r\n  }\r\n\r\n  const documentWidthGetters = [\r\n    () => win.document.body.scrollWidth,\r\n    () => win.document.documentElement.scrollWidth,\r\n    () => win.document.body.offsetWidth,\r\n    () => win.document.documentElement.offsetWidth,\r\n    () => win.document.body.clientWidth,\r\n    () => win.document.documentElement.clientWidth,\r\n  ];\r\n\r\n  let documentWidthGetter = documentWidthGetters[0];\r\n  let documentWidth = 0;\r\n\r\n  for (const _documentWidthGetter of documentWidthGetters) {\r\n    const _documentWidth = _documentWidthGetter();\r\n\r\n    if (_documentWidth > documentWidth) {\r\n      documentWidthGetter = _documentWidthGetter;\r\n      documentWidth = _documentWidth;\r\n    }\r\n  }\r\n\r\n  return documentWidthGetter;\r\n}\r\n\r\n\r\n/**\r\n * Returns element absolute rect.\r\n *\r\n * @param element Element\r\n * @returns Element absolute rect\r\n */\r\nexport function getElementAbsoluteRect(element: HTMLElement) {\r\n  const rect = {\r\n    height: element.offsetHeight,\r\n    width: element.offsetWidth,\r\n    left: 0,\r\n    top: 0,\r\n  };\r\n\r\n  let currentElement = element;\r\n\r\n  do {\r\n    rect.top += currentElement.offsetTop || 0;\r\n    rect.left += currentElement.offsetLeft || 0;\r\n\r\n    currentElement = currentElement.offsetParent as HTMLElement;\r\n  } while (currentElement);\r\n\r\n  return rect;\r\n}\r\n\r\n\r\n/**\r\n * Returns element relative rect.\r\n *\r\n * @param win Window reference\r\n * @param element Element\r\n * @returns Element relative rect.\r\n */\r\nexport function getElementRelativeRect(win: Window, element: HTMLElement) {\r\n  const rect = {\r\n    height: element.offsetHeight,\r\n    width: element.offsetWidth,\r\n    left: 0,\r\n    top: 0,\r\n  };\r\n\r\n  let currentElement = element;\r\n  let currentElementStyle: CSSStyleDeclaration;\r\n\r\n  do {\r\n    currentElementStyle = currentElement !== element ? win.getComputedStyle(currentElement) : {} as CSSStyleDeclaration;\r\n\r\n    if (currentElementStyle.position === 'relative') {\r\n      break;\r\n    }\r\n\r\n    if (currentElementStyle.position !== 'absolute') {\r\n      rect.top += currentElement.offsetTop || 0;\r\n      rect.left += currentElement.offsetLeft || 0;\r\n    }\r\n\r\n    currentElement = currentElement.offsetParent as HTMLElement;\r\n  } while (currentElement);\r\n\r\n  return rect;\r\n}\r\n\r\n\r\n/**\r\n * Get window viewport height.\r\n *\r\n * @param win Window reference\r\n * @returns Window viewport height\r\n */\r\nexport function getWindowViewportHeight(win: Window): number {\r\n  return win && win.innerHeight || 0;\r\n}\r\n\r\n\r\n/**\r\n * Get window scroll left position.\r\n *\r\n * @param win Window reference\r\n * @returns Window scroll left position\r\n */\r\nexport function getWindowViewportLeft(win: Window): number {\r\n  if (!win) {\r\n    return 0;\r\n  }\r\n\r\n  // The top-left-corner of the viewport is determined by the scroll position of the document\r\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n  // `document.documentElement` works consistently, where the `top` and `left` values will\r\n  // equal negative the scroll position.\r\n  const documentRect = win.document.documentElement.getBoundingClientRect();\r\n\r\n  return -documentRect.left\r\n    || win.document.body.scrollLeft\r\n    || win.scrollX\r\n    || win.document.documentElement.scrollLeft\r\n    || 0;\r\n}\r\n\r\n\r\n/**\r\n * Get window scroll top position.\r\n *\r\n * @param win Window reference\r\n * @returns Window scroll top position\r\n */\r\nexport function getWindowViewportTop(win: Window): number {\r\n  if (!win) {\r\n    return 0;\r\n  }\r\n\r\n  // The top-left-corner of the viewport is determined by the scroll position of the document\r\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n  // `document.documentElement` works consistently, where the `top` and `left` values will\r\n  // equal negative the scroll position.\r\n  const documentRect = win.document.documentElement.getBoundingClientRect();\r\n\r\n  return -documentRect.top\r\n    || win.document.body.scrollTop\r\n    || win.scrollY\r\n    || win.document.documentElement.scrollTop\r\n    || 0;\r\n}\r\n\r\n\r\n/**\r\n * Returns `true` when element is scrollable.\r\n *\r\n * @param win Window reference\r\n * @param element Element\r\n * @returns `true` when element is scrollable\r\n */\r\nexport function isElementScrollableY(win: Window, element: HTMLElement): boolean {\r\n  return element.offsetHeight < element.scrollHeight && win.getComputedStyle(element).overflowY === 'auto';\r\n}\r\n\r\n\r\n/**\r\n * Set styles on a given element.\r\n *\r\n * @param renderer Renderer2 instance\r\n * @param element Element\r\n * @param styles Styles\r\n */\r\nexport function setElementStyles(\r\n  renderer: Renderer2,\r\n  element: HTMLElement,\r\n  styles: any,\r\n): void {\r\n  if (!element || !styles) {\r\n    return;\r\n  }\r\n\r\n  const propKeys = Object.keys(styles);\r\n\r\n  for (const prop of propKeys) {\r\n    const value = styles[prop];\r\n\r\n    if (value) {\r\n      renderer.setStyle(element, prop, value);\r\n    } else {\r\n      renderer.removeStyle(element, prop);\r\n    }\r\n  }\r\n}\r\n\r\n","import { Observable, fromEvent, merge, of } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\n\r\n\r\n/**\r\n * Create observable which emit image events.\r\n *\r\n * @param element Element\r\n * @returns Observable on image events\r\n */\r\nexport function fromImageEvents(element: HTMLElement): Observable<{ event: Event; target: HTMLImageElement }> {\r\n  if (!element) {\r\n    return of();\r\n  }\r\n\r\n  const images$: Observable<{ event: Event; target: HTMLImageElement }>[] = [];\r\n\r\n  const addImage = (target: HTMLImageElement) => images$.push(\r\n    fromEvent(target, 'load').pipe(map(event => ({ event, target }))),\r\n    fromEvent(target, 'error').pipe(map(event => ({ event, target }))),\r\n  );\r\n\r\n  // if (element instanceof HTMLImageElement) {\r\n  if (element.tagName === 'IMG' || element.tagName === 'img') {\r\n    addImage(element as HTMLImageElement);\r\n  } else {\r\n    element.querySelectorAll('img').forEach(addImage);\r\n  }\r\n\r\n  return merge(...images$);\r\n}\r\n","import { BehaviorSubject, Observable, of } from 'rxjs';\r\n\r\n/**\r\n * Create observable which emit media query events.\r\n *\r\n * @param win Window reference\r\n * @param query Media query\r\n * @returns Observable on media query events\r\n */\r\nexport function fromMediaQuery(win: Window, query: string): Observable<MediaQueryListEvent> {\r\n  if (!win || !win.matchMedia) {\r\n    return of();\r\n  }\r\n\r\n  const mql = win.matchMedia(query);\r\n\r\n  const initEvent = {\r\n    matches: mql.matches,\r\n    media: query,\r\n  };\r\n\r\n  const initMqlEvent = typeof MediaQueryListEvent !== 'undefined'\r\n    ? new MediaQueryListEvent('change', initEvent)\r\n    : { type: 'change', ...initEvent} as MediaQueryListEvent;\r\n\r\n  const mql$ = new BehaviorSubject<MediaQueryListEvent>(initMqlEvent);\r\n\r\n  const onQueryChange = (mqlEvent: MediaQueryListEvent) => mql$.next(mqlEvent);\r\n  const complete = mql$.complete;\r\n\r\n  mql$.complete = function() {\r\n    complete.call(mql$);\r\n    mql.removeListener(onQueryChange);\r\n  };\r\n\r\n  mql.addListener(onQueryChange);\r\n\r\n  return mql$;\r\n}\r\n","export * from './coercion';\r\nexport * from './collections';\r\nexport * from './config-subject';\r\nexport * from './dom';\r\nexport * from './from-image-events';\r\nexport * from './from-media-query';\r\nexport * from './input-subject';\r\nexport * from './intersection';\r\n","import { Subject } from 'rxjs';\r\n\r\n\r\nexport type InputCoercionFn<T> = (value: T) => T;\r\n\r\nexport interface InputSubjectNextOptions {\r\n  skipCoercion?: boolean;\r\n}\r\n\r\nexport interface InputSubjectChange<T> {\r\n  previousValue: T;\r\n  currentValue: T;\r\n  firstChange: boolean;\r\n}\r\n\r\n\r\n/**\r\n * An InputSubject is an Observable that coerces values and emit when change is detected.\r\n */\r\nexport class InputSubject<T> extends Subject<T> {\r\n  /** Emit value changes */\r\n  readonly change$ = new Subject<InputSubjectChange<T>>();\r\n\r\n  _firstChange = true;\r\n  _value: T;\r\n  _valueSetted: T;\r\n\r\n  constructor(\r\n    readonly defaultValue: T,\r\n    readonly coercion?: InputCoercionFn<T>,\r\n  ) {\r\n    super();\r\n\r\n    this._value = defaultValue;\r\n  }\r\n\r\n  /**\r\n   * Returns current value.\r\n   */\r\n  getValue(): T {\r\n    return this._value;\r\n  }\r\n\r\n  /**\r\n   * Emit next value.\r\n   *\r\n   * @param value Next value\r\n   * @param options Options to skip coercion\r\n   */\r\n  next(value?: T, options?: InputSubjectNextOptions): void {\r\n    if (!options || !options.skipCoercion) {\r\n      if (value === this._valueSetted) {\r\n        return;\r\n      }\r\n\r\n      this._valueSetted = value;\r\n\r\n      if (this.coercion) {\r\n        value = this.coercion(value);\r\n      }\r\n    }\r\n\r\n    if (value !== this._value) {\r\n      const firstChange = this._firstChange;\r\n      const previousValue = this._value;\r\n\r\n      this._firstChange = false;\r\n      this._value = value;\r\n\r\n      this.change$.next({\r\n        previousValue,\r\n        currentValue: value,\r\n        firstChange,\r\n      });\r\n\r\n      super.next(value);\r\n    }\r\n  }\r\n}\r\n","\r\n\r\n/** Coerces a data-bound value (typically a string) to intersection thresholds. */\r\nexport function coerceIntersectionThresholds(thresholds: any) {\r\n  if (typeof thresholds === 'number') {\r\n    return [ thresholds ];\r\n  }\r\n\r\n  if (typeof thresholds === 'string') {\r\n    return (thresholds as string)\r\n      .split(',')\r\n      .map(x => (parseFloat(x) || 0))\r\n      .sort();\r\n  }\r\n\r\n  if (!thresholds) {\r\n    return [ 0, 1 ];\r\n  }\r\n\r\n  if (!Array.isArray(thresholds)) {\r\n    thresholds = [ thresholds ];\r\n  }\r\n\r\n  return [ ...thresholds ].sort();\r\n}\r\n\r\n\r\n/**\r\n * Returns threshold crossed for a given ratio change.\r\n *\r\n * @param thresholds Thresholds\r\n * @param oldRatio Old ratio\r\n * @param newRatio New ratio\r\n * @returns Threshold crossed or `undefined`\r\n */\r\nexport function getCrossedThreshold(thresholds: number[], oldRatio: number, newRatio: number): number {\r\n  let crossedThreshold: number;\r\n\r\n  for (const threshold of thresholds) {\r\n    if (\r\n      // threshold is perfect-crossed by old ratio\r\n      threshold === oldRatio\r\n      // or threshold is perfect-crossed by new ratio\r\n      || threshold === newRatio\r\n      // or threshold is crossed by new ratio and old ratio (there are on the opposite sides)\r\n      || threshold < oldRatio !== threshold < newRatio\r\n    ) {\r\n      crossedThreshold = threshold;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return crossedThreshold;\r\n}\r\n","/*\r\n * Public API Surface of @enten/ngx-sticky\r\n */\r\n\r\nexport * from './lib/in-viewport.directive';\r\nexport * from './lib/sticky-base-boundary.controller';\r\nexport * from './lib/sticky-base-container.controller';\r\nexport * from './lib/sticky-base-container.directive';\r\nexport * from './lib/sticky-base.controller';\r\nexport * from './lib/sticky-boundary.directive';\r\nexport * from './lib/sticky-container.directive';\r\nexport * from './lib/sticky-engine';\r\nexport * from './lib/sticky-root-container.controller';\r\nexport * from './lib/sticky-spot.directive';\r\nexport * from './lib/sticky.directive';\r\nexport * from './lib/sticky.helpers';\r\nexport * from './lib/sticky.module';\r\nexport * from './lib/sticky.tokens';\r\nexport * from './lib/sticky.types';\r\nexport * from './lib/utils';\r\n","import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\n\r\nconst routes: Routes = [];\r\n\r\n@NgModule({\r\n  imports: [ RouterModule.forRoot(routes) ],\r\n  exports: [ RouterModule ],\r\n})\r\nexport class AppRoutingModule { }\r\n","import { ChangeDetectorRef, Component, Inject, OnDestroy, OnInit } from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\n\r\nimport {\r\n  NGX_STICKY_WINDOW,\r\n  NgxStickyDirection,\r\n  NgxStickyPosition,\r\n  fromMediaQuery,\r\n} from '../../projects/ngx-sticky/src/public-api';\r\n\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: [ './app.component.scss' ],\r\n})\r\nexport class AppComponent implements OnDestroy, OnInit  {\r\n  apiBoundaryStickyDisabled = false;\r\n  apiBoundaryStickyOrbit = false;\r\n  apiBoundaryStickyDirection: NgxStickyDirection = 'down';\r\n  apiBoundaryStickyPosition: NgxStickyPosition = 'top';\r\n\r\n  apiContainerStickyDisabled = false;\r\n  apiContainerStickyOrbit = false;\r\n  apiContainerStickyDirection: NgxStickyDirection = 'down';\r\n  apiContainerStickyOffsetTop = 0;\r\n  apiContainerStickyOffsetBottom = 0;\r\n  apiContainerStickyPosition: NgxStickyPosition = 'top';\r\n\r\n  apiInViewportStickyDisabled = false;\r\n  apiInViewportStickyOrbit = false;\r\n  apiInViewportStickyDirection: NgxStickyDirection = 'down';\r\n  apiInViewportStickyPosition: NgxStickyPosition = 'top';\r\n\r\n  _isSmallScreen: boolean;\r\n  _smallBreakpointSubscription: Subscription;\r\n\r\n  constructor(\r\n    readonly changeDetectorRef: ChangeDetectorRef,\r\n    @Inject(NGX_STICKY_WINDOW)\r\n    readonly win: Window,\r\n  ) { }\r\n\r\n  ngOnInit(): void {\r\n    const smallBreakpoint$ = fromMediaQuery(this.win, '(min-width: 640px)');\r\n\r\n    this._smallBreakpointSubscription = smallBreakpoint$.subscribe(mqlEvent => {\r\n      this._isSmallScreen = !mqlEvent.matches;\r\n    });\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    if (this._smallBreakpointSubscription) {\r\n      this._smallBreakpointSubscription.unsubscribe();\r\n      this._smallBreakpointSubscription = null;\r\n    }\r\n  }\r\n}\r\n","<nav ngx-sticky class=\"navigation\">\r\n  <section class=\"container\">\r\n    <a href=\"https://github.com/enten/ngx-sticky\">\r\n      <h1>ngx-sticky</h1>\r\n    </a>\r\n  </section>\r\n</nav>\r\n\r\n<header class=\"header\">\r\n  <section class=\"features container text\">\r\n    <h2>Features</h2>\r\n    <ul>\r\n      <li>Stick all the things!</li>\r\n      <li>Super smooth!</li>\r\n      <li>Tested in real world projects</li>\r\n      <li>Support for <strong>Angular Universal</strong></li>\r\n      <li>Prevents page-jumping when switching to sticky mode</li>\r\n      <li>No jQuery or other dependencies - <strong>pure Angular</strong> solution</li>\r\n      <li>Support for boundaries to make elements stop.</li>\r\n    </ul>\r\n  </section>\r\n  <section class=\"installation container text\">\r\n    <h2>Installation</h2>\r\n    <p>with npm:</p>\r\n    <pre data-header=\"shell\" class=\"code\"><code>npm install @enten/ngx-sticky</code></pre>\r\n    <p>with yarn:</p>\r\n    <pre data-header=\"shell\" class=\"code\"><code>yarn add @enten/ngx-sticky</code></pre>\r\n    <p>Now import the <code>NgxStickyModule</code> in the corresponding Module</p>\r\n    <pre data-header=\"ts\" class=\"code\"><code><span class=\"ts-keyword\">import</span> <span class=\"ts-sign\">{{ '{' }}</span> <span class=\"ts-user-declaration\">NgxStickyModule</span> <span class=\"ts-sign\">{{ '}' }}</span> <span class=\"ts-keyword\">from</span> <span class=\"ts-sign\">'</span><span class=\"ts-string\">@enten/ngx-sticky</span><span class=\"ts-sign\">';</span>\r\n\r\n<span class=\"ts-decorator\">@NgModule</span><span class=\"ts-sign\">({{ '{' }}</span>\r\n  imports<span class=\"ts-sign\">: [</span>\r\n    <span class=\"ts-user-declaration\">NgxStickyModule</span><span class=\"ts-sign\">,</span> \r\n  <span class=\"ts-sign\">],</span> \r\n  declarations<span class=\"ts-sign\">: [],</span>\r\n  providers<span class=\"ts-sign\">: [],</span>\r\n<span class=\"ts-sign\">{{ '}' }})</span>\r\n<span class=\"ts-keyword\">export</span> <span class=\"ts-keyword\">class</span> <span class=\"ts-user-declaration\">SomeModule</span> <span class=\"ts-sign\">{{ '{ }' }}</span></code></pre>\r\n  </section>\r\n  <section class=\"usage container text\">\r\n    <h2>Usage</h2>\r\n    <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n  </section>\r\n  <section class=\"more container text\">\r\n    <h2>More</h2>\r\n    <div>\r\n      For more information see: <a href=\"https://github.com/enten/ngx-sticky\">https://github.com/enten/ngx-sticky</a>.\r\n    </div>\r\n  </section>\r\n</header>\r\n\r\n<section class=\"examples\">\r\n  <div class=\"container\">\r\n    <h2>Examples</h2>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">stickyDisabled</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [value]=\"exampleSticky1.disabled\" (change)=\"exampleSticky1.config$.nextKeyValue('disabled', $event.target.checked)\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/p&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <p ngx-sticky #exampleSticky1=\"ngxSticky\">\r\n            I am sticky!\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky inside boundary</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-attr\">stickyDisabled</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [value]=\"exampleStickyOutsideBoundary.disabled\" (change)=\"exampleStickyOutsideBoundary.config$.nextKeyValue('disabled', $event.target.checked)\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/p&gt;</span>\r\n\r\n<span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\r\n    Sticky inside boundary\r\n  <span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <p #exampleStickyOutsideBoundary=\"ngxSticky\" ngx-sticky>I am sticky!</p>\r\n          <div ngx-sticky-boundary style=\"margin: 5rem auto; height: 30rem; width: 80%;\">\r\n            <p ngx-sticky>Sticky inside boundary</p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky boundary unstacked</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span>\r\n  <span class=\"html-attr\">ngx-sticky-boundary</span>\r\n  <span class=\"html-attr\">stickyUnstacked</span><span class=\"html-sign\">=&quot;</span><input type=\"checkbox\" [checked]=\"exampleBoundaryUnstacked.config.unstacked\" (change)=\"exampleBoundaryUnstacked.config$.nextKeyValue('unstacked', $event.target.checked)\"><span class=\"html-sign\">&quot;</span>\r\n<span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>&gt;Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div class=\"preview\">\r\n          <div #exampleBoundaryUnstacked=\"ngxStickyBoundary\" ngx-sticky-boundary stickyUnstacked style=\"margin: 5rem auto; width: 80%;\">\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 1</p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 2</p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky stickyPosition=\"top\" stickyDirection=\"down\">Sticky 3</p>\r\n            <div style=\"height: 5rem\"></div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky position bottom</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Sticky bottom direction up<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">down</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Sticky bottom direction down<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary offsetTop=\"0\" offsetBottom=\"200\" class=\"preview\">\r\n          <div style=\"height: 800px;\"></div>\r\n          <p ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">\r\n            Sticky bottom direction up\r\n          </p>\r\n          <p ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"down\">\r\n            Sticky bottom direction down\r\n          </p>\r\n          <div style=\"height: 800px;\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky container</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-container</span>\r\n  <span class=\"html-attr\">style</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">height: 400px; overflow: auto;</span><span class=\"html-sign\">&quot;</span>\r\n&gt;\r\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">top</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">down</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Header<span class=\"html-tag\">&lt;/header&gt;</span>\r\n  <span class=\"html-tag\">&lt;section</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n    <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;/section&gt;</span>\r\n  <span class=\"html-tag\">&lt;footer</span> <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span>\r\n    <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>Footer<span class=\"html-tag\">&lt;/div&gt;</span>\r\n<span class=\"html-tag\">&lt;/footer&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-container class=\"preview\" style=\"position: relative; overflow: auto; height: 40rem\">\r\n          <header ngx-sticky>Header</header>\r\n          <div style=\"height: 12rem\"></div>\r\n          <section ngx-sticky-boundary style=\"position: relative;\">\r\n            <!-- <p ngx-sticky style=\"position: absolute; top: 50px; right: 50px; width: 50px; height: 50px; padding: 0; background: lightsteelblue;\">\r\n              Sticky\r\n            </p> -->\r\n            <div style=\"height: 10rem;\"></div>\r\n            <p ngx-sticky>Sticky 1</p>\r\n            <div style=\"height: 5rem;\"></div>\r\n            <p ngx-sticky>Sticky 2</p>\r\n            <div style=\"height: 5rem;\"></div>\r\n            <p ngx-sticky stickyPosition=\"bottom\">Sticky 3</p>\r\n            <div style=\"height: 10rem;\"></div>\r\n          </section>\r\n          <div style=\"height: 36rem\"></div>\r\n          <footer ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">Footer</footer>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example sticky-classes\">\r\n      <h3>Sticky classes</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">container</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">header</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>Header<span class=\"html-tag\">&lt;/header&gt;</span>\r\n  <span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">#headerSticky</span>\r\n    <span class=\"html-attr\">ngx-sticky</span>\r\n    <span class=\"html-attr\">stickyClasses</span>\r\n    <span class=\"html-attr\">class</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">header-sticky</span><span class=\"html-sign\">&quot;</span>\r\n  <span class=\"html-tag\">&gt;</span>\r\n    {{ '{{' }} headerSticky.className {{ '\\}\\}' }}\r\n  <span class=\"html-tag\">&lt;/div&gt;</span>\r\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p&gt;&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span>\r\n\r\n<span class=\"html-tag\">&lt;style&gt;</span>\r\n.container {{ '{' }}\r\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">relative</span>;\r\n{{ '\\}' }}\r\n.header {{ '{' }}\r\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">relative</span>;\r\n  <span class=\"css-prop\">z-index</span>: <span class=\"css-user-value\">2</span>;\r\n{{ '\\}' }}\r\n.header-sticky {{ '{' }}\r\n  <span class=\"css-prop\">display</span>: <span class=\"css-value\">none</span>;\r\n  <span class=\"css-prop\">position</span>: <span class=\"css-value\">absolute</span>;\r\n  <span class=\"css-prop\">transform</span>: <span class=\"css-user-value\">translateY(-100%)</span>;\r\n  <span class=\"css-prop\">transition</span>: <span class=\"css-user-value\">transform 0.3s</span>;\r\n  <span class=\"css-prop\">width</span>: <span class=\"css-user-value\">100%</span>;\r\n  <span class=\"css-prop\">z-index</span>: <span class=\"css-user-value\">1</span>;\r\n{{ '\\}' }}\r\n.header-sticky:not(.ngx-sticky--disabled) {{ '{' }}\r\n  <span class=\"css-prop\">display</span>: <span class=\"css-value\">block</span>;\r\n{{ '\\}' }}\r\n.header-sticky:not(.ngx-sticky--normal) {{ '{' }}\r\n  <span class=\"css-prop\">transform</span>: <span class=\"css-user-value\">translateY(0%)</span>;\r\n{{ '\\}' }}\r\n<span class=\"html-tag\">&lt;/style&gt;</span>\r\n</code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <header style=\"padding: 2rem 1rem\">Header</header>\r\n          <div #exampleStickyClasses=\"ngxSticky\" ngx-sticky stickyClasses stickyDisabled=\"false\" class=\"header-sticky\">.ngx-sticky--{{ exampleStickyClasses.state }}</div>\r\n          <p></p>\r\n          <p></p>\r\n          <p></p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"example\">\r\n      <h3>Sticky with spot</h3>\r\n      <div class=\"sidepanes\">\r\n        <div ngx-sticky-boundary class=\"controls\">\r\n          <pre ngx-sticky [stickyDisabled]=\"_isSmallScreen\" data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">[stickySpot]</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">spot</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n    Sticky with spot\r\n  <span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">[style.height.px]</span><span class=\"html-sign\">=&quot;</span><input #stickyWithSpotBlankHeight type=\"number\" value=\"1500\" class=\"html-attr-value\" style=\"width: 5rem;\" (change)=\"changeDetectorRef.detectChanges(); exampleStickyWithSpot.update()\"><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;/div&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">#spot</span><span class=\"html-tag\">&gt;</span>Spot<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n        </div>\r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <p #exampleStickyWithSpot=\"ngxSticky\" ngx-sticky [stickySpot]=\"spot\">Sticky with spot</p>\r\n          <div [style.height.px]=\"stickyWithSpotBlankHeight.value\"></div>\r\n          <div #spot style=\"padding: 2em 1em; background: lightblue;\">\r\n            Spot<br>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n</section>\r\n\r\n<section class=\"api\">\r\n  <div class=\"container\">\r\n    <h2>API</h2>\r\n\r\n    <div>\r\n      <h3>NgxStickyDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\" ngx-sticky-boundary>\r\n          <div ngx-sticky [stickyDisabled]=\"_isSmallScreen\">\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiSticky.disabled\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('disabled', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiSticky.config.position\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('position', $event.target.value)\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiSticky.config.direction\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('direction', $event.target.value)\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiSticky.config.orbit\"\r\n                  (change)=\"apiSticky.config$.nextKeyValue('orbit', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                outputs\r\n              </div>\r\n              <div>\r\n                <label>stickyState</label>\r\n                {{ apiSticky.state }}\r\n              </div>\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>enableSticky</label>\r\n                <button (click)=\"apiSticky.enableSticky()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>disableSticky</label>\r\n                <button (click)=\"apiSticky.disableSticky()\">call</button>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>update</label>\r\n                <button (click)=\"apiSticky.update()\">call</button>\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div ngx-sticky-boundary class=\"preview\">\r\n          <div style=\"height: 15rem;\"></div>\r\n          <p #apiSticky=\"ngxSticky\" ngx-sticky>\r\n            I am sticky!\r\n          </p>\r\n          <div style=\"height: 15rem;\"></div>\r\n        </div>\r\n      </div>\r\n  \r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;p</span> <span class=\"html-attr\">ngx-sticky</span><span *ngIf=\"apiSticky.disabled\" class=\"html-attr\"> stickyDisabled</span><!--<span *ngIf=\"apiSticky.config.orbit\" class=\"html-attr\"> stickyOrbit</span>--><ng-container *ngIf=\"apiSticky.config.position === 'bottom'\"><span class=\"html-attr\"> stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span></ng-container><ng-container *ngIf=\"apiSticky.config.direction === 'up'\"><span class=\"html-attr\"> stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span></ng-container><span class=\"html-tag\">&gt;</span>\r\n  I am sticky!\r\n<span class=\"html-tag\">&lt;/p&gt;</span></code></pre>\r\n    </div>\r\n\r\n    <div>\r\n      <h3>NgxStickyBoundaryDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\" ngx-sticky-boundary>\r\n          <div ngx-sticky [stickyDisabled]=\"_isSmallScreen\">\r\n            <div class=\"controls-header\">\r\n              ngx-sticky-boundary\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>stickyUnstacked</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiBoundary.config.unstacked\"\r\n                  (change)=\"apiBoundary.config$.nextKeyValue('unstacked', $event.target.checked)\"\r\n                >\r\n              </div>\r\n            </div>\r\n            <!--\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>updateStickies</label>\r\n                <button (click)=\"apiBoundary.updateStickies()\">call</button>\r\n              </div>\r\n            </div>\r\n            -->\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiBoundaryStickyDisabled\"\r\n                  (change)=\"apiBoundaryStickyDisabled = !apiBoundaryStickyDisabled\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiBoundaryStickyPosition\"\r\n                  (change)=\"apiBoundaryStickyPosition = $event.target.value\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiBoundaryStickyDirection\"\r\n                  (change)=\"apiBoundaryStickyDirection = $event.target.value\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"stickyOrbit\"\r\n                  (change)=\"stickyOrbit = !stickyOrbit\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div class=\"preview\">\r\n          <div style=\"height: 5rem;\"></div>\r\n          <div #apiBoundary=\"ngxStickyBoundary\" ngx-sticky-boundary>\r\n            <div style=\"height: 10rem;\"></div>\r\n            <p ngx-sticky\r\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\r\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\r\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\r\n            >\r\n              Sticky 1\r\n            </p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky\r\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\r\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\r\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\r\n            >\r\n              Sticky 2\r\n            </p>\r\n            <div style=\"height: 5rem\"></div>\r\n            <p ngx-sticky\r\n              [stickyDisabled]=\"apiBoundaryStickyDisabled\"\r\n              [stickyPosition]=\"apiBoundaryStickyPosition\"\r\n              [stickyDirection]=\"apiBoundaryStickyDirection\"\r\n            >\r\n              Sticky 3\r\n            </p>\r\n            <div style=\"height: 10rem;\"></div>\r\n          </div>\r\n          <div style=\"height: 5rem;\"></div>\r\n        </div>\r\n      </div>\r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-boundary</span><span *ngIf=\"apiBoundary.config.unstacked\" class=\"html-attr\"> stickyUnstacked</span><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n    </div>\r\n\r\n    <div>\r\n      <h3>NgxStickyContainerDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\">\r\n          <div>\r\n            <div class=\"controls-header\">\r\n              ngx-sticky-container\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiContainer.disabled\"\r\n                  (change)=\"apiContainer.config$.nextKeyValue('disabled', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyOffsetTop</label>\r\n                <input type=\"number\"\r\n                  [value]=\"apiContainerStickyOffsetTop\"\r\n                  (change)=\"apiContainerStickyOffsetTop = +$event.target.value\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyOffsetBottom</label>\r\n                <input type=\"number\"\r\n                  [value]=\"apiContainerStickyOffsetBottom\"\r\n                  (change)=\"apiContainerStickyOffsetBottom = +$event.target.value\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyUnstacked</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiContainer.config.unstacked\"\r\n                  (change)=\"apiContainer.config$.nextKeyValue('unstacked', $event.target.checked)\"\r\n                >\r\n              </div>\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>enableStickies</label>\r\n                <button (click)=\"apiContainer.enableStickies()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>disableStickies</label>\r\n                <button (click)=\"apiContainer.disableStickies()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>scrollToTop</label>\r\n                <button (click)=\"apiContainer.scrollToTop('#apiContainerScrollTarget')\">call</button>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>updateStickies</label>\r\n                <button (click)=\"apiContainer.updateStickies()\">call</button>\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiContainerStickyDisabled\"\r\n                  (change)=\"apiContainerStickyDisabled = !apiContainerStickyDisabled\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiContainerStickyPosition\"\r\n                  (change)=\"apiContainerStickyPosition = $event.target.value\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiContainerStickyDirection\"\r\n                  (change)=\"apiContainerStickyDirection = $event.target.value\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"stickyOrbit\"\r\n                  (change)=\"stickyOrbit = !stickyOrbit\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div #apiContainer=\"ngxStickyContainer\" ngx-sticky-container\r\n          [stickyOffsetTop]=\"apiContainerStickyOffsetTop\"\r\n          [stickyOffsetBottom]=\"apiContainerStickyOffsetBottom\"\r\n          class=\"preview\"\r\n          style=\"position: relative; height: 40rem; overflow: auto;\"\r\n        >\r\n          <header ngx-sticky>\r\n            Header\r\n          </header>\r\n          <div style=\"height: 30rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\r\n            [stickyPosition]=\"apiContainerStickyPosition\"\r\n            [stickyDirection]=\"apiContainerStickyDirection\"\r\n          >\r\n            Sticky 1\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\r\n            [stickyPosition]=\"apiContainerStickyPosition\"\r\n            [stickyDirection]=\"apiContainerStickyDirection\"\r\n          >\r\n            Sticky 2\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiContainerStickyDisabled\"\r\n            [stickyPosition]=\"apiContainerStickyPosition\"\r\n            [stickyDirection]=\"apiContainerStickyDirection\"\r\n          >\r\n            Sticky 3\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p id=\"apiContainerScrollTarget\" style=\"background: lightblue; opacity: 1;\">Scroll target</p>\r\n          <div style=\"height: 40rem;\"></div>\r\n          <footer ngx-sticky stickyPosition=\"bottom\" stickyDirection=\"up\">\r\n            Footer\r\n          </footer>\r\n        </div>\r\n      </div>\r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-sticky-container</span><span *ngIf=\"apiContainer.disabled\" class=\"html-attr\"> stickyDisabled</span><span *ngIf=\"apiContainer.config.unstacked\" class=\"html-attr\"> stickyUnstacked</span><ng-container *ngIf=\"apiContainerStickyOffsetTop\" ><span class=\"html-attr\"> stickyOffsetTop</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiContainerStickyOffsetTop }}</span><span class=\"html-sign\">&quot;</span></ng-container><ng-container *ngIf=\"apiContainerStickyOffsetBottom\"><span class=\"html-attr\"> stickyOffsetBottom</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiContainerStickyOffsetBottom }}</span><span class=\"html-sign\">&quot;</span></ng-container><span class=\"html-tag\">&gt;</span>\r\n  <span class=\"html-tag\">&lt;header</span> <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>\r\n    Header\r\n  <span class=\"html-tag\">&lt;/header&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 1<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 2<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;p</span>  <span class=\"html-attr\">ngx-sticky</span><span class=\"html-tag\">&gt;</span>Sticky 3<span class=\"html-tag\">&lt;/p&gt;</span>\r\n  <span class=\"html-tag\">&lt;footer</span> <span class=\"html-attr\">ngx-sticky</span> <span class=\"html-attr\">stickyPosition</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">bottom</span><span class=\"html-sign\">&quot;</span> <span class=\"html-attr\">stickyDirection</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">up</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n    Footer\r\n  <span class=\"html-tag\">&lt;/footer&gt;</span>\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n    </div>\r\n\r\n    <div>\r\n      <h3>NgxInViewportDirective</h3>\r\n      <div class=\"sidepanes\">\r\n        <div class=\"controls\">\r\n          <div>\r\n            <div class=\"controls-header\">\r\n              ngx-in-viewport\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                inputs\r\n              </div>\r\n              <div>\r\n                <label>intersectionDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiInViewport.disabled\"\r\n                  (change)=\"apiInViewport.config$.nextKeyValue('disabled', $event.target.checked)\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>intersectionThresholds</label>\r\n                <input type=\"text\"\r\n                  [value]=\"apiInViewport.config.thresholds.join(',')\"\r\n                  (change)=\"apiInViewport.config$.nextKeyValue('thresholds', $event.target.value)\"\r\n                >\r\n              </div>\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                methods\r\n              </div>\r\n              <div>\r\n                <label>enableIntersection</label>\r\n                <button (click)=\"apiInViewport.enableIntersection()\">call</button>\r\n              </div>\r\n              <div>\r\n                <label>disableIntersection</label>\r\n                <button (click)=\"apiInViewport.disableIntersection()\">call</button>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>update</label>\r\n                <button (click)=\"apiInViewport.update()\">call</button>\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div class=\"controls-group-header\">\r\n                outputs\r\n              </div>\r\n              <div>\r\n                <label>intersectionState</label>\r\n                {{ apiInViewport.state || 'null' }}\r\n              </div>\r\n              <div>\r\n                <label>intersectionThreshold</label>\r\n                {{ apiInViewport._intersectionThreshold }}\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>intersectionComputation</label>\r\n                <pre class=\"code\" style=\"margin: 0\"><code>{{ getIntersectionComputationAsText() }}</code></pre>\r\n              </div>\r\n              -->\r\n            </div>\r\n            <div class=\"controls-header\">\r\n              ngx-sticky\r\n            </div>\r\n            <div class=\"controls-group\">\r\n              <div>\r\n                <label>stickyDisabled</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiInViewportStickyDisabled\"\r\n                  (change)=\"apiInViewportStickyDisabled = !apiInViewportStickyDisabled\"\r\n                >\r\n              </div>\r\n              <div>\r\n                <label>stickyPosition</label>\r\n                <select\r\n                  [value]=\"apiInViewportStickyPosition\"\r\n                  (change)=\"apiInViewportStickyPosition = $event.target.value\"\r\n                >\r\n                  <option value=\"top\">top</option>\r\n                  <option value=\"bottom\">bottom</option>\r\n                </select>\r\n              </div>\r\n              <div>\r\n                <label>stickyDirection</label>\r\n                <select\r\n                  [value]=\"apiInViewportStickyDirection\"\r\n                  (change)=\"apiInViewportStickyDirection = $event.target.value\"\r\n                >\r\n                  <option value=\"up\">up</option>\r\n                  <option value=\"down\">down</option>\r\n                </select>\r\n              </div>\r\n              <!--\r\n              <div>\r\n                <label>stickyOrbit</label>\r\n                <input type=\"checkbox\"\r\n                  [checked]=\"apiInViewportStickyOrbit\"\r\n                  (change)=\"apiInViewportStickyOrbit = !apiInViewportStickyOrbit\"\r\n                >\r\n              </div>\r\n              -->\r\n            </div>\r\n          </div>\r\n        </div>\r\n  \r\n        <div #container=\"ngxStickyContainer\" ngx-sticky-container class=\"preview\" style=\"position: relative; height: 40rem; overflow: auto;\">\r\n          <header ngx-sticky>\r\n            Header\r\n          </header>\r\n          <div style=\"height: 30rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\r\n            [stickyPosition]=\"apiInViewportStickyPosition\"\r\n            [stickyDirection]=\"apiInViewportStickyDirection\"\r\n          >\r\n            Sticky 1\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\r\n            [stickyPosition]=\"apiInViewportStickyPosition\"\r\n            [stickyDirection]=\"apiInViewportStickyDirection\"\r\n          >\r\n            Sticky 2\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p #apiInViewport=\"ngxInViewport\" ngx-in-viewport style=\"opacity: 1; padding: 8rem 1rem; background: lightblue; text-align: center\">\r\n            In viewport element\r\n          </p>\r\n          <div style=\"height: 5rem;\"></div>\r\n          <p ngx-sticky\r\n            [stickyDisabled]=\"apiInViewportStickyDisabled\"\r\n            [stickyPosition]=\"apiInViewportStickyPosition\"\r\n            [stickyDirection]=\"apiInViewportStickyDirection\"\r\n          >\r\n            Sticky 3\r\n          </p>\r\n          <div style=\"height: 40rem;\"></div>\r\n          <footer ngx-sticky\r\n            stickyPosition=\"bottom\"\r\n            stickyDirection=\"up\"\r\n            style=\"margin-bottom: 0;\"\r\n          >\r\n            Footer\r\n          </footer>\r\n        </div>\r\n      </div>\r\n      <pre data-header=\"html\" class=\"code\"><code><span class=\"html-tag\">&lt;div</span> <span class=\"html-attr\">ngx-in-viewport</span><span *ngIf=\"apiInViewport.disabled\" class=\"html-attr\"> intersectionDisabled</span><span class=\"html-attr\"> intersectionThresholds</span><span class=\"html-sign\">=&quot;</span><span class=\"html-attr-value\">{{ apiInViewport.config.thresholds.join(',') }}</span><span class=\"html-sign\">&quot;</span><span class=\"html-tag\">&gt;</span>\r\n  in viewport element\r\n<span class=\"html-tag\">&lt;/div&gt;</span></code></pre>\r\n    </div>\r\n  </div>\r\n</section>\r\n\r\n<footer class=\"footer\">\r\n  <p class=\"container\">made with  by <a href=\"http://enten.fr\">enten</a></p>\r\n</footer>\r\n  \r\n  ","import { NgModule } from '@angular/core';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\n\r\nimport { NgxStickyModule } from '../../projects/ngx-sticky/src/public-api';\r\n\r\nimport { AppRoutingModule } from './app-routing.module';\r\nimport { AppComponent } from './app.component';\r\n\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    AppRoutingModule,\r\n    NgxStickyModule,\r\n  ],\r\n  providers: [],\r\n  bootstrap: [ AppComponent ],\r\n})\r\nexport class AppModule { }\r\n","export const environment = {\r\n  production: true,\r\n};\r\n","import { enableProdMode } from '@angular/core';\r\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n\r\nimport { AppModule } from './app/app.module';\r\nimport { environment } from './environments/environment';\r\n\r\nif (environment.production) {\r\n  enableProdMode();\r\n}\r\n\r\nplatformBrowserDynamic().bootstrapModule(AppModule)\r\n  .catch(err => console.error(err));\r\n"]}